
type __ = Obj.t

val negb : bool -> bool

type nat =
| O
| S of nat

val option_map : ('a1 -> 'a2) -> 'a1 option -> 'a2 option

val fst : ('a1 * 'a2) -> 'a1

val snd : ('a1 * 'a2) -> 'a2

val length : 'a1 list -> nat

val app : 'a1 list -> 'a1 list -> 'a1 list

type comparison =
| Eq
| Lt
| Gt

val compOpp : comparison -> comparison

type compareSpecT =
| CompEqT
| CompLtT
| CompGtT

val compareSpec2Type : comparison -> compareSpecT

type 'a compSpecT = compareSpecT

val compSpec2Type : 'a1 -> 'a1 -> comparison -> 'a1 compSpecT

type ('a, 'p) sigT =
| ExistT of 'a * 'p



type uint =
| Nil
| D0 of uint
| D1 of uint
| D2 of uint
| D3 of uint
| D4 of uint
| D5 of uint
| D6 of uint
| D7 of uint
| D8 of uint
| D9 of uint

type int =
| Pos of uint
| Neg of uint

val add : nat -> nat -> nat

val max : nat -> nat -> nat

val min : nat -> nat -> nat

module type DecidableTypeOrig =
 sig
  type t

  val eq_dec : t -> t -> bool
 end

module type EqLtLe =
 sig
  type t
 end

module type OrderedType =
 sig
  type t

  val compare : t -> t -> comparison

  val eq_dec : t -> t -> bool
 end

module type OrderedType' =
 sig
  type t

  val compare : t -> t -> comparison

  val eq_dec : t -> t -> bool
 end

module OT_to_Full :
 functor (O:OrderedType') ->
 sig
  type t = O.t

  val compare : t -> t -> comparison

  val eq_dec : t -> t -> bool
 end

module MakeOrderTac :
 functor (O:EqLtLe) ->
 functor (P:sig
 end) ->
 sig
 end

module OT_to_OrderTac :
 functor (OT:OrderedType) ->
 sig
  module OTF :
   sig
    type t = OT.t

    val compare : t -> t -> comparison

    val eq_dec : t -> t -> bool
   end

  module TO :
   sig
    type t = OTF.t

    val compare : t -> t -> comparison

    val eq_dec : t -> t -> bool
   end
 end

module OrderedTypeFacts :
 functor (O:OrderedType') ->
 sig
  module OrderTac :
   sig
    module OTF :
     sig
      type t = O.t

      val compare : t -> t -> comparison

      val eq_dec : t -> t -> bool
     end

    module TO :
     sig
      type t = OTF.t

      val compare : t -> t -> comparison

      val eq_dec : t -> t -> bool
     end
   end

  val eq_dec : O.t -> O.t -> bool

  val lt_dec : O.t -> O.t -> bool

  val eqb : O.t -> O.t -> bool
 end

module Nat :
 sig
  val eqb : nat -> nat -> bool

  val leb : nat -> nat -> bool

  val ltb : nat -> nat -> bool
 end

val map : ('a1 -> 'a2) -> 'a1 list -> 'a2 list

val fold_right : ('a2 -> 'a1 -> 'a1) -> 'a1 -> 'a2 list -> 'a1

val filter : ('a1 -> bool) -> 'a1 list -> 'a1 list

type positive =
| XI of positive
| XO of positive
| XH

type n =
| N0
| Npos of positive

type z =
| Z0
| Zpos of positive
| Zneg of positive

module Pos :
 sig
  val succ : positive -> positive

  val add : positive -> positive -> positive

  val add_carry : positive -> positive -> positive

  val pred_double : positive -> positive

  val pred : positive -> positive

  val mul : positive -> positive -> positive

  val compare_cont : comparison -> positive -> positive -> comparison

  val compare : positive -> positive -> comparison

  val eqb : positive -> positive -> bool

  val of_succ_nat : nat -> positive

  val of_uint_acc : uint -> positive -> positive

  val of_uint : uint -> n

  val eq_dec : positive -> positive -> bool
 end

module N :
 sig
  val of_nat : nat -> n
 end

module Z :
 sig
  val double : z -> z

  val succ_double : z -> z

  val pred_double : z -> z

  val pos_sub : positive -> positive -> z

  val add : z -> z -> z

  val opp : z -> z

  val succ : z -> z

  val pred : z -> z

  val sub : z -> z -> z

  val mul : z -> z -> z

  val compare : z -> z -> comparison

  val leb : z -> z -> bool

  val ltb : z -> z -> bool

  val eqb : z -> z -> bool

  val max : z -> z -> z

  val of_N : n -> z

  val of_uint : uint -> z

  val of_int : int -> z

  val eq_dec : z -> z -> bool
 end

val zero : char

val one : char

val shift : bool -> char -> char

val ascii_of_pos : positive -> char

val ascii_of_N : n -> char

val ascii_of_nat : nat -> char

val string_of_list_ascii : char list -> char list

val list_ascii_of_string : char list -> char list

val uint_of_char : char -> uint option -> uint option

module NilEmpty :
 sig
  val uint_of_string : char list -> uint option

  val int_of_string : char list -> int option
 end

type 'x compare0 =
| LT
| EQ
| GT

module type Coq_OrderedType =
 sig
  type t

  val compare : t -> t -> t compare0

  val eq_dec : t -> t -> bool
 end

module Coq_OrderedTypeFacts :
 functor (O:Coq_OrderedType) ->
 sig
  module TO :
   sig
    type t = O.t
   end

  module IsTO :
   sig
   end

  module OrderTac :
   sig
   end

  val eq_dec : O.t -> O.t -> bool

  val lt_dec : O.t -> O.t -> bool

  val eqb : O.t -> O.t -> bool
 end

module KeyOrderedType :
 functor (O:Coq_OrderedType) ->
 sig
  module MO :
   sig
    module TO :
     sig
      type t = O.t
     end

    module IsTO :
     sig
     end

    module OrderTac :
     sig
     end

    val eq_dec : O.t -> O.t -> bool

    val lt_dec : O.t -> O.t -> bool

    val eqb : O.t -> O.t -> bool
   end
 end

module type UsualOrderedType =
 sig
  type t

  val compare : t -> t -> t compare0

  val eq_dec : t -> t -> bool
 end

module type DecidableType =
 DecidableTypeOrig

module type WS =
 sig
  module E :
   DecidableType

  type elt = E.t

  type t

  val empty : t

  val is_empty : t -> bool

  val mem : elt -> t -> bool

  val add : elt -> t -> t

  val singleton : elt -> t

  val remove : elt -> t -> t

  val union : t -> t -> t

  val inter : t -> t -> t

  val diff : t -> t -> t

  val eq_dec : t -> t -> bool

  val equal : t -> t -> bool

  val subset : t -> t -> bool

  val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

  val for_all : (elt -> bool) -> t -> bool

  val exists_ : (elt -> bool) -> t -> bool

  val filter : (elt -> bool) -> t -> t

  val partition : (elt -> bool) -> t -> t * t

  val cardinal : t -> nat

  val elements : t -> elt list

  val choose : t -> elt option
 end

module WFacts_fun :
 functor (E:DecidableType) ->
 functor (M:sig
  type elt = E.t

  type t

  val empty : t

  val is_empty : t -> bool

  val mem : elt -> t -> bool

  val add : elt -> t -> t

  val singleton : elt -> t

  val remove : elt -> t -> t

  val union : t -> t -> t

  val inter : t -> t -> t

  val diff : t -> t -> t

  val eq_dec : t -> t -> bool

  val equal : t -> t -> bool

  val subset : t -> t -> bool

  val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

  val for_all : (elt -> bool) -> t -> bool

  val exists_ : (elt -> bool) -> t -> bool

  val filter : (elt -> bool) -> t -> t

  val partition : (elt -> bool) -> t -> t * t

  val cardinal : t -> nat

  val elements : t -> elt list

  val choose : t -> elt option
 end) ->
 sig
  val eqb : E.t -> E.t -> bool
 end

module WFacts :
 functor (M:WS) ->
 sig
  val eqb : M.E.t -> M.E.t -> bool
 end

module Facts :
 functor (M:WS) ->
 sig
  val eqb : M.E.t -> M.E.t -> bool
 end

module MakeListOrdering :
 functor (O:OrderedType) ->
 sig
  module MO :
   sig
    module OrderTac :
     sig
      module OTF :
       sig
        type t = O.t

        val compare : t -> t -> comparison

        val eq_dec : t -> t -> bool
       end

      module TO :
       sig
        type t = OTF.t

        val compare : t -> t -> comparison

        val eq_dec : t -> t -> bool
       end
     end

    val eq_dec : O.t -> O.t -> bool

    val lt_dec : O.t -> O.t -> bool

    val eqb : O.t -> O.t -> bool
   end
 end

module type OrderedTypeOrig =
 Coq_OrderedType

module Update_OT :
 functor (O:OrderedTypeOrig) ->
 sig
  type t = O.t

  val eq_dec : t -> t -> bool

  val compare : O.t -> O.t -> comparison
 end

module type Int =
 sig
  type t

  val i2z : t -> z

  val _0 : t

  val _1 : t

  val _2 : t

  val _3 : t

  val add : t -> t -> t

  val opp : t -> t

  val sub : t -> t -> t

  val mul : t -> t -> t

  val max : t -> t -> t

  val eqb : t -> t -> bool

  val ltb : t -> t -> bool

  val leb : t -> t -> bool

  val gt_le_dec : t -> t -> bool

  val ge_lt_dec : t -> t -> bool

  val eq_dec : t -> t -> bool
 end

module Z_as_Int :
 sig
  type t = z

  val _0 : z

  val _1 : z

  val _2 : z

  val _3 : z

  val add : z -> z -> z

  val opp : z -> z

  val sub : z -> z -> z

  val mul : z -> z -> z

  val max : z -> z -> z

  val eqb : z -> z -> bool

  val ltb : z -> z -> bool

  val leb : z -> z -> bool

  val eq_dec : z -> z -> bool

  val gt_le_dec : z -> z -> bool

  val ge_lt_dec : z -> z -> bool

  val i2z : t -> z
 end

module MakeRaw :
 functor (I:Int) ->
 functor (X:OrderedType) ->
 sig
  type elt = X.t

  type tree =
  | Leaf
  | Node of I.t * tree * X.t * tree

  val empty : tree

  val is_empty : tree -> bool

  val mem : X.t -> tree -> bool

  val min_elt : tree -> elt option

  val max_elt : tree -> elt option

  val choose : tree -> elt option

  val fold : (elt -> 'a1 -> 'a1) -> tree -> 'a1 -> 'a1

  val elements_aux : X.t list -> tree -> X.t list

  val elements : tree -> X.t list

  val rev_elements_aux : X.t list -> tree -> X.t list

  val rev_elements : tree -> X.t list

  val cardinal : tree -> nat

  val maxdepth : tree -> nat

  val mindepth : tree -> nat

  val for_all : (elt -> bool) -> tree -> bool

  val exists_ : (elt -> bool) -> tree -> bool

  type enumeration =
  | End
  | More of elt * tree * enumeration

  val cons : tree -> enumeration -> enumeration

  val compare_more :
    X.t -> (enumeration -> comparison) -> enumeration -> comparison

  val compare_cont :
    tree -> (enumeration -> comparison) -> enumeration -> comparison

  val compare_end : enumeration -> comparison

  val compare : tree -> tree -> comparison

  val equal : tree -> tree -> bool

  val subsetl : (tree -> bool) -> X.t -> tree -> bool

  val subsetr : (tree -> bool) -> X.t -> tree -> bool

  val subset : tree -> tree -> bool

  type t = tree

  val height : t -> I.t

  val singleton : X.t -> tree

  val create : t -> X.t -> t -> tree

  val assert_false : t -> X.t -> t -> tree

  val bal : t -> X.t -> t -> tree

  val add : X.t -> tree -> tree

  val join : tree -> elt -> t -> t

  val remove_min : tree -> elt -> t -> t * elt

  val merge : tree -> tree -> tree

  val remove : X.t -> tree -> tree

  val concat : tree -> tree -> tree

  type triple = { t_left : t; t_in : bool; t_right : t }

  val t_left : triple -> t

  val t_in : triple -> bool

  val t_right : triple -> t

  val split : X.t -> tree -> triple

  val inter : tree -> tree -> tree

  val diff : tree -> tree -> tree

  val union : tree -> tree -> tree

  val filter : (elt -> bool) -> tree -> tree

  val partition : (elt -> bool) -> t -> t * t

  val ltb_tree : X.t -> tree -> bool

  val gtb_tree : X.t -> tree -> bool

  val isok : tree -> bool

  module MX :
   sig
    module OrderTac :
     sig
      module OTF :
       sig
        type t = X.t

        val compare : t -> t -> comparison

        val eq_dec : t -> t -> bool
       end

      module TO :
       sig
        type t = OTF.t

        val compare : t -> t -> comparison

        val eq_dec : t -> t -> bool
       end
     end

    val eq_dec : X.t -> X.t -> bool

    val lt_dec : X.t -> X.t -> bool

    val eqb : X.t -> X.t -> bool
   end

  type coq_R_min_elt =
  | R_min_elt_0 of tree
  | R_min_elt_1 of tree * I.t * tree * X.t * tree
  | R_min_elt_2 of tree * I.t * tree * X.t * tree * I.t * tree * X.t * 
     tree * elt option * coq_R_min_elt

  type coq_R_max_elt =
  | R_max_elt_0 of tree
  | R_max_elt_1 of tree * I.t * tree * X.t * tree
  | R_max_elt_2 of tree * I.t * tree * X.t * tree * I.t * tree * X.t * 
     tree * elt option * coq_R_max_elt

  module L :
   sig
    module MO :
     sig
      module OrderTac :
       sig
        module OTF :
         sig
          type t = X.t

          val compare : t -> t -> comparison

          val eq_dec : t -> t -> bool
         end

        module TO :
         sig
          type t = OTF.t

          val compare : t -> t -> comparison

          val eq_dec : t -> t -> bool
         end
       end

      val eq_dec : X.t -> X.t -> bool

      val lt_dec : X.t -> X.t -> bool

      val eqb : X.t -> X.t -> bool
     end
   end

  val flatten_e : enumeration -> elt list

  type coq_R_bal =
  | R_bal_0 of t * X.t * t
  | R_bal_1 of t * X.t * t * I.t * tree * X.t * tree
  | R_bal_2 of t * X.t * t * I.t * tree * X.t * tree
  | R_bal_3 of t * X.t * t * I.t * tree * X.t * tree * I.t * tree * X.t * tree
  | R_bal_4 of t * X.t * t
  | R_bal_5 of t * X.t * t * I.t * tree * X.t * tree
  | R_bal_6 of t * X.t * t * I.t * tree * X.t * tree
  | R_bal_7 of t * X.t * t * I.t * tree * X.t * tree * I.t * tree * X.t * tree
  | R_bal_8 of t * X.t * t

  type coq_R_remove_min =
  | R_remove_min_0 of tree * elt * t
  | R_remove_min_1 of tree * elt * t * I.t * tree * X.t * tree * (t * elt)
     * coq_R_remove_min * t * elt

  type coq_R_merge =
  | R_merge_0 of tree * tree
  | R_merge_1 of tree * tree * I.t * tree * X.t * tree
  | R_merge_2 of tree * tree * I.t * tree * X.t * tree * I.t * tree * 
     X.t * tree * t * elt

  type coq_R_concat =
  | R_concat_0 of tree * tree
  | R_concat_1 of tree * tree * I.t * tree * X.t * tree
  | R_concat_2 of tree * tree * I.t * tree * X.t * tree * I.t * tree * 
     X.t * tree * t * elt

  type coq_R_inter =
  | R_inter_0 of tree * tree
  | R_inter_1 of tree * tree * I.t * tree * X.t * tree
  | R_inter_2 of tree * tree * I.t * tree * X.t * tree * I.t * tree * 
     X.t * tree * t * bool * t * tree * coq_R_inter * tree * coq_R_inter
  | R_inter_3 of tree * tree * I.t * tree * X.t * tree * I.t * tree * 
     X.t * tree * t * bool * t * tree * coq_R_inter * tree * coq_R_inter

  type coq_R_diff =
  | R_diff_0 of tree * tree
  | R_diff_1 of tree * tree * I.t * tree * X.t * tree
  | R_diff_2 of tree * tree * I.t * tree * X.t * tree * I.t * tree * 
     X.t * tree * t * bool * t * tree * coq_R_diff * tree * coq_R_diff
  | R_diff_3 of tree * tree * I.t * tree * X.t * tree * I.t * tree * 
     X.t * tree * t * bool * t * tree * coq_R_diff * tree * coq_R_diff

  type coq_R_union =
  | R_union_0 of tree * tree
  | R_union_1 of tree * tree * I.t * tree * X.t * tree
  | R_union_2 of tree * tree * I.t * tree * X.t * tree * I.t * tree * 
     X.t * tree * t * bool * t * tree * coq_R_union * tree * coq_R_union
 end

module IntMake :
 functor (I:Int) ->
 functor (X:OrderedType) ->
 sig
  module Raw :
   sig
    type elt = X.t

    type tree =
    | Leaf
    | Node of I.t * tree * X.t * tree

    val empty : tree

    val is_empty : tree -> bool

    val mem : X.t -> tree -> bool

    val min_elt : tree -> elt option

    val max_elt : tree -> elt option

    val choose : tree -> elt option

    val fold : (elt -> 'a1 -> 'a1) -> tree -> 'a1 -> 'a1

    val elements_aux : X.t list -> tree -> X.t list

    val elements : tree -> X.t list

    val rev_elements_aux : X.t list -> tree -> X.t list

    val rev_elements : tree -> X.t list

    val cardinal : tree -> nat

    val maxdepth : tree -> nat

    val mindepth : tree -> nat

    val for_all : (elt -> bool) -> tree -> bool

    val exists_ : (elt -> bool) -> tree -> bool

    type enumeration =
    | End
    | More of elt * tree * enumeration

    val cons : tree -> enumeration -> enumeration

    val compare_more :
      X.t -> (enumeration -> comparison) -> enumeration -> comparison

    val compare_cont :
      tree -> (enumeration -> comparison) -> enumeration -> comparison

    val compare_end : enumeration -> comparison

    val compare : tree -> tree -> comparison

    val equal : tree -> tree -> bool

    val subsetl : (tree -> bool) -> X.t -> tree -> bool

    val subsetr : (tree -> bool) -> X.t -> tree -> bool

    val subset : tree -> tree -> bool

    type t = tree

    val height : t -> I.t

    val singleton : X.t -> tree

    val create : t -> X.t -> t -> tree

    val assert_false : t -> X.t -> t -> tree

    val bal : t -> X.t -> t -> tree

    val add : X.t -> tree -> tree

    val join : tree -> elt -> t -> t

    val remove_min : tree -> elt -> t -> t * elt

    val merge : tree -> tree -> tree

    val remove : X.t -> tree -> tree

    val concat : tree -> tree -> tree

    type triple = { t_left : t; t_in : bool; t_right : t }

    val t_left : triple -> t

    val t_in : triple -> bool

    val t_right : triple -> t

    val split : X.t -> tree -> triple

    val inter : tree -> tree -> tree

    val diff : tree -> tree -> tree

    val union : tree -> tree -> tree

    val filter : (elt -> bool) -> tree -> tree

    val partition : (elt -> bool) -> t -> t * t

    val ltb_tree : X.t -> tree -> bool

    val gtb_tree : X.t -> tree -> bool

    val isok : tree -> bool

    module MX :
     sig
      module OrderTac :
       sig
        module OTF :
         sig
          type t = X.t

          val compare : t -> t -> comparison

          val eq_dec : t -> t -> bool
         end

        module TO :
         sig
          type t = OTF.t

          val compare : t -> t -> comparison

          val eq_dec : t -> t -> bool
         end
       end

      val eq_dec : X.t -> X.t -> bool

      val lt_dec : X.t -> X.t -> bool

      val eqb : X.t -> X.t -> bool
     end

    type coq_R_min_elt =
    | R_min_elt_0 of tree
    | R_min_elt_1 of tree * I.t * tree * X.t * tree
    | R_min_elt_2 of tree * I.t * tree * X.t * tree * I.t * tree * X.t * 
       tree * elt option * coq_R_min_elt

    type coq_R_max_elt =
    | R_max_elt_0 of tree
    | R_max_elt_1 of tree * I.t * tree * X.t * tree
    | R_max_elt_2 of tree * I.t * tree * X.t * tree * I.t * tree * X.t * 
       tree * elt option * coq_R_max_elt

    module L :
     sig
      module MO :
       sig
        module OrderTac :
         sig
          module OTF :
           sig
            type t = X.t

            val compare : t -> t -> comparison

            val eq_dec : t -> t -> bool
           end

          module TO :
           sig
            type t = OTF.t

            val compare : t -> t -> comparison

            val eq_dec : t -> t -> bool
           end
         end

        val eq_dec : X.t -> X.t -> bool

        val lt_dec : X.t -> X.t -> bool

        val eqb : X.t -> X.t -> bool
       end
     end

    val flatten_e : enumeration -> elt list

    type coq_R_bal =
    | R_bal_0 of t * X.t * t
    | R_bal_1 of t * X.t * t * I.t * tree * X.t * tree
    | R_bal_2 of t * X.t * t * I.t * tree * X.t * tree
    | R_bal_3 of t * X.t * t * I.t * tree * X.t * tree * I.t * tree * 
       X.t * tree
    | R_bal_4 of t * X.t * t
    | R_bal_5 of t * X.t * t * I.t * tree * X.t * tree
    | R_bal_6 of t * X.t * t * I.t * tree * X.t * tree
    | R_bal_7 of t * X.t * t * I.t * tree * X.t * tree * I.t * tree * 
       X.t * tree
    | R_bal_8 of t * X.t * t

    type coq_R_remove_min =
    | R_remove_min_0 of tree * elt * t
    | R_remove_min_1 of tree * elt * t * I.t * tree * X.t * tree * (t * elt)
       * coq_R_remove_min * t * elt

    type coq_R_merge =
    | R_merge_0 of tree * tree
    | R_merge_1 of tree * tree * I.t * tree * X.t * tree
    | R_merge_2 of tree * tree * I.t * tree * X.t * tree * I.t * tree * 
       X.t * tree * t * elt

    type coq_R_concat =
    | R_concat_0 of tree * tree
    | R_concat_1 of tree * tree * I.t * tree * X.t * tree
    | R_concat_2 of tree * tree * I.t * tree * X.t * tree * I.t * tree * 
       X.t * tree * t * elt

    type coq_R_inter =
    | R_inter_0 of tree * tree
    | R_inter_1 of tree * tree * I.t * tree * X.t * tree
    | R_inter_2 of tree * tree * I.t * tree * X.t * tree * I.t * tree * 
       X.t * tree * t * bool * t * tree * coq_R_inter * tree * coq_R_inter
    | R_inter_3 of tree * tree * I.t * tree * X.t * tree * I.t * tree * 
       X.t * tree * t * bool * t * tree * coq_R_inter * tree * coq_R_inter

    type coq_R_diff =
    | R_diff_0 of tree * tree
    | R_diff_1 of tree * tree * I.t * tree * X.t * tree
    | R_diff_2 of tree * tree * I.t * tree * X.t * tree * I.t * tree * 
       X.t * tree * t * bool * t * tree * coq_R_diff * tree * coq_R_diff
    | R_diff_3 of tree * tree * I.t * tree * X.t * tree * I.t * tree * 
       X.t * tree * t * bool * t * tree * coq_R_diff * tree * coq_R_diff

    type coq_R_union =
    | R_union_0 of tree * tree
    | R_union_1 of tree * tree * I.t * tree * X.t * tree
    | R_union_2 of tree * tree * I.t * tree * X.t * tree * I.t * tree * 
       X.t * tree * t * bool * t * tree * coq_R_union * tree * coq_R_union
   end

  module E :
   sig
    type t = X.t

    val compare : t -> t -> comparison

    val eq_dec : t -> t -> bool
   end

  type elt = X.t

  type t_ = Raw.t
    (* singleton inductive, whose constructor was Mkt *)

  val this : t_ -> Raw.t

  type t = t_

  val mem : elt -> t -> bool

  val add : elt -> t -> t

  val remove : elt -> t -> t

  val singleton : elt -> t

  val union : t -> t -> t

  val inter : t -> t -> t

  val diff : t -> t -> t

  val equal : t -> t -> bool

  val subset : t -> t -> bool

  val empty : t

  val is_empty : t -> bool

  val elements : t -> elt list

  val choose : t -> elt option

  val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

  val cardinal : t -> nat

  val filter : (elt -> bool) -> t -> t

  val for_all : (elt -> bool) -> t -> bool

  val exists_ : (elt -> bool) -> t -> bool

  val partition : (elt -> bool) -> t -> t * t

  val eq_dec : t -> t -> bool

  val compare : t -> t -> comparison

  val min_elt : t -> elt option

  val max_elt : t -> elt option
 end

module Coq_IntMake :
 functor (I:Int) ->
 functor (X:Coq_OrderedType) ->
 sig
  module X' :
   sig
    type t = X.t

    val eq_dec : t -> t -> bool

    val compare : X.t -> X.t -> comparison
   end

  module MSet :
   sig
    module Raw :
     sig
      type elt = X.t

      type tree =
      | Leaf
      | Node of I.t * tree * X.t * tree

      val empty : tree

      val is_empty : tree -> bool

      val mem : X.t -> tree -> bool

      val min_elt : tree -> elt option

      val max_elt : tree -> elt option

      val choose : tree -> elt option

      val fold : (elt -> 'a1 -> 'a1) -> tree -> 'a1 -> 'a1

      val elements_aux : X.t list -> tree -> X.t list

      val elements : tree -> X.t list

      val rev_elements_aux : X.t list -> tree -> X.t list

      val rev_elements : tree -> X.t list

      val cardinal : tree -> nat

      val maxdepth : tree -> nat

      val mindepth : tree -> nat

      val for_all : (elt -> bool) -> tree -> bool

      val exists_ : (elt -> bool) -> tree -> bool

      type enumeration =
      | End
      | More of elt * tree * enumeration

      val cons : tree -> enumeration -> enumeration

      val compare_more :
        X.t -> (enumeration -> comparison) -> enumeration -> comparison

      val compare_cont :
        tree -> (enumeration -> comparison) -> enumeration -> comparison

      val compare_end : enumeration -> comparison

      val compare : tree -> tree -> comparison

      val equal : tree -> tree -> bool

      val subsetl : (tree -> bool) -> X.t -> tree -> bool

      val subsetr : (tree -> bool) -> X.t -> tree -> bool

      val subset : tree -> tree -> bool

      type t = tree

      val height : t -> I.t

      val singleton : X.t -> tree

      val create : t -> X.t -> t -> tree

      val assert_false : t -> X.t -> t -> tree

      val bal : t -> X.t -> t -> tree

      val add : X.t -> tree -> tree

      val join : tree -> elt -> t -> t

      val remove_min : tree -> elt -> t -> t * elt

      val merge : tree -> tree -> tree

      val remove : X.t -> tree -> tree

      val concat : tree -> tree -> tree

      type triple = { t_left : t; t_in : bool; t_right : t }

      val t_left : triple -> t

      val t_in : triple -> bool

      val t_right : triple -> t

      val split : X.t -> tree -> triple

      val inter : tree -> tree -> tree

      val diff : tree -> tree -> tree

      val union : tree -> tree -> tree

      val filter : (elt -> bool) -> tree -> tree

      val partition : (elt -> bool) -> t -> t * t

      val ltb_tree : X.t -> tree -> bool

      val gtb_tree : X.t -> tree -> bool

      val isok : tree -> bool

      module MX :
       sig
        module OrderTac :
         sig
          module OTF :
           sig
            type t = X.t

            val compare : X.t -> X.t -> comparison

            val eq_dec : X.t -> X.t -> bool
           end

          module TO :
           sig
            type t = X.t

            val compare : X.t -> X.t -> comparison

            val eq_dec : X.t -> X.t -> bool
           end
         end

        val eq_dec : X.t -> X.t -> bool

        val lt_dec : X.t -> X.t -> bool

        val eqb : X.t -> X.t -> bool
       end

      type coq_R_min_elt =
      | R_min_elt_0 of tree
      | R_min_elt_1 of tree * I.t * tree * X.t * tree
      | R_min_elt_2 of tree * I.t * tree * X.t * tree * I.t * tree * 
         X.t * tree * elt option * coq_R_min_elt

      type coq_R_max_elt =
      | R_max_elt_0 of tree
      | R_max_elt_1 of tree * I.t * tree * X.t * tree
      | R_max_elt_2 of tree * I.t * tree * X.t * tree * I.t * tree * 
         X.t * tree * elt option * coq_R_max_elt

      module L :
       sig
        module MO :
         sig
          module OrderTac :
           sig
            module OTF :
             sig
              type t = X.t

              val compare : X.t -> X.t -> comparison

              val eq_dec : X.t -> X.t -> bool
             end

            module TO :
             sig
              type t = X.t

              val compare : X.t -> X.t -> comparison

              val eq_dec : X.t -> X.t -> bool
             end
           end

          val eq_dec : X.t -> X.t -> bool

          val lt_dec : X.t -> X.t -> bool

          val eqb : X.t -> X.t -> bool
         end
       end

      val flatten_e : enumeration -> elt list

      type coq_R_bal =
      | R_bal_0 of t * X.t * t
      | R_bal_1 of t * X.t * t * I.t * tree * X.t * tree
      | R_bal_2 of t * X.t * t * I.t * tree * X.t * tree
      | R_bal_3 of t * X.t * t * I.t * tree * X.t * tree * I.t * tree * 
         X.t * tree
      | R_bal_4 of t * X.t * t
      | R_bal_5 of t * X.t * t * I.t * tree * X.t * tree
      | R_bal_6 of t * X.t * t * I.t * tree * X.t * tree
      | R_bal_7 of t * X.t * t * I.t * tree * X.t * tree * I.t * tree * 
         X.t * tree
      | R_bal_8 of t * X.t * t

      type coq_R_remove_min =
      | R_remove_min_0 of tree * elt * t
      | R_remove_min_1 of tree * elt * t * I.t * tree * X.t * tree
         * (t * elt) * coq_R_remove_min * t * elt

      type coq_R_merge =
      | R_merge_0 of tree * tree
      | R_merge_1 of tree * tree * I.t * tree * X.t * tree
      | R_merge_2 of tree * tree * I.t * tree * X.t * tree * I.t * tree * 
         X.t * tree * t * elt

      type coq_R_concat =
      | R_concat_0 of tree * tree
      | R_concat_1 of tree * tree * I.t * tree * X.t * tree
      | R_concat_2 of tree * tree * I.t * tree * X.t * tree * I.t * tree
         * X.t * tree * t * elt

      type coq_R_inter =
      | R_inter_0 of tree * tree
      | R_inter_1 of tree * tree * I.t * tree * X.t * tree
      | R_inter_2 of tree * tree * I.t * tree * X.t * tree * I.t * tree * 
         X.t * tree * t * bool * t * tree * coq_R_inter * tree * coq_R_inter
      | R_inter_3 of tree * tree * I.t * tree * X.t * tree * I.t * tree * 
         X.t * tree * t * bool * t * tree * coq_R_inter * tree * coq_R_inter

      type coq_R_diff =
      | R_diff_0 of tree * tree
      | R_diff_1 of tree * tree * I.t * tree * X.t * tree
      | R_diff_2 of tree * tree * I.t * tree * X.t * tree * I.t * tree * 
         X.t * tree * t * bool * t * tree * coq_R_diff * tree * coq_R_diff
      | R_diff_3 of tree * tree * I.t * tree * X.t * tree * I.t * tree * 
         X.t * tree * t * bool * t * tree * coq_R_diff * tree * coq_R_diff

      type coq_R_union =
      | R_union_0 of tree * tree
      | R_union_1 of tree * tree * I.t * tree * X.t * tree
      | R_union_2 of tree * tree * I.t * tree * X.t * tree * I.t * tree * 
         X.t * tree * t * bool * t * tree * coq_R_union * tree * coq_R_union
     end

    module E :
     sig
      type t = X.t

      val compare : X.t -> X.t -> comparison

      val eq_dec : X.t -> X.t -> bool
     end

    type elt = X.t

    type t_ = Raw.t
      (* singleton inductive, whose constructor was Mkt *)

    val this : t_ -> Raw.t

    type t = t_

    val mem : elt -> t -> bool

    val add : elt -> t -> t

    val remove : elt -> t -> t

    val singleton : elt -> t

    val union : t -> t -> t

    val inter : t -> t -> t

    val diff : t -> t -> t

    val equal : t -> t -> bool

    val subset : t -> t -> bool

    val empty : t

    val is_empty : t -> bool

    val elements : t -> elt list

    val choose : t -> elt option

    val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

    val cardinal : t -> nat

    val filter : (elt -> bool) -> t -> t

    val for_all : (elt -> bool) -> t -> bool

    val exists_ : (elt -> bool) -> t -> bool

    val partition : (elt -> bool) -> t -> t * t

    val eq_dec : t -> t -> bool

    val compare : t -> t -> comparison

    val min_elt : t -> elt option

    val max_elt : t -> elt option
   end

  type elt = X.t

  type t = MSet.t

  val empty : t

  val is_empty : t -> bool

  val mem : elt -> t -> bool

  val add : elt -> t -> t

  val singleton : elt -> t

  val remove : elt -> t -> t

  val union : t -> t -> t

  val inter : t -> t -> t

  val diff : t -> t -> t

  val eq_dec : t -> t -> bool

  val equal : t -> t -> bool

  val subset : t -> t -> bool

  val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

  val for_all : (elt -> bool) -> t -> bool

  val exists_ : (elt -> bool) -> t -> bool

  val filter : (elt -> bool) -> t -> t

  val partition : (elt -> bool) -> t -> t * t

  val cardinal : t -> nat

  val elements : t -> elt list

  val choose : t -> elt option

  module MF :
   sig
    val eqb : X.t -> X.t -> bool
   end

  val min_elt : t -> elt option

  val max_elt : t -> elt option

  val compare : t -> t -> t compare0

  module E :
   sig
    type t = X.t

    val compare : t -> t -> t compare0

    val eq_dec : t -> t -> bool
   end
 end

module Make :
 functor (X:Coq_OrderedType) ->
 sig
  module X' :
   sig
    type t = X.t

    val eq_dec : t -> t -> bool

    val compare : X.t -> X.t -> comparison
   end

  module MSet :
   sig
    module Raw :
     sig
      type elt = X.t

      type tree =
      | Leaf
      | Node of Z_as_Int.t * tree * X.t * tree

      val empty : tree

      val is_empty : tree -> bool

      val mem : X.t -> tree -> bool

      val min_elt : tree -> elt option

      val max_elt : tree -> elt option

      val choose : tree -> elt option

      val fold : (elt -> 'a1 -> 'a1) -> tree -> 'a1 -> 'a1

      val elements_aux : X.t list -> tree -> X.t list

      val elements : tree -> X.t list

      val rev_elements_aux : X.t list -> tree -> X.t list

      val rev_elements : tree -> X.t list

      val cardinal : tree -> nat

      val maxdepth : tree -> nat

      val mindepth : tree -> nat

      val for_all : (elt -> bool) -> tree -> bool

      val exists_ : (elt -> bool) -> tree -> bool

      type enumeration =
      | End
      | More of elt * tree * enumeration

      val cons : tree -> enumeration -> enumeration

      val compare_more :
        X.t -> (enumeration -> comparison) -> enumeration -> comparison

      val compare_cont :
        tree -> (enumeration -> comparison) -> enumeration -> comparison

      val compare_end : enumeration -> comparison

      val compare : tree -> tree -> comparison

      val equal : tree -> tree -> bool

      val subsetl : (tree -> bool) -> X.t -> tree -> bool

      val subsetr : (tree -> bool) -> X.t -> tree -> bool

      val subset : tree -> tree -> bool

      type t = tree

      val height : t -> Z_as_Int.t

      val singleton : X.t -> tree

      val create : t -> X.t -> t -> tree

      val assert_false : t -> X.t -> t -> tree

      val bal : t -> X.t -> t -> tree

      val add : X.t -> tree -> tree

      val join : tree -> elt -> t -> t

      val remove_min : tree -> elt -> t -> t * elt

      val merge : tree -> tree -> tree

      val remove : X.t -> tree -> tree

      val concat : tree -> tree -> tree

      type triple = { t_left : t; t_in : bool; t_right : t }

      val t_left : triple -> t

      val t_in : triple -> bool

      val t_right : triple -> t

      val split : X.t -> tree -> triple

      val inter : tree -> tree -> tree

      val diff : tree -> tree -> tree

      val union : tree -> tree -> tree

      val filter : (elt -> bool) -> tree -> tree

      val partition : (elt -> bool) -> t -> t * t

      val ltb_tree : X.t -> tree -> bool

      val gtb_tree : X.t -> tree -> bool

      val isok : tree -> bool

      module MX :
       sig
        module OrderTac :
         sig
          module OTF :
           sig
            type t = X.t

            val compare : X.t -> X.t -> comparison

            val eq_dec : X.t -> X.t -> bool
           end

          module TO :
           sig
            type t = X.t

            val compare : X.t -> X.t -> comparison

            val eq_dec : X.t -> X.t -> bool
           end
         end

        val eq_dec : X.t -> X.t -> bool

        val lt_dec : X.t -> X.t -> bool

        val eqb : X.t -> X.t -> bool
       end

      type coq_R_min_elt =
      | R_min_elt_0 of tree
      | R_min_elt_1 of tree * Z_as_Int.t * tree * X.t * tree
      | R_min_elt_2 of tree * Z_as_Int.t * tree * X.t * tree * Z_as_Int.t
         * tree * X.t * tree * elt option * coq_R_min_elt

      type coq_R_max_elt =
      | R_max_elt_0 of tree
      | R_max_elt_1 of tree * Z_as_Int.t * tree * X.t * tree
      | R_max_elt_2 of tree * Z_as_Int.t * tree * X.t * tree * Z_as_Int.t
         * tree * X.t * tree * elt option * coq_R_max_elt

      module L :
       sig
        module MO :
         sig
          module OrderTac :
           sig
            module OTF :
             sig
              type t = X.t

              val compare : X.t -> X.t -> comparison

              val eq_dec : X.t -> X.t -> bool
             end

            module TO :
             sig
              type t = X.t

              val compare : X.t -> X.t -> comparison

              val eq_dec : X.t -> X.t -> bool
             end
           end

          val eq_dec : X.t -> X.t -> bool

          val lt_dec : X.t -> X.t -> bool

          val eqb : X.t -> X.t -> bool
         end
       end

      val flatten_e : enumeration -> elt list

      type coq_R_bal =
      | R_bal_0 of t * X.t * t
      | R_bal_1 of t * X.t * t * Z_as_Int.t * tree * X.t * tree
      | R_bal_2 of t * X.t * t * Z_as_Int.t * tree * X.t * tree
      | R_bal_3 of t * X.t * t * Z_as_Int.t * tree * X.t * tree * Z_as_Int.t
         * tree * X.t * tree
      | R_bal_4 of t * X.t * t
      | R_bal_5 of t * X.t * t * Z_as_Int.t * tree * X.t * tree
      | R_bal_6 of t * X.t * t * Z_as_Int.t * tree * X.t * tree
      | R_bal_7 of t * X.t * t * Z_as_Int.t * tree * X.t * tree * Z_as_Int.t
         * tree * X.t * tree
      | R_bal_8 of t * X.t * t

      type coq_R_remove_min =
      | R_remove_min_0 of tree * elt * t
      | R_remove_min_1 of tree * elt * t * Z_as_Int.t * tree * X.t * 
         tree * (t * elt) * coq_R_remove_min * t * elt

      type coq_R_merge =
      | R_merge_0 of tree * tree
      | R_merge_1 of tree * tree * Z_as_Int.t * tree * X.t * tree
      | R_merge_2 of tree * tree * Z_as_Int.t * tree * X.t * tree
         * Z_as_Int.t * tree * X.t * tree * t * elt

      type coq_R_concat =
      | R_concat_0 of tree * tree
      | R_concat_1 of tree * tree * Z_as_Int.t * tree * X.t * tree
      | R_concat_2 of tree * tree * Z_as_Int.t * tree * X.t * tree
         * Z_as_Int.t * tree * X.t * tree * t * elt

      type coq_R_inter =
      | R_inter_0 of tree * tree
      | R_inter_1 of tree * tree * Z_as_Int.t * tree * X.t * tree
      | R_inter_2 of tree * tree * Z_as_Int.t * tree * X.t * tree
         * Z_as_Int.t * tree * X.t * tree * t * bool * t * tree * coq_R_inter
         * tree * coq_R_inter
      | R_inter_3 of tree * tree * Z_as_Int.t * tree * X.t * tree
         * Z_as_Int.t * tree * X.t * tree * t * bool * t * tree * coq_R_inter
         * tree * coq_R_inter

      type coq_R_diff =
      | R_diff_0 of tree * tree
      | R_diff_1 of tree * tree * Z_as_Int.t * tree * X.t * tree
      | R_diff_2 of tree * tree * Z_as_Int.t * tree * X.t * tree * Z_as_Int.t
         * tree * X.t * tree * t * bool * t * tree * coq_R_diff * tree
         * coq_R_diff
      | R_diff_3 of tree * tree * Z_as_Int.t * tree * X.t * tree * Z_as_Int.t
         * tree * X.t * tree * t * bool * t * tree * coq_R_diff * tree
         * coq_R_diff

      type coq_R_union =
      | R_union_0 of tree * tree
      | R_union_1 of tree * tree * Z_as_Int.t * tree * X.t * tree
      | R_union_2 of tree * tree * Z_as_Int.t * tree * X.t * tree
         * Z_as_Int.t * tree * X.t * tree * t * bool * t * tree * coq_R_union
         * tree * coq_R_union
     end

    module E :
     sig
      type t = X.t

      val compare : X.t -> X.t -> comparison

      val eq_dec : X.t -> X.t -> bool
     end

    type elt = X.t

    type t_ = Raw.t
      (* singleton inductive, whose constructor was Mkt *)

    val this : t_ -> Raw.t

    type t = t_

    val mem : elt -> t -> bool

    val add : elt -> t -> t

    val remove : elt -> t -> t

    val singleton : elt -> t

    val union : t -> t -> t

    val inter : t -> t -> t

    val diff : t -> t -> t

    val equal : t -> t -> bool

    val subset : t -> t -> bool

    val empty : t

    val is_empty : t -> bool

    val elements : t -> elt list

    val choose : t -> elt option

    val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

    val cardinal : t -> nat

    val filter : (elt -> bool) -> t -> t

    val for_all : (elt -> bool) -> t -> bool

    val exists_ : (elt -> bool) -> t -> bool

    val partition : (elt -> bool) -> t -> t * t

    val eq_dec : t -> t -> bool

    val compare : t -> t -> comparison

    val min_elt : t -> elt option

    val max_elt : t -> elt option
   end

  type elt = X.t

  type t = MSet.t

  val empty : t

  val is_empty : t -> bool

  val mem : elt -> t -> bool

  val add : elt -> t -> t

  val singleton : elt -> t

  val remove : elt -> t -> t

  val union : t -> t -> t

  val inter : t -> t -> t

  val diff : t -> t -> t

  val eq_dec : t -> t -> bool

  val equal : t -> t -> bool

  val subset : t -> t -> bool

  val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

  val for_all : (elt -> bool) -> t -> bool

  val exists_ : (elt -> bool) -> t -> bool

  val filter : (elt -> bool) -> t -> t

  val partition : (elt -> bool) -> t -> t * t

  val cardinal : t -> nat

  val elements : t -> elt list

  val choose : t -> elt option

  module MF :
   sig
    val eqb : X.t -> X.t -> bool
   end

  val min_elt : t -> elt option

  val max_elt : t -> elt option

  val compare : t -> t -> t compare0

  module E :
   sig
    type t = X.t

    val compare : t -> t -> t compare0

    val eq_dec : t -> t -> bool
   end
 end

module type Coq_WS =
 sig
  module E :
   DecidableType

  type key = E.t

  type 'x t

  val empty : 'a1 t

  val is_empty : 'a1 t -> bool

  val add : key -> 'a1 -> 'a1 t -> 'a1 t

  val find : key -> 'a1 t -> 'a1 option

  val remove : key -> 'a1 t -> 'a1 t

  val mem : key -> 'a1 t -> bool

  val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

  val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

  val map2 :
    ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t -> 'a3 t

  val elements : 'a1 t -> (key * 'a1) list

  val cardinal : 'a1 t -> nat

  val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

  val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool
 end

module Raw :
 functor (X:Coq_OrderedType) ->
 sig
  module MX :
   sig
    module TO :
     sig
      type t = X.t
     end

    module IsTO :
     sig
     end

    module OrderTac :
     sig
     end

    val eq_dec : X.t -> X.t -> bool

    val lt_dec : X.t -> X.t -> bool

    val eqb : X.t -> X.t -> bool
   end

  module PX :
   sig
    module MO :
     sig
      module TO :
       sig
        type t = X.t
       end

      module IsTO :
       sig
       end

      module OrderTac :
       sig
       end

      val eq_dec : X.t -> X.t -> bool

      val lt_dec : X.t -> X.t -> bool

      val eqb : X.t -> X.t -> bool
     end
   end

  type key = X.t

  type 'elt t = (X.t * 'elt) list

  val empty : 'a1 t

  val is_empty : 'a1 t -> bool

  val mem : key -> 'a1 t -> bool

  type 'elt coq_R_mem =
  | R_mem_0 of 'elt t
  | R_mem_1 of 'elt t * X.t * 'elt * (X.t * 'elt) list
  | R_mem_2 of 'elt t * X.t * 'elt * (X.t * 'elt) list
  | R_mem_3 of 'elt t * X.t * 'elt * (X.t * 'elt) list * bool * 'elt coq_R_mem

  val coq_R_mem_rect :
    key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1) list
    -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1) list ->
    __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1) list -> __
    -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 t -> bool ->
    'a1 coq_R_mem -> 'a2

  val coq_R_mem_rec :
    key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1) list
    -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1) list ->
    __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1) list -> __
    -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 t -> bool ->
    'a1 coq_R_mem -> 'a2

  val mem_rect :
    key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1) list
    -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1) list ->
    __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1) list -> __
    -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

  val mem_rec :
    key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1) list
    -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1) list ->
    __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1) list -> __
    -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

  val coq_R_mem_correct : key -> 'a1 t -> bool -> 'a1 coq_R_mem

  val find : key -> 'a1 t -> 'a1 option

  type 'elt coq_R_find =
  | R_find_0 of 'elt t
  | R_find_1 of 'elt t * X.t * 'elt * (X.t * 'elt) list
  | R_find_2 of 'elt t * X.t * 'elt * (X.t * 'elt) list
  | R_find_3 of 'elt t * X.t * 'elt * (X.t * 'elt) list * 'elt option
     * 'elt coq_R_find

  val coq_R_find_rect :
    key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1) list
    -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1) list ->
    __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1) list -> __
    -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> 'a1 t ->
    'a1 option -> 'a1 coq_R_find -> 'a2

  val coq_R_find_rec :
    key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1) list
    -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1) list ->
    __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1) list -> __
    -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> 'a1 t ->
    'a1 option -> 'a1 coq_R_find -> 'a2

  val find_rect :
    key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1) list
    -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1) list ->
    __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1) list -> __
    -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

  val find_rec :
    key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1) list
    -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1) list ->
    __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1) list -> __
    -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

  val coq_R_find_correct : key -> 'a1 t -> 'a1 option -> 'a1 coq_R_find

  val add : key -> 'a1 -> 'a1 t -> 'a1 t

  type 'elt coq_R_add =
  | R_add_0 of 'elt t
  | R_add_1 of 'elt t * X.t * 'elt * (X.t * 'elt) list
  | R_add_2 of 'elt t * X.t * 'elt * (X.t * 'elt) list
  | R_add_3 of 'elt t * X.t * 'elt * (X.t * 'elt) list * 'elt t
     * 'elt coq_R_add

  val coq_R_add_rect :
    key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
    list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
    list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
    list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 t
    -> 'a1 t -> 'a1 coq_R_add -> 'a2

  val coq_R_add_rec :
    key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
    list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
    list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
    list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 t
    -> 'a1 t -> 'a1 coq_R_add -> 'a2

  val add_rect :
    key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
    list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
    list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
    list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

  val add_rec :
    key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
    list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
    list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
    list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

  val coq_R_add_correct : key -> 'a1 -> 'a1 t -> 'a1 t -> 'a1 coq_R_add

  val remove : key -> 'a1 t -> 'a1 t

  type 'elt coq_R_remove =
  | R_remove_0 of 'elt t
  | R_remove_1 of 'elt t * X.t * 'elt * (X.t * 'elt) list
  | R_remove_2 of 'elt t * X.t * 'elt * (X.t * 'elt) list
  | R_remove_3 of 'elt t * X.t * 'elt * (X.t * 'elt) list * 'elt t
     * 'elt coq_R_remove

  val coq_R_remove_rect :
    key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1) list
    -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1) list ->
    __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1) list -> __
    -> __ -> __ -> 'a1 t -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t
    -> 'a1 coq_R_remove -> 'a2

  val coq_R_remove_rec :
    key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1) list
    -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1) list ->
    __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1) list -> __
    -> __ -> __ -> 'a1 t -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t
    -> 'a1 coq_R_remove -> 'a2

  val remove_rect :
    key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1) list
    -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1) list ->
    __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1) list -> __
    -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

  val remove_rec :
    key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1) list
    -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1) list ->
    __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1) list -> __
    -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

  val coq_R_remove_correct : key -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove

  val elements : 'a1 t -> 'a1 t

  val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

  type ('elt, 'a) coq_R_fold =
  | R_fold_0 of 'elt t * 'a
  | R_fold_1 of 'elt t * 'a * X.t * 'elt * (X.t * 'elt) list * 'a
     * ('elt, 'a) coq_R_fold

  val coq_R_fold_rect :
    (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) -> ('a1 t ->
    'a2 -> X.t -> 'a1 -> (X.t * 'a1) list -> __ -> 'a2 -> ('a1, 'a2)
    coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a2 -> ('a1, 'a2) coq_R_fold
    -> 'a3

  val coq_R_fold_rec :
    (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) -> ('a1 t ->
    'a2 -> X.t -> 'a1 -> (X.t * 'a1) list -> __ -> 'a2 -> ('a1, 'a2)
    coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a2 -> ('a1, 'a2) coq_R_fold
    -> 'a3

  val fold_rect :
    (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) -> ('a1 t ->
    'a2 -> X.t -> 'a1 -> (X.t * 'a1) list -> __ -> 'a3 -> 'a3) -> 'a1 t ->
    'a2 -> 'a3

  val fold_rec :
    (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) -> ('a1 t ->
    'a2 -> X.t -> 'a1 -> (X.t * 'a1) list -> __ -> 'a3 -> 'a3) -> 'a1 t ->
    'a2 -> 'a3

  val coq_R_fold_correct :
    (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2 -> ('a1, 'a2) coq_R_fold

  val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool

  type 'elt coq_R_equal =
  | R_equal_0 of 'elt t * 'elt t
  | R_equal_1 of 'elt t * 'elt t * X.t * 'elt * (X.t * 'elt) list * X.t
     * 'elt * (X.t * 'elt) list * bool * 'elt coq_R_equal
  | R_equal_2 of 'elt t * 'elt t * X.t * 'elt * (X.t * 'elt) list * X.t
     * 'elt * (X.t * 'elt) list * X.t compare0
  | R_equal_3 of 'elt t * 'elt t * 'elt t * 'elt t

  val coq_R_equal_rect :
    ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) -> ('a1 t ->
    'a1 t -> X.t -> 'a1 -> (X.t * 'a1) list -> __ -> X.t -> 'a1 ->
    (X.t * 'a1) list -> __ -> __ -> __ -> bool -> 'a1 coq_R_equal -> 'a2 ->
    'a2) -> ('a1 t -> 'a1 t -> X.t -> 'a1 -> (X.t * 'a1) list -> __ -> X.t ->
    'a1 -> (X.t * 'a1) list -> __ -> X.t compare0 -> __ -> __ -> 'a2) -> ('a1
    t -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2) -> 'a1 t -> 'a1 t
    -> bool -> 'a1 coq_R_equal -> 'a2

  val coq_R_equal_rec :
    ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) -> ('a1 t ->
    'a1 t -> X.t -> 'a1 -> (X.t * 'a1) list -> __ -> X.t -> 'a1 ->
    (X.t * 'a1) list -> __ -> __ -> __ -> bool -> 'a1 coq_R_equal -> 'a2 ->
    'a2) -> ('a1 t -> 'a1 t -> X.t -> 'a1 -> (X.t * 'a1) list -> __ -> X.t ->
    'a1 -> (X.t * 'a1) list -> __ -> X.t compare0 -> __ -> __ -> 'a2) -> ('a1
    t -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2) -> 'a1 t -> 'a1 t
    -> bool -> 'a1 coq_R_equal -> 'a2

  val equal_rect :
    ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) -> ('a1 t ->
    'a1 t -> X.t -> 'a1 -> (X.t * 'a1) list -> __ -> X.t -> 'a1 ->
    (X.t * 'a1) list -> __ -> __ -> __ -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t ->
    X.t -> 'a1 -> (X.t * 'a1) list -> __ -> X.t -> 'a1 -> (X.t * 'a1) list ->
    __ -> X.t compare0 -> __ -> __ -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __
    -> 'a1 t -> __ -> __ -> 'a2) -> 'a1 t -> 'a1 t -> 'a2

  val equal_rec :
    ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) -> ('a1 t ->
    'a1 t -> X.t -> 'a1 -> (X.t * 'a1) list -> __ -> X.t -> 'a1 ->
    (X.t * 'a1) list -> __ -> __ -> __ -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t ->
    X.t -> 'a1 -> (X.t * 'a1) list -> __ -> X.t -> 'a1 -> (X.t * 'a1) list ->
    __ -> X.t compare0 -> __ -> __ -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __
    -> 'a1 t -> __ -> __ -> 'a2) -> 'a1 t -> 'a1 t -> 'a2

  val coq_R_equal_correct :
    ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool -> 'a1 coq_R_equal

  val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

  val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

  val option_cons : key -> 'a1 option -> (key * 'a1) list -> (key * 'a1) list

  val map2_l : ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a3 t

  val map2_r : ('a1 option -> 'a2 option -> 'a3 option) -> 'a2 t -> 'a3 t

  val map2 :
    ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t -> 'a3 t

  val combine : 'a1 t -> 'a2 t -> ('a1 option * 'a2 option) t

  val fold_right_pair :
    ('a1 -> 'a2 -> 'a3 -> 'a3) -> ('a1 * 'a2) list -> 'a3 -> 'a3

  val map2_alt :
    ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t -> (key * 'a3)
    list

  val at_least_one :
    'a1 option -> 'a2 option -> ('a1 option * 'a2 option) option

  val at_least_one_then_f :
    ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 option -> 'a2 option ->
    'a3 option
 end

module Coq_Raw :
 functor (I:Int) ->
 functor (X:Coq_OrderedType) ->
 sig
  type key = X.t

  type 'elt tree =
  | Leaf
  | Node of 'elt tree * key * 'elt * 'elt tree * I.t

  val tree_rect :
    'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 -> I.t -> 'a2)
    -> 'a1 tree -> 'a2

  val tree_rec :
    'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 -> I.t -> 'a2)
    -> 'a1 tree -> 'a2

  val height : 'a1 tree -> I.t

  val cardinal : 'a1 tree -> nat

  val empty : 'a1 tree

  val is_empty : 'a1 tree -> bool

  val mem : X.t -> 'a1 tree -> bool

  val find : X.t -> 'a1 tree -> 'a1 option

  val create : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

  val assert_false : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

  val bal : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

  val add : key -> 'a1 -> 'a1 tree -> 'a1 tree

  val remove_min :
    'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree * (key * 'a1)

  val merge : 'a1 tree -> 'a1 tree -> 'a1 tree

  val remove : X.t -> 'a1 tree -> 'a1 tree

  val join : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

  type 'elt triple = { t_left : 'elt tree; t_opt : 'elt option;
                       t_right : 'elt tree }

  val t_left : 'a1 triple -> 'a1 tree

  val t_opt : 'a1 triple -> 'a1 option

  val t_right : 'a1 triple -> 'a1 tree

  val split : X.t -> 'a1 tree -> 'a1 triple

  val concat : 'a1 tree -> 'a1 tree -> 'a1 tree

  val elements_aux : (key * 'a1) list -> 'a1 tree -> (key * 'a1) list

  val elements : 'a1 tree -> (key * 'a1) list

  val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

  type 'elt enumeration =
  | End
  | More of key * 'elt * 'elt tree * 'elt enumeration

  val enumeration_rect :
    'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 -> 'a2) -> 'a1
    enumeration -> 'a2

  val enumeration_rec :
    'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 -> 'a2) -> 'a1
    enumeration -> 'a2

  val cons : 'a1 tree -> 'a1 enumeration -> 'a1 enumeration

  val equal_more :
    ('a1 -> 'a1 -> bool) -> X.t -> 'a1 -> ('a1 enumeration -> bool) -> 'a1
    enumeration -> bool

  val equal_cont :
    ('a1 -> 'a1 -> bool) -> 'a1 tree -> ('a1 enumeration -> bool) -> 'a1
    enumeration -> bool

  val equal_end : 'a1 enumeration -> bool

  val equal : ('a1 -> 'a1 -> bool) -> 'a1 tree -> 'a1 tree -> bool

  val map : ('a1 -> 'a2) -> 'a1 tree -> 'a2 tree

  val mapi : (key -> 'a1 -> 'a2) -> 'a1 tree -> 'a2 tree

  val map_option : (key -> 'a1 -> 'a2 option) -> 'a1 tree -> 'a2 tree

  val map2_opt :
    (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3 tree) ->
    ('a2 tree -> 'a3 tree) -> 'a1 tree -> 'a2 tree -> 'a3 tree

  val map2 :
    ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 tree -> 'a2 tree -> 'a3
    tree

  module Proofs :
   sig
    module MX :
     sig
      module TO :
       sig
        type t = X.t
       end

      module IsTO :
       sig
       end

      module OrderTac :
       sig
       end

      val eq_dec : X.t -> X.t -> bool

      val lt_dec : X.t -> X.t -> bool

      val eqb : X.t -> X.t -> bool
     end

    module PX :
     sig
      module MO :
       sig
        module TO :
         sig
          type t = X.t
         end

        module IsTO :
         sig
         end

        module OrderTac :
         sig
         end

        val eq_dec : X.t -> X.t -> bool

        val lt_dec : X.t -> X.t -> bool

        val eqb : X.t -> X.t -> bool
       end
     end

    module L :
     sig
      module MX :
       sig
        module TO :
         sig
          type t = X.t
         end

        module IsTO :
         sig
         end

        module OrderTac :
         sig
         end

        val eq_dec : X.t -> X.t -> bool

        val lt_dec : X.t -> X.t -> bool

        val eqb : X.t -> X.t -> bool
       end

      module PX :
       sig
        module MO :
         sig
          module TO :
           sig
            type t = X.t
           end

          module IsTO :
           sig
           end

          module OrderTac :
           sig
           end

          val eq_dec : X.t -> X.t -> bool

          val lt_dec : X.t -> X.t -> bool

          val eqb : X.t -> X.t -> bool
         end
       end

      type key = X.t

      type 'elt t = (X.t * 'elt) list

      val empty : 'a1 t

      val is_empty : 'a1 t -> bool

      val mem : key -> 'a1 t -> bool

      type 'elt coq_R_mem =
      | R_mem_0 of 'elt t
      | R_mem_1 of 'elt t * X.t * 'elt * (X.t * 'elt) list
      | R_mem_2 of 'elt t * X.t * 'elt * (X.t * 'elt) list
      | R_mem_3 of 'elt t * X.t * 'elt * (X.t * 'elt) list * bool
         * 'elt coq_R_mem

      val coq_R_mem_rect :
        key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
        list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
        list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
        list -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1
        t -> bool -> 'a1 coq_R_mem -> 'a2

      val coq_R_mem_rec :
        key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
        list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
        list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
        list -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1
        t -> bool -> 'a1 coq_R_mem -> 'a2

      val mem_rect :
        key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
        list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
        list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
        list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

      val mem_rec :
        key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
        list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
        list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
        list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

      val coq_R_mem_correct : key -> 'a1 t -> bool -> 'a1 coq_R_mem

      val find : key -> 'a1 t -> 'a1 option

      type 'elt coq_R_find =
      | R_find_0 of 'elt t
      | R_find_1 of 'elt t * X.t * 'elt * (X.t * 'elt) list
      | R_find_2 of 'elt t * X.t * 'elt * (X.t * 'elt) list
      | R_find_3 of 'elt t * X.t * 'elt * (X.t * 'elt) list * 'elt option
         * 'elt coq_R_find

      val coq_R_find_rect :
        key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
        list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
        list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
        list -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2)
        -> 'a1 t -> 'a1 option -> 'a1 coq_R_find -> 'a2

      val coq_R_find_rec :
        key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
        list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
        list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
        list -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2)
        -> 'a1 t -> 'a1 option -> 'a1 coq_R_find -> 'a2

      val find_rect :
        key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
        list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
        list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
        list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

      val find_rec :
        key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
        list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
        list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
        list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

      val coq_R_find_correct : key -> 'a1 t -> 'a1 option -> 'a1 coq_R_find

      val add : key -> 'a1 -> 'a1 t -> 'a1 t

      type 'elt coq_R_add =
      | R_add_0 of 'elt t
      | R_add_1 of 'elt t * X.t * 'elt * (X.t * 'elt) list
      | R_add_2 of 'elt t * X.t * 'elt * (X.t * 'elt) list
      | R_add_3 of 'elt t * X.t * 'elt * (X.t * 'elt) list * 'elt t
         * 'elt coq_R_add

      val coq_R_add_rect :
        key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 ->
        (X.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 ->
        (X.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 ->
        (X.t * 'a1) list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_add -> 'a2
        -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_add -> 'a2

      val coq_R_add_rec :
        key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 ->
        (X.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 ->
        (X.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 ->
        (X.t * 'a1) list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_add -> 'a2
        -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_add -> 'a2

      val add_rect :
        key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 ->
        (X.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 ->
        (X.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 ->
        (X.t * 'a1) list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

      val add_rec :
        key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 ->
        (X.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 ->
        (X.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 ->
        (X.t * 'a1) list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

      val coq_R_add_correct : key -> 'a1 -> 'a1 t -> 'a1 t -> 'a1 coq_R_add

      val remove : key -> 'a1 t -> 'a1 t

      type 'elt coq_R_remove =
      | R_remove_0 of 'elt t
      | R_remove_1 of 'elt t * X.t * 'elt * (X.t * 'elt) list
      | R_remove_2 of 'elt t * X.t * 'elt * (X.t * 'elt) list
      | R_remove_3 of 'elt t * X.t * 'elt * (X.t * 'elt) list * 'elt t
         * 'elt coq_R_remove

      val coq_R_remove_rect :
        key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
        list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
        list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
        list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_remove -> 'a2 -> 'a2) ->
        'a1 t -> 'a1 t -> 'a1 coq_R_remove -> 'a2

      val coq_R_remove_rec :
        key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
        list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
        list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
        list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_remove -> 'a2 -> 'a2) ->
        'a1 t -> 'a1 t -> 'a1 coq_R_remove -> 'a2

      val remove_rect :
        key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
        list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
        list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
        list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

      val remove_rec :
        key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
        list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
        list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
        list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

      val coq_R_remove_correct : key -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove

      val elements : 'a1 t -> 'a1 t

      val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

      type ('elt, 'a) coq_R_fold =
      | R_fold_0 of 'elt t * 'a
      | R_fold_1 of 'elt t * 'a * X.t * 'elt * (X.t * 'elt) list * 'a
         * ('elt, 'a) coq_R_fold

      val coq_R_fold_rect :
        (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) -> ('a1 t
        -> 'a2 -> X.t -> 'a1 -> (X.t * 'a1) list -> __ -> 'a2 -> ('a1, 'a2)
        coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a2 -> ('a1, 'a2)
        coq_R_fold -> 'a3

      val coq_R_fold_rec :
        (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) -> ('a1 t
        -> 'a2 -> X.t -> 'a1 -> (X.t * 'a1) list -> __ -> 'a2 -> ('a1, 'a2)
        coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a2 -> ('a1, 'a2)
        coq_R_fold -> 'a3

      val fold_rect :
        (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) -> ('a1 t
        -> 'a2 -> X.t -> 'a1 -> (X.t * 'a1) list -> __ -> 'a3 -> 'a3) -> 'a1
        t -> 'a2 -> 'a3

      val fold_rec :
        (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) -> ('a1 t
        -> 'a2 -> X.t -> 'a1 -> (X.t * 'a1) list -> __ -> 'a3 -> 'a3) -> 'a1
        t -> 'a2 -> 'a3

      val coq_R_fold_correct :
        (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2 -> ('a1, 'a2)
        coq_R_fold

      val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool

      type 'elt coq_R_equal =
      | R_equal_0 of 'elt t * 'elt t
      | R_equal_1 of 'elt t * 'elt t * X.t * 'elt * (X.t * 'elt) list * 
         X.t * 'elt * (X.t * 'elt) list * bool * 'elt coq_R_equal
      | R_equal_2 of 'elt t * 'elt t * X.t * 'elt * (X.t * 'elt) list * 
         X.t * 'elt * (X.t * 'elt) list * X.t compare0
      | R_equal_3 of 'elt t * 'elt t * 'elt t * 'elt t

      val coq_R_equal_rect :
        ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) -> ('a1 t
        -> 'a1 t -> X.t -> 'a1 -> (X.t * 'a1) list -> __ -> X.t -> 'a1 ->
        (X.t * 'a1) list -> __ -> __ -> __ -> bool -> 'a1 coq_R_equal -> 'a2
        -> 'a2) -> ('a1 t -> 'a1 t -> X.t -> 'a1 -> (X.t * 'a1) list -> __ ->
        X.t -> 'a1 -> (X.t * 'a1) list -> __ -> X.t compare0 -> __ -> __ ->
        'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2)
        -> 'a1 t -> 'a1 t -> bool -> 'a1 coq_R_equal -> 'a2

      val coq_R_equal_rec :
        ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) -> ('a1 t
        -> 'a1 t -> X.t -> 'a1 -> (X.t * 'a1) list -> __ -> X.t -> 'a1 ->
        (X.t * 'a1) list -> __ -> __ -> __ -> bool -> 'a1 coq_R_equal -> 'a2
        -> 'a2) -> ('a1 t -> 'a1 t -> X.t -> 'a1 -> (X.t * 'a1) list -> __ ->
        X.t -> 'a1 -> (X.t * 'a1) list -> __ -> X.t compare0 -> __ -> __ ->
        'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2)
        -> 'a1 t -> 'a1 t -> bool -> 'a1 coq_R_equal -> 'a2

      val equal_rect :
        ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) -> ('a1 t
        -> 'a1 t -> X.t -> 'a1 -> (X.t * 'a1) list -> __ -> X.t -> 'a1 ->
        (X.t * 'a1) list -> __ -> __ -> __ -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t
        -> X.t -> 'a1 -> (X.t * 'a1) list -> __ -> X.t -> 'a1 -> (X.t * 'a1)
        list -> __ -> X.t compare0 -> __ -> __ -> 'a2) -> ('a1 t -> 'a1 t ->
        'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2) -> 'a1 t -> 'a1 t -> 'a2

      val equal_rec :
        ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) -> ('a1 t
        -> 'a1 t -> X.t -> 'a1 -> (X.t * 'a1) list -> __ -> X.t -> 'a1 ->
        (X.t * 'a1) list -> __ -> __ -> __ -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t
        -> X.t -> 'a1 -> (X.t * 'a1) list -> __ -> X.t -> 'a1 -> (X.t * 'a1)
        list -> __ -> X.t compare0 -> __ -> __ -> 'a2) -> ('a1 t -> 'a1 t ->
        'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2) -> 'a1 t -> 'a1 t -> 'a2

      val coq_R_equal_correct :
        ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool -> 'a1 coq_R_equal

      val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

      val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

      val option_cons :
        key -> 'a1 option -> (key * 'a1) list -> (key * 'a1) list

      val map2_l : ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a3 t

      val map2_r : ('a1 option -> 'a2 option -> 'a3 option) -> 'a2 t -> 'a3 t

      val map2 :
        ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t -> 'a3 t

      val combine : 'a1 t -> 'a2 t -> ('a1 option * 'a2 option) t

      val fold_right_pair :
        ('a1 -> 'a2 -> 'a3 -> 'a3) -> ('a1 * 'a2) list -> 'a3 -> 'a3

      val map2_alt :
        ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t ->
        (key * 'a3) list

      val at_least_one :
        'a1 option -> 'a2 option -> ('a1 option * 'a2 option) option

      val at_least_one_then_f :
        ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 option -> 'a2 option
        -> 'a3 option
     end

    type 'elt coq_R_mem =
    | R_mem_0 of 'elt tree
    | R_mem_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree * I.t * 
       bool * 'elt coq_R_mem
    | R_mem_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree * I.t
    | R_mem_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree * I.t * 
       bool * 'elt coq_R_mem

    val coq_R_mem_rect :
      X.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
      -> 'a1 tree -> I.t -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 ->
      'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ ->
      __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
      I.t -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1
      tree -> bool -> 'a1 coq_R_mem -> 'a2

    val coq_R_mem_rec :
      X.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
      -> 'a1 tree -> I.t -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 ->
      'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ ->
      __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
      I.t -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1
      tree -> bool -> 'a1 coq_R_mem -> 'a2

    type 'elt coq_R_find =
    | R_find_0 of 'elt tree
    | R_find_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree * I.t
       * 'elt option * 'elt coq_R_find
    | R_find_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree * I.t
    | R_find_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree * I.t
       * 'elt option * 'elt coq_R_find

    val coq_R_find_rect :
      X.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
      -> 'a1 tree -> I.t -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find ->
      'a2 -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t
      -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
      tree -> I.t -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 ->
      'a2) -> 'a1 tree -> 'a1 option -> 'a1 coq_R_find -> 'a2

    val coq_R_find_rec :
      X.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
      -> 'a1 tree -> I.t -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find ->
      'a2 -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t
      -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
      tree -> I.t -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 ->
      'a2) -> 'a1 tree -> 'a1 option -> 'a1 coq_R_find -> 'a2

    type 'elt coq_R_bal =
    | R_bal_0 of 'elt tree * key * 'elt * 'elt tree
    | R_bal_1 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * key * 
       'elt * 'elt tree * I.t
    | R_bal_2 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * key * 
       'elt * 'elt tree * I.t
    | R_bal_3 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * key * 
       'elt * 'elt tree * I.t * 'elt tree * key * 'elt * 'elt tree * 
       I.t
    | R_bal_4 of 'elt tree * key * 'elt * 'elt tree
    | R_bal_5 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * key * 
       'elt * 'elt tree * I.t
    | R_bal_6 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * key * 
       'elt * 'elt tree * I.t
    | R_bal_7 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * key * 
       'elt * 'elt tree * I.t * 'elt tree * key * 'elt * 'elt tree * 
       I.t
    | R_bal_8 of 'elt tree * key * 'elt * 'elt tree

    val coq_R_bal_rect :
      ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> 'a2) -> ('a1
      tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key -> 'a1 ->
      'a1 tree -> I.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 ->
      'a1 tree -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __
      -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __
      -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ -> __ -> __ ->
      'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ -> 'a2) -> ('a1 tree ->
      key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> __ -> 'a2) -> ('a1
      tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree ->
      key -> 'a1 -> 'a1 tree -> I.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree ->
      key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key ->
      'a1 -> 'a1 tree -> I.t -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree ->
      key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key ->
      'a1 -> 'a1 tree -> I.t -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 ->
      'a1 tree -> I.t -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree ->
      __ -> __ -> __ -> __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
      'a1 tree -> 'a1 coq_R_bal -> 'a2

    val coq_R_bal_rec :
      ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> 'a2) -> ('a1
      tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key -> 'a1 ->
      'a1 tree -> I.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 ->
      'a1 tree -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __
      -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __
      -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ -> __ -> __ ->
      'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ -> 'a2) -> ('a1 tree ->
      key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> __ -> 'a2) -> ('a1
      tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree ->
      key -> 'a1 -> 'a1 tree -> I.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree ->
      key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key ->
      'a1 -> 'a1 tree -> I.t -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree ->
      key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key ->
      'a1 -> 'a1 tree -> I.t -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 ->
      'a1 tree -> I.t -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree ->
      __ -> __ -> __ -> __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
      'a1 tree -> 'a1 coq_R_bal -> 'a2

    type 'elt coq_R_add =
    | R_add_0 of 'elt tree
    | R_add_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree * I.t
       * 'elt tree * 'elt coq_R_add
    | R_add_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree * I.t
    | R_add_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree * I.t
       * 'elt tree * 'elt coq_R_add

    val coq_R_add_rect :
      key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key
      -> 'a1 -> 'a1 tree -> I.t -> __ -> __ -> __ -> 'a1 tree -> 'a1
      coq_R_add -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
      tree -> I.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key
      -> 'a1 -> 'a1 tree -> I.t -> __ -> __ -> __ -> 'a1 tree -> 'a1
      coq_R_add -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_add -> 'a2

    val coq_R_add_rec :
      key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key
      -> 'a1 -> 'a1 tree -> I.t -> __ -> __ -> __ -> 'a1 tree -> 'a1
      coq_R_add -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
      tree -> I.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key
      -> 'a1 -> 'a1 tree -> I.t -> __ -> __ -> __ -> 'a1 tree -> 'a1
      coq_R_add -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_add -> 'a2

    type 'elt coq_R_remove_min =
    | R_remove_min_0 of 'elt tree * key * 'elt * 'elt tree
    | R_remove_min_1 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
       key * 'elt * 'elt tree * I.t * ('elt tree * (key * 'elt))
       * 'elt coq_R_remove_min * 'elt tree * (key * 'elt)

    val coq_R_remove_min_rect :
      ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> key
      -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __
      -> ('a1 tree * (key * 'a1)) -> 'a1 coq_R_remove_min -> 'a2 -> 'a1 tree
      -> (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
      ('a1 tree * (key * 'a1)) -> 'a1 coq_R_remove_min -> 'a2

    val coq_R_remove_min_rec :
      ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> key
      -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __
      -> ('a1 tree * (key * 'a1)) -> 'a1 coq_R_remove_min -> 'a2 -> 'a1 tree
      -> (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
      ('a1 tree * (key * 'a1)) -> 'a1 coq_R_remove_min -> 'a2

    type 'elt coq_R_merge =
    | R_merge_0 of 'elt tree * 'elt tree
    | R_merge_1 of 'elt tree * 'elt tree * 'elt tree * key * 'elt * 'elt tree
       * I.t
    | R_merge_2 of 'elt tree * 'elt tree * 'elt tree * key * 'elt * 'elt tree
       * I.t * 'elt tree * key * 'elt * 'elt tree * I.t * 'elt tree
       * (key * 'elt) * key * 'elt

    val coq_R_merge_rect :
      ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1
      tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ -> __ -> 'a2) -> ('a1 tree
      -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ -> 'a1
      tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ -> 'a1 tree -> (key * 'a1)
      -> __ -> key -> 'a1 -> __ -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 tree
      -> 'a1 coq_R_merge -> 'a2

    val coq_R_merge_rec :
      ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1
      tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ -> __ -> 'a2) -> ('a1 tree
      -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ -> 'a1
      tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ -> 'a1 tree -> (key * 'a1)
      -> __ -> key -> 'a1 -> __ -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 tree
      -> 'a1 coq_R_merge -> 'a2

    type 'elt coq_R_remove =
    | R_remove_0 of 'elt tree
    | R_remove_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree * 
       I.t * 'elt tree * 'elt coq_R_remove
    | R_remove_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree * I.t
    | R_remove_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree * 
       I.t * 'elt tree * 'elt coq_R_remove

    val coq_R_remove_rect :
      X.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
      -> 'a1 tree -> I.t -> __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove ->
      'a2 -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t
      -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
      tree -> I.t -> __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 ->
      'a2) -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_remove -> 'a2

    val coq_R_remove_rec :
      X.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
      -> 'a1 tree -> I.t -> __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove ->
      'a2 -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t
      -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
      tree -> I.t -> __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 ->
      'a2) -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_remove -> 'a2

    type 'elt coq_R_concat =
    | R_concat_0 of 'elt tree * 'elt tree
    | R_concat_1 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
       * 'elt tree * I.t
    | R_concat_2 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
       * 'elt tree * I.t * 'elt tree * key * 'elt * 'elt tree * I.t
       * 'elt tree * (key * 'elt)

    val coq_R_concat_rect :
      ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1
      tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ -> __ -> 'a2) -> ('a1 tree
      -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ -> 'a1
      tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ -> 'a1 tree -> (key * 'a1)
      -> __ -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_concat
      -> 'a2

    val coq_R_concat_rec :
      ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1
      tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ -> __ -> 'a2) -> ('a1 tree
      -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ -> 'a1
      tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ -> 'a1 tree -> (key * 'a1)
      -> __ -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_concat
      -> 'a2

    type 'elt coq_R_split =
    | R_split_0 of 'elt tree
    | R_split_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree * I.t
       * 'elt triple * 'elt coq_R_split * 'elt tree * 'elt option * 'elt tree
    | R_split_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree * I.t
    | R_split_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree * I.t
       * 'elt triple * 'elt coq_R_split * 'elt tree * 'elt option * 'elt tree

    val coq_R_split_rect :
      X.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
      -> 'a1 tree -> I.t -> __ -> __ -> __ -> 'a1 triple -> 'a1 coq_R_split
      -> 'a2 -> 'a1 tree -> 'a1 option -> 'a1 tree -> __ -> 'a2) -> ('a1 tree
      -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ -> __ -> __ -> 'a2)
      -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ -> __
      -> __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option
      -> 'a1 tree -> __ -> 'a2) -> 'a1 tree -> 'a1 triple -> 'a1 coq_R_split
      -> 'a2

    val coq_R_split_rec :
      X.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
      -> 'a1 tree -> I.t -> __ -> __ -> __ -> 'a1 triple -> 'a1 coq_R_split
      -> 'a2 -> 'a1 tree -> 'a1 option -> 'a1 tree -> __ -> 'a2) -> ('a1 tree
      -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ -> __ -> __ -> 'a2)
      -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ -> __
      -> __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option
      -> 'a1 tree -> __ -> 'a2) -> 'a1 tree -> 'a1 triple -> 'a1 coq_R_split
      -> 'a2

    type ('elt, 'x) coq_R_map_option =
    | R_map_option_0 of 'elt tree
    | R_map_option_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree * 
       I.t * 'x * 'x tree * ('elt, 'x) coq_R_map_option * 'x tree
       * ('elt, 'x) coq_R_map_option
    | R_map_option_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree * 
       I.t * 'x tree * ('elt, 'x) coq_R_map_option * 'x tree
       * ('elt, 'x) coq_R_map_option

    val coq_R_map_option_rect :
      (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) -> ('a1 tree ->
      'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ -> 'a2 -> __ -> 'a2
      tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2 tree -> ('a1, 'a2)
      coq_R_map_option -> 'a3 -> 'a3) -> ('a1 tree -> 'a1 tree -> key -> 'a1
      -> 'a1 tree -> I.t -> __ -> __ -> 'a2 tree -> ('a1, 'a2)
      coq_R_map_option -> 'a3 -> 'a2 tree -> ('a1, 'a2) coq_R_map_option ->
      'a3 -> 'a3) -> 'a1 tree -> 'a2 tree -> ('a1, 'a2) coq_R_map_option ->
      'a3

    val coq_R_map_option_rec :
      (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) -> ('a1 tree ->
      'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ -> 'a2 -> __ -> 'a2
      tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2 tree -> ('a1, 'a2)
      coq_R_map_option -> 'a3 -> 'a3) -> ('a1 tree -> 'a1 tree -> key -> 'a1
      -> 'a1 tree -> I.t -> __ -> __ -> 'a2 tree -> ('a1, 'a2)
      coq_R_map_option -> 'a3 -> 'a2 tree -> ('a1, 'a2) coq_R_map_option ->
      'a3 -> 'a3) -> 'a1 tree -> 'a2 tree -> ('a1, 'a2) coq_R_map_option ->
      'a3

    type ('elt, 'x0, 'x) coq_R_map2_opt =
    | R_map2_opt_0 of 'elt tree * 'x0 tree
    | R_map2_opt_1 of 'elt tree * 'x0 tree * 'elt tree * key * 'elt
       * 'elt tree * I.t
    | R_map2_opt_2 of 'elt tree * 'x0 tree * 'elt tree * key * 'elt
       * 'elt tree * I.t * 'x0 tree * key * 'x0 * 'x0 tree * I.t * 'x0 tree
       * 'x0 option * 'x0 tree * 'x * 'x tree
       * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
       * ('elt, 'x0, 'x) coq_R_map2_opt
    | R_map2_opt_3 of 'elt tree * 'x0 tree * 'elt tree * key * 'elt
       * 'elt tree * I.t * 'x0 tree * key * 'x0 * 'x0 tree * I.t * 'x0 tree
       * 'x0 option * 'x0 tree * 'x tree * ('elt, 'x0, 'x) coq_R_map2_opt
       * 'x tree * ('elt, 'x0, 'x) coq_R_map2_opt

    val coq_R_map2_opt_rect :
      (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3 tree) ->
      ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2 tree -> __ -> 'a4) -> ('a1
      tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ ->
      __ -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1
      tree -> I.t -> __ -> 'a2 tree -> key -> 'a2 -> 'a2 tree -> I.t -> __ ->
      'a2 tree -> 'a2 option -> 'a2 tree -> __ -> 'a3 -> __ -> 'a3 tree ->
      ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
      coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree ->
      key -> 'a1 -> 'a1 tree -> I.t -> __ -> 'a2 tree -> key -> 'a2 -> 'a2
      tree -> I.t -> __ -> 'a2 tree -> 'a2 option -> 'a2 tree -> __ -> __ ->
      'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1,
      'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1 tree -> 'a2 tree -> 'a3
      tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4

    val coq_R_map2_opt_rec :
      (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3 tree) ->
      ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2 tree -> __ -> 'a4) -> ('a1
      tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ ->
      __ -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1
      tree -> I.t -> __ -> 'a2 tree -> key -> 'a2 -> 'a2 tree -> I.t -> __ ->
      'a2 tree -> 'a2 option -> 'a2 tree -> __ -> 'a3 -> __ -> 'a3 tree ->
      ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
      coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree ->
      key -> 'a1 -> 'a1 tree -> I.t -> __ -> 'a2 tree -> key -> 'a2 -> 'a2
      tree -> I.t -> __ -> 'a2 tree -> 'a2 option -> 'a2 tree -> __ -> __ ->
      'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1,
      'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1 tree -> 'a2 tree -> 'a3
      tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4

    val fold' : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

    val flatten_e : 'a1 enumeration -> (key * 'a1) list
   end
 end

module Coq0_IntMake :
 functor (I:Int) ->
 functor (X:Coq_OrderedType) ->
 sig
  module E :
   sig
    type t = X.t

    val compare : t -> t -> t compare0

    val eq_dec : t -> t -> bool
   end

  module Raw :
   sig
    type key = X.t

    type 'elt tree =
    | Leaf
    | Node of 'elt tree * key * 'elt * 'elt tree * I.t

    val tree_rect :
      'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 -> I.t -> 'a2)
      -> 'a1 tree -> 'a2

    val tree_rec :
      'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 -> I.t -> 'a2)
      -> 'a1 tree -> 'a2

    val height : 'a1 tree -> I.t

    val cardinal : 'a1 tree -> nat

    val empty : 'a1 tree

    val is_empty : 'a1 tree -> bool

    val mem : X.t -> 'a1 tree -> bool

    val find : X.t -> 'a1 tree -> 'a1 option

    val create : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

    val assert_false : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

    val bal : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

    val add : key -> 'a1 -> 'a1 tree -> 'a1 tree

    val remove_min :
      'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree * (key * 'a1)

    val merge : 'a1 tree -> 'a1 tree -> 'a1 tree

    val remove : X.t -> 'a1 tree -> 'a1 tree

    val join : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

    type 'elt triple = { t_left : 'elt tree; t_opt : 'elt option;
                         t_right : 'elt tree }

    val t_left : 'a1 triple -> 'a1 tree

    val t_opt : 'a1 triple -> 'a1 option

    val t_right : 'a1 triple -> 'a1 tree

    val split : X.t -> 'a1 tree -> 'a1 triple

    val concat : 'a1 tree -> 'a1 tree -> 'a1 tree

    val elements_aux : (key * 'a1) list -> 'a1 tree -> (key * 'a1) list

    val elements : 'a1 tree -> (key * 'a1) list

    val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

    type 'elt enumeration =
    | End
    | More of key * 'elt * 'elt tree * 'elt enumeration

    val enumeration_rect :
      'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 -> 'a2) -> 'a1
      enumeration -> 'a2

    val enumeration_rec :
      'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 -> 'a2) -> 'a1
      enumeration -> 'a2

    val cons : 'a1 tree -> 'a1 enumeration -> 'a1 enumeration

    val equal_more :
      ('a1 -> 'a1 -> bool) -> X.t -> 'a1 -> ('a1 enumeration -> bool) -> 'a1
      enumeration -> bool

    val equal_cont :
      ('a1 -> 'a1 -> bool) -> 'a1 tree -> ('a1 enumeration -> bool) -> 'a1
      enumeration -> bool

    val equal_end : 'a1 enumeration -> bool

    val equal : ('a1 -> 'a1 -> bool) -> 'a1 tree -> 'a1 tree -> bool

    val map : ('a1 -> 'a2) -> 'a1 tree -> 'a2 tree

    val mapi : (key -> 'a1 -> 'a2) -> 'a1 tree -> 'a2 tree

    val map_option : (key -> 'a1 -> 'a2 option) -> 'a1 tree -> 'a2 tree

    val map2_opt :
      (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3 tree) ->
      ('a2 tree -> 'a3 tree) -> 'a1 tree -> 'a2 tree -> 'a3 tree

    val map2 :
      ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 tree -> 'a2 tree -> 'a3
      tree

    module Proofs :
     sig
      module MX :
       sig
        module TO :
         sig
          type t = X.t
         end

        module IsTO :
         sig
         end

        module OrderTac :
         sig
         end

        val eq_dec : X.t -> X.t -> bool

        val lt_dec : X.t -> X.t -> bool

        val eqb : X.t -> X.t -> bool
       end

      module PX :
       sig
        module MO :
         sig
          module TO :
           sig
            type t = X.t
           end

          module IsTO :
           sig
           end

          module OrderTac :
           sig
           end

          val eq_dec : X.t -> X.t -> bool

          val lt_dec : X.t -> X.t -> bool

          val eqb : X.t -> X.t -> bool
         end
       end

      module L :
       sig
        module MX :
         sig
          module TO :
           sig
            type t = X.t
           end

          module IsTO :
           sig
           end

          module OrderTac :
           sig
           end

          val eq_dec : X.t -> X.t -> bool

          val lt_dec : X.t -> X.t -> bool

          val eqb : X.t -> X.t -> bool
         end

        module PX :
         sig
          module MO :
           sig
            module TO :
             sig
              type t = X.t
             end

            module IsTO :
             sig
             end

            module OrderTac :
             sig
             end

            val eq_dec : X.t -> X.t -> bool

            val lt_dec : X.t -> X.t -> bool

            val eqb : X.t -> X.t -> bool
           end
         end

        type key = X.t

        type 'elt t = (X.t * 'elt) list

        val empty : 'a1 t

        val is_empty : 'a1 t -> bool

        val mem : key -> 'a1 t -> bool

        type 'elt coq_R_mem =
        | R_mem_0 of 'elt t
        | R_mem_1 of 'elt t * X.t * 'elt * (X.t * 'elt) list
        | R_mem_2 of 'elt t * X.t * 'elt * (X.t * 'elt) list
        | R_mem_3 of 'elt t * X.t * 'elt * (X.t * 'elt) list * bool
           * 'elt coq_R_mem

        val coq_R_mem_rect :
          key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
          list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 ->
          (X.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1
          -> (X.t * 'a1) list -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem ->
          'a2 -> 'a2) -> 'a1 t -> bool -> 'a1 coq_R_mem -> 'a2

        val coq_R_mem_rec :
          key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
          list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 ->
          (X.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1
          -> (X.t * 'a1) list -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem ->
          'a2 -> 'a2) -> 'a1 t -> bool -> 'a1 coq_R_mem -> 'a2

        val mem_rect :
          key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
          list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 ->
          (X.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1
          -> (X.t * 'a1) list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

        val mem_rec :
          key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
          list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 ->
          (X.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1
          -> (X.t * 'a1) list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

        val coq_R_mem_correct : key -> 'a1 t -> bool -> 'a1 coq_R_mem

        val find : key -> 'a1 t -> 'a1 option

        type 'elt coq_R_find =
        | R_find_0 of 'elt t
        | R_find_1 of 'elt t * X.t * 'elt * (X.t * 'elt) list
        | R_find_2 of 'elt t * X.t * 'elt * (X.t * 'elt) list
        | R_find_3 of 'elt t * X.t * 'elt * (X.t * 'elt) list * 'elt option
           * 'elt coq_R_find

        val coq_R_find_rect :
          key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
          list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 ->
          (X.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1
          -> (X.t * 'a1) list -> __ -> __ -> __ -> 'a1 option -> 'a1
          coq_R_find -> 'a2 -> 'a2) -> 'a1 t -> 'a1 option -> 'a1 coq_R_find
          -> 'a2

        val coq_R_find_rec :
          key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
          list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 ->
          (X.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1
          -> (X.t * 'a1) list -> __ -> __ -> __ -> 'a1 option -> 'a1
          coq_R_find -> 'a2 -> 'a2) -> 'a1 t -> 'a1 option -> 'a1 coq_R_find
          -> 'a2

        val find_rect :
          key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
          list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 ->
          (X.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1
          -> (X.t * 'a1) list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

        val find_rec :
          key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
          list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 ->
          (X.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1
          -> (X.t * 'a1) list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

        val coq_R_find_correct : key -> 'a1 t -> 'a1 option -> 'a1 coq_R_find

        val add : key -> 'a1 -> 'a1 t -> 'a1 t

        type 'elt coq_R_add =
        | R_add_0 of 'elt t
        | R_add_1 of 'elt t * X.t * 'elt * (X.t * 'elt) list
        | R_add_2 of 'elt t * X.t * 'elt * (X.t * 'elt) list
        | R_add_3 of 'elt t * X.t * 'elt * (X.t * 'elt) list * 'elt t
           * 'elt coq_R_add

        val coq_R_add_rect :
          key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 ->
          (X.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1
          -> (X.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t ->
          'a1 -> (X.t * 'a1) list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_add
          -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_add -> 'a2

        val coq_R_add_rec :
          key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 ->
          (X.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1
          -> (X.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t ->
          'a1 -> (X.t * 'a1) list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_add
          -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_add -> 'a2

        val add_rect :
          key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 ->
          (X.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1
          -> (X.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t ->
          'a1 -> (X.t * 'a1) list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t
          -> 'a2

        val add_rec :
          key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 ->
          (X.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1
          -> (X.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t ->
          'a1 -> (X.t * 'a1) list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t
          -> 'a2

        val coq_R_add_correct : key -> 'a1 -> 'a1 t -> 'a1 t -> 'a1 coq_R_add

        val remove : key -> 'a1 t -> 'a1 t

        type 'elt coq_R_remove =
        | R_remove_0 of 'elt t
        | R_remove_1 of 'elt t * X.t * 'elt * (X.t * 'elt) list
        | R_remove_2 of 'elt t * X.t * 'elt * (X.t * 'elt) list
        | R_remove_3 of 'elt t * X.t * 'elt * (X.t * 'elt) list * 'elt t
           * 'elt coq_R_remove

        val coq_R_remove_rect :
          key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
          list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 ->
          (X.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1
          -> (X.t * 'a1) list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_remove
          -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove -> 'a2

        val coq_R_remove_rec :
          key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
          list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 ->
          (X.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1
          -> (X.t * 'a1) list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_remove
          -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove -> 'a2

        val remove_rect :
          key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
          list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 ->
          (X.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1
          -> (X.t * 'a1) list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

        val remove_rec :
          key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
          list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 ->
          (X.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1
          -> (X.t * 'a1) list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

        val coq_R_remove_correct : key -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove

        val elements : 'a1 t -> 'a1 t

        val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

        type ('elt, 'a) coq_R_fold =
        | R_fold_0 of 'elt t * 'a
        | R_fold_1 of 'elt t * 'a * X.t * 'elt * (X.t * 'elt) list * 
           'a * ('elt, 'a) coq_R_fold

        val coq_R_fold_rect :
          (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) -> ('a1 t
          -> 'a2 -> X.t -> 'a1 -> (X.t * 'a1) list -> __ -> 'a2 -> ('a1, 'a2)
          coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a2 -> ('a1, 'a2)
          coq_R_fold -> 'a3

        val coq_R_fold_rec :
          (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) -> ('a1 t
          -> 'a2 -> X.t -> 'a1 -> (X.t * 'a1) list -> __ -> 'a2 -> ('a1, 'a2)
          coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a2 -> ('a1, 'a2)
          coq_R_fold -> 'a3

        val fold_rect :
          (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) -> ('a1 t
          -> 'a2 -> X.t -> 'a1 -> (X.t * 'a1) list -> __ -> 'a3 -> 'a3) ->
          'a1 t -> 'a2 -> 'a3

        val fold_rec :
          (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) -> ('a1 t
          -> 'a2 -> X.t -> 'a1 -> (X.t * 'a1) list -> __ -> 'a3 -> 'a3) ->
          'a1 t -> 'a2 -> 'a3

        val coq_R_fold_correct :
          (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2 -> ('a1, 'a2)
          coq_R_fold

        val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool

        type 'elt coq_R_equal =
        | R_equal_0 of 'elt t * 'elt t
        | R_equal_1 of 'elt t * 'elt t * X.t * 'elt * (X.t * 'elt) list * 
           X.t * 'elt * (X.t * 'elt) list * bool * 'elt coq_R_equal
        | R_equal_2 of 'elt t * 'elt t * X.t * 'elt * (X.t * 'elt) list * 
           X.t * 'elt * (X.t * 'elt) list * X.t compare0
        | R_equal_3 of 'elt t * 'elt t * 'elt t * 'elt t

        val coq_R_equal_rect :
          ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) -> ('a1
          t -> 'a1 t -> X.t -> 'a1 -> (X.t * 'a1) list -> __ -> X.t -> 'a1 ->
          (X.t * 'a1) list -> __ -> __ -> __ -> bool -> 'a1 coq_R_equal ->
          'a2 -> 'a2) -> ('a1 t -> 'a1 t -> X.t -> 'a1 -> (X.t * 'a1) list ->
          __ -> X.t -> 'a1 -> (X.t * 'a1) list -> __ -> X.t compare0 -> __ ->
          __ -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __
          -> 'a2) -> 'a1 t -> 'a1 t -> bool -> 'a1 coq_R_equal -> 'a2

        val coq_R_equal_rec :
          ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) -> ('a1
          t -> 'a1 t -> X.t -> 'a1 -> (X.t * 'a1) list -> __ -> X.t -> 'a1 ->
          (X.t * 'a1) list -> __ -> __ -> __ -> bool -> 'a1 coq_R_equal ->
          'a2 -> 'a2) -> ('a1 t -> 'a1 t -> X.t -> 'a1 -> (X.t * 'a1) list ->
          __ -> X.t -> 'a1 -> (X.t * 'a1) list -> __ -> X.t compare0 -> __ ->
          __ -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __
          -> 'a2) -> 'a1 t -> 'a1 t -> bool -> 'a1 coq_R_equal -> 'a2

        val equal_rect :
          ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) -> ('a1
          t -> 'a1 t -> X.t -> 'a1 -> (X.t * 'a1) list -> __ -> X.t -> 'a1 ->
          (X.t * 'a1) list -> __ -> __ -> __ -> 'a2 -> 'a2) -> ('a1 t -> 'a1
          t -> X.t -> 'a1 -> (X.t * 'a1) list -> __ -> X.t -> 'a1 ->
          (X.t * 'a1) list -> __ -> X.t compare0 -> __ -> __ -> 'a2) -> ('a1
          t -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2) -> 'a1 t ->
          'a1 t -> 'a2

        val equal_rec :
          ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) -> ('a1
          t -> 'a1 t -> X.t -> 'a1 -> (X.t * 'a1) list -> __ -> X.t -> 'a1 ->
          (X.t * 'a1) list -> __ -> __ -> __ -> 'a2 -> 'a2) -> ('a1 t -> 'a1
          t -> X.t -> 'a1 -> (X.t * 'a1) list -> __ -> X.t -> 'a1 ->
          (X.t * 'a1) list -> __ -> X.t compare0 -> __ -> __ -> 'a2) -> ('a1
          t -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2) -> 'a1 t ->
          'a1 t -> 'a2

        val coq_R_equal_correct :
          ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool -> 'a1 coq_R_equal

        val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

        val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

        val option_cons :
          key -> 'a1 option -> (key * 'a1) list -> (key * 'a1) list

        val map2_l :
          ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a3 t

        val map2_r :
          ('a1 option -> 'a2 option -> 'a3 option) -> 'a2 t -> 'a3 t

        val map2 :
          ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t -> 'a3 t

        val combine : 'a1 t -> 'a2 t -> ('a1 option * 'a2 option) t

        val fold_right_pair :
          ('a1 -> 'a2 -> 'a3 -> 'a3) -> ('a1 * 'a2) list -> 'a3 -> 'a3

        val map2_alt :
          ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t ->
          (key * 'a3) list

        val at_least_one :
          'a1 option -> 'a2 option -> ('a1 option * 'a2 option) option

        val at_least_one_then_f :
          ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 option -> 'a2
          option -> 'a3 option
       end

      type 'elt coq_R_mem =
      | R_mem_0 of 'elt tree
      | R_mem_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree * I.t
         * bool * 'elt coq_R_mem
      | R_mem_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree * I.t
      | R_mem_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree * I.t
         * bool * 'elt coq_R_mem

      val coq_R_mem_rect :
        X.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
        -> 'a1 tree -> I.t -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2
        -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t ->
        __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
        tree -> I.t -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2)
        -> 'a1 tree -> bool -> 'a1 coq_R_mem -> 'a2

      val coq_R_mem_rec :
        X.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
        -> 'a1 tree -> I.t -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2
        -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t ->
        __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
        tree -> I.t -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2)
        -> 'a1 tree -> bool -> 'a1 coq_R_mem -> 'a2

      type 'elt coq_R_find =
      | R_find_0 of 'elt tree
      | R_find_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree * 
         I.t * 'elt option * 'elt coq_R_find
      | R_find_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree * I.t
      | R_find_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree * 
         I.t * 'elt option * 'elt coq_R_find

      val coq_R_find_rect :
        X.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
        -> 'a1 tree -> I.t -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find
        -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
        I.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
        -> 'a1 tree -> I.t -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find
        -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 option -> 'a1 coq_R_find -> 'a2

      val coq_R_find_rec :
        X.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
        -> 'a1 tree -> I.t -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find
        -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
        I.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
        -> 'a1 tree -> I.t -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find
        -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 option -> 'a1 coq_R_find -> 'a2

      type 'elt coq_R_bal =
      | R_bal_0 of 'elt tree * key * 'elt * 'elt tree
      | R_bal_1 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * key
         * 'elt * 'elt tree * I.t
      | R_bal_2 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * key
         * 'elt * 'elt tree * I.t
      | R_bal_3 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * key
         * 'elt * 'elt tree * I.t * 'elt tree * key * 'elt * 'elt tree * 
         I.t
      | R_bal_4 of 'elt tree * key * 'elt * 'elt tree
      | R_bal_5 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * key
         * 'elt * 'elt tree * I.t
      | R_bal_6 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * key
         * 'elt * 'elt tree * I.t
      | R_bal_7 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * key
         * 'elt * 'elt tree * I.t * 'elt tree * key * 'elt * 'elt tree * 
         I.t
      | R_bal_8 of 'elt tree * key * 'elt * 'elt tree

      val coq_R_bal_rect :
        ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> 'a2) -> ('a1
        tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key -> 'a1
        -> 'a1 tree -> I.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key ->
        'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
        I.t -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1
        tree -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __
        -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ ->
        'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __
        -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ ->
        __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ -> __ ->
        __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __
        -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ -> __ -> __
        -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ ->
        __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ -> __ ->
        __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ -> 'a2) -> ('a1
        tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a2) -> 'a1
        tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_bal -> 'a2

      val coq_R_bal_rec :
        ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> 'a2) -> ('a1
        tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key -> 'a1
        -> 'a1 tree -> I.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key ->
        'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
        I.t -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1
        tree -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __
        -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ ->
        'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __
        -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ ->
        __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ -> __ ->
        __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __
        -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ -> __ -> __
        -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ ->
        __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ -> __ ->
        __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ -> 'a2) -> ('a1
        tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a2) -> 'a1
        tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_bal -> 'a2

      type 'elt coq_R_add =
      | R_add_0 of 'elt tree
      | R_add_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree * I.t
         * 'elt tree * 'elt coq_R_add
      | R_add_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree * I.t
      | R_add_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree * I.t
         * 'elt tree * 'elt coq_R_add

      val coq_R_add_rect :
        key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key
        -> 'a1 -> 'a1 tree -> I.t -> __ -> __ -> __ -> 'a1 tree -> 'a1
        coq_R_add -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 ->
        'a1 tree -> I.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
        key -> 'a1 -> 'a1 tree -> I.t -> __ -> __ -> __ -> 'a1 tree -> 'a1
        coq_R_add -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_add ->
        'a2

      val coq_R_add_rec :
        key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key
        -> 'a1 -> 'a1 tree -> I.t -> __ -> __ -> __ -> 'a1 tree -> 'a1
        coq_R_add -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 ->
        'a1 tree -> I.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
        key -> 'a1 -> 'a1 tree -> I.t -> __ -> __ -> __ -> 'a1 tree -> 'a1
        coq_R_add -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_add ->
        'a2

      type 'elt coq_R_remove_min =
      | R_remove_min_0 of 'elt tree * key * 'elt * 'elt tree
      | R_remove_min_1 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
         * key * 'elt * 'elt tree * I.t * ('elt tree * (key * 'elt))
         * 'elt coq_R_remove_min * 'elt tree * (key * 'elt)

      val coq_R_remove_min_rect :
        ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> key
        -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __
        -> ('a1 tree * (key * 'a1)) -> 'a1 coq_R_remove_min -> 'a2 -> 'a1
        tree -> (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1
        tree -> ('a1 tree * (key * 'a1)) -> 'a1 coq_R_remove_min -> 'a2

      val coq_R_remove_min_rec :
        ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> key
        -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __
        -> ('a1 tree * (key * 'a1)) -> 'a1 coq_R_remove_min -> 'a2 -> 'a1
        tree -> (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1
        tree -> ('a1 tree * (key * 'a1)) -> 'a1 coq_R_remove_min -> 'a2

      type 'elt coq_R_merge =
      | R_merge_0 of 'elt tree * 'elt tree
      | R_merge_1 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
         * 'elt tree * I.t
      | R_merge_2 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
         * 'elt tree * I.t * 'elt tree * key * 'elt * 'elt tree * I.t
         * 'elt tree * (key * 'elt) * key * 'elt

      val coq_R_merge_rect :
        ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1
        tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ -> __ -> 'a2) -> ('a1
        tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __
        -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ -> 'a1 tree ->
        (key * 'a1) -> __ -> key -> 'a1 -> __ -> 'a2) -> 'a1 tree -> 'a1 tree
        -> 'a1 tree -> 'a1 coq_R_merge -> 'a2

      val coq_R_merge_rec :
        ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1
        tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ -> __ -> 'a2) -> ('a1
        tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __
        -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ -> 'a1 tree ->
        (key * 'a1) -> __ -> key -> 'a1 -> __ -> 'a2) -> 'a1 tree -> 'a1 tree
        -> 'a1 tree -> 'a1 coq_R_merge -> 'a2

      type 'elt coq_R_remove =
      | R_remove_0 of 'elt tree
      | R_remove_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree * 
         I.t * 'elt tree * 'elt coq_R_remove
      | R_remove_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree * I.t
      | R_remove_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree * 
         I.t * 'elt tree * 'elt coq_R_remove

      val coq_R_remove_rect :
        X.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
        -> 'a1 tree -> I.t -> __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove
        -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
        I.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
        -> 'a1 tree -> I.t -> __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove
        -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_remove -> 'a2

      val coq_R_remove_rec :
        X.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
        -> 'a1 tree -> I.t -> __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove
        -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
        I.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
        -> 'a1 tree -> I.t -> __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove
        -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_remove -> 'a2

      type 'elt coq_R_concat =
      | R_concat_0 of 'elt tree * 'elt tree
      | R_concat_1 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
         * 'elt tree * I.t
      | R_concat_2 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
         * 'elt tree * I.t * 'elt tree * key * 'elt * 'elt tree * I.t
         * 'elt tree * (key * 'elt)

      val coq_R_concat_rect :
        ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1
        tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ -> __ -> 'a2) -> ('a1
        tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __
        -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ -> 'a1 tree ->
        (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 tree -> 'a1
        coq_R_concat -> 'a2

      val coq_R_concat_rec :
        ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1
        tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ -> __ -> 'a2) -> ('a1
        tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __
        -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ -> 'a1 tree ->
        (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 tree -> 'a1
        coq_R_concat -> 'a2

      type 'elt coq_R_split =
      | R_split_0 of 'elt tree
      | R_split_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree * 
         I.t * 'elt triple * 'elt coq_R_split * 'elt tree * 'elt option
         * 'elt tree
      | R_split_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree * I.t
      | R_split_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree * 
         I.t * 'elt triple * 'elt coq_R_split * 'elt tree * 'elt option
         * 'elt tree

      val coq_R_split_rect :
        X.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
        -> 'a1 tree -> I.t -> __ -> __ -> __ -> 'a1 triple -> 'a1 coq_R_split
        -> 'a2 -> 'a1 tree -> 'a1 option -> 'a1 tree -> __ -> 'a2) -> ('a1
        tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ -> __ -> __
        -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t ->
        __ -> __ -> __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree ->
        'a1 option -> 'a1 tree -> __ -> 'a2) -> 'a1 tree -> 'a1 triple -> 'a1
        coq_R_split -> 'a2

      val coq_R_split_rec :
        X.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
        -> 'a1 tree -> I.t -> __ -> __ -> __ -> 'a1 triple -> 'a1 coq_R_split
        -> 'a2 -> 'a1 tree -> 'a1 option -> 'a1 tree -> __ -> 'a2) -> ('a1
        tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ -> __ -> __
        -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t ->
        __ -> __ -> __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree ->
        'a1 option -> 'a1 tree -> __ -> 'a2) -> 'a1 tree -> 'a1 triple -> 'a1
        coq_R_split -> 'a2

      type ('elt, 'x) coq_R_map_option =
      | R_map_option_0 of 'elt tree
      | R_map_option_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
         * I.t * 'x * 'x tree * ('elt, 'x) coq_R_map_option * 'x tree
         * ('elt, 'x) coq_R_map_option
      | R_map_option_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
         * I.t * 'x tree * ('elt, 'x) coq_R_map_option * 'x tree
         * ('elt, 'x) coq_R_map_option

      val coq_R_map_option_rect :
        (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) -> ('a1 tree ->
        'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ -> 'a2 -> __ -> 'a2
        tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2 tree -> ('a1, 'a2)
        coq_R_map_option -> 'a3 -> 'a3) -> ('a1 tree -> 'a1 tree -> key ->
        'a1 -> 'a1 tree -> I.t -> __ -> __ -> 'a2 tree -> ('a1, 'a2)
        coq_R_map_option -> 'a3 -> 'a2 tree -> ('a1, 'a2) coq_R_map_option ->
        'a3 -> 'a3) -> 'a1 tree -> 'a2 tree -> ('a1, 'a2) coq_R_map_option ->
        'a3

      val coq_R_map_option_rec :
        (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) -> ('a1 tree ->
        'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ -> 'a2 -> __ -> 'a2
        tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2 tree -> ('a1, 'a2)
        coq_R_map_option -> 'a3 -> 'a3) -> ('a1 tree -> 'a1 tree -> key ->
        'a1 -> 'a1 tree -> I.t -> __ -> __ -> 'a2 tree -> ('a1, 'a2)
        coq_R_map_option -> 'a3 -> 'a2 tree -> ('a1, 'a2) coq_R_map_option ->
        'a3 -> 'a3) -> 'a1 tree -> 'a2 tree -> ('a1, 'a2) coq_R_map_option ->
        'a3

      type ('elt, 'x0, 'x) coq_R_map2_opt =
      | R_map2_opt_0 of 'elt tree * 'x0 tree
      | R_map2_opt_1 of 'elt tree * 'x0 tree * 'elt tree * key * 'elt
         * 'elt tree * I.t
      | R_map2_opt_2 of 'elt tree * 'x0 tree * 'elt tree * key * 'elt
         * 'elt tree * I.t * 'x0 tree * key * 'x0 * 'x0 tree * I.t * 
         'x0 tree * 'x0 option * 'x0 tree * 'x * 'x tree
         * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
         * ('elt, 'x0, 'x) coq_R_map2_opt
      | R_map2_opt_3 of 'elt tree * 'x0 tree * 'elt tree * key * 'elt
         * 'elt tree * I.t * 'x0 tree * key * 'x0 * 'x0 tree * I.t * 
         'x0 tree * 'x0 option * 'x0 tree * 'x tree
         * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
         * ('elt, 'x0, 'x) coq_R_map2_opt

      val coq_R_map2_opt_rect :
        (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3 tree) ->
        ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2 tree -> __ -> 'a4) -> ('a1
        tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __
        -> __ -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 ->
        'a1 tree -> I.t -> __ -> 'a2 tree -> key -> 'a2 -> 'a2 tree -> I.t ->
        __ -> 'a2 tree -> 'a2 option -> 'a2 tree -> __ -> 'a3 -> __ -> 'a3
        tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1,
        'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree ->
        'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ -> 'a2 tree -> key ->
        'a2 -> 'a2 tree -> I.t -> __ -> 'a2 tree -> 'a2 option -> 'a2 tree ->
        __ -> __ -> 'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3
        tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1 tree ->
        'a2 tree -> 'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4

      val coq_R_map2_opt_rec :
        (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3 tree) ->
        ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2 tree -> __ -> 'a4) -> ('a1
        tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __
        -> __ -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 ->
        'a1 tree -> I.t -> __ -> 'a2 tree -> key -> 'a2 -> 'a2 tree -> I.t ->
        __ -> 'a2 tree -> 'a2 option -> 'a2 tree -> __ -> 'a3 -> __ -> 'a3
        tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1,
        'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree ->
        'a1 tree -> key -> 'a1 -> 'a1 tree -> I.t -> __ -> 'a2 tree -> key ->
        'a2 -> 'a2 tree -> I.t -> __ -> 'a2 tree -> 'a2 option -> 'a2 tree ->
        __ -> __ -> 'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3
        tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1 tree ->
        'a2 tree -> 'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4

      val fold' : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

      val flatten_e : 'a1 enumeration -> (key * 'a1) list
     end
   end

  type 'elt bst =
    'elt Raw.tree
    (* singleton inductive, whose constructor was Bst *)

  val this : 'a1 bst -> 'a1 Raw.tree

  type 'elt t = 'elt bst

  type key = E.t

  val empty : 'a1 t

  val is_empty : 'a1 t -> bool

  val add : key -> 'a1 -> 'a1 t -> 'a1 t

  val remove : key -> 'a1 t -> 'a1 t

  val mem : key -> 'a1 t -> bool

  val find : key -> 'a1 t -> 'a1 option

  val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

  val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

  val map2 :
    ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t -> 'a3 t

  val elements : 'a1 t -> (key * 'a1) list

  val cardinal : 'a1 t -> nat

  val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

  val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool
 end

module Coq_Make :
 functor (X:Coq_OrderedType) ->
 sig
  module E :
   sig
    type t = X.t

    val compare : t -> t -> t compare0

    val eq_dec : t -> t -> bool
   end

  module Raw :
   sig
    type key = X.t

    type 'elt tree =
    | Leaf
    | Node of 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t

    val tree_rect :
      'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 -> Z_as_Int.t
      -> 'a2) -> 'a1 tree -> 'a2

    val tree_rec :
      'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 -> Z_as_Int.t
      -> 'a2) -> 'a1 tree -> 'a2

    val height : 'a1 tree -> Z_as_Int.t

    val cardinal : 'a1 tree -> nat

    val empty : 'a1 tree

    val is_empty : 'a1 tree -> bool

    val mem : X.t -> 'a1 tree -> bool

    val find : X.t -> 'a1 tree -> 'a1 option

    val create : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

    val assert_false : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

    val bal : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

    val add : key -> 'a1 -> 'a1 tree -> 'a1 tree

    val remove_min :
      'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree * (key * 'a1)

    val merge : 'a1 tree -> 'a1 tree -> 'a1 tree

    val remove : X.t -> 'a1 tree -> 'a1 tree

    val join : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

    type 'elt triple = { t_left : 'elt tree; t_opt : 'elt option;
                         t_right : 'elt tree }

    val t_left : 'a1 triple -> 'a1 tree

    val t_opt : 'a1 triple -> 'a1 option

    val t_right : 'a1 triple -> 'a1 tree

    val split : X.t -> 'a1 tree -> 'a1 triple

    val concat : 'a1 tree -> 'a1 tree -> 'a1 tree

    val elements_aux : (key * 'a1) list -> 'a1 tree -> (key * 'a1) list

    val elements : 'a1 tree -> (key * 'a1) list

    val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

    type 'elt enumeration =
    | End
    | More of key * 'elt * 'elt tree * 'elt enumeration

    val enumeration_rect :
      'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 -> 'a2) -> 'a1
      enumeration -> 'a2

    val enumeration_rec :
      'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 -> 'a2) -> 'a1
      enumeration -> 'a2

    val cons : 'a1 tree -> 'a1 enumeration -> 'a1 enumeration

    val equal_more :
      ('a1 -> 'a1 -> bool) -> X.t -> 'a1 -> ('a1 enumeration -> bool) -> 'a1
      enumeration -> bool

    val equal_cont :
      ('a1 -> 'a1 -> bool) -> 'a1 tree -> ('a1 enumeration -> bool) -> 'a1
      enumeration -> bool

    val equal_end : 'a1 enumeration -> bool

    val equal : ('a1 -> 'a1 -> bool) -> 'a1 tree -> 'a1 tree -> bool

    val map : ('a1 -> 'a2) -> 'a1 tree -> 'a2 tree

    val mapi : (key -> 'a1 -> 'a2) -> 'a1 tree -> 'a2 tree

    val map_option : (key -> 'a1 -> 'a2 option) -> 'a1 tree -> 'a2 tree

    val map2_opt :
      (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3 tree) ->
      ('a2 tree -> 'a3 tree) -> 'a1 tree -> 'a2 tree -> 'a3 tree

    val map2 :
      ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 tree -> 'a2 tree -> 'a3
      tree

    module Proofs :
     sig
      module MX :
       sig
        module TO :
         sig
          type t = X.t
         end

        module IsTO :
         sig
         end

        module OrderTac :
         sig
         end

        val eq_dec : X.t -> X.t -> bool

        val lt_dec : X.t -> X.t -> bool

        val eqb : X.t -> X.t -> bool
       end

      module PX :
       sig
        module MO :
         sig
          module TO :
           sig
            type t = X.t
           end

          module IsTO :
           sig
           end

          module OrderTac :
           sig
           end

          val eq_dec : X.t -> X.t -> bool

          val lt_dec : X.t -> X.t -> bool

          val eqb : X.t -> X.t -> bool
         end
       end

      module L :
       sig
        module MX :
         sig
          module TO :
           sig
            type t = X.t
           end

          module IsTO :
           sig
           end

          module OrderTac :
           sig
           end

          val eq_dec : X.t -> X.t -> bool

          val lt_dec : X.t -> X.t -> bool

          val eqb : X.t -> X.t -> bool
         end

        module PX :
         sig
          module MO :
           sig
            module TO :
             sig
              type t = X.t
             end

            module IsTO :
             sig
             end

            module OrderTac :
             sig
             end

            val eq_dec : X.t -> X.t -> bool

            val lt_dec : X.t -> X.t -> bool

            val eqb : X.t -> X.t -> bool
           end
         end

        type key = X.t

        type 'elt t = (X.t * 'elt) list

        val empty : 'a1 t

        val is_empty : 'a1 t -> bool

        val mem : key -> 'a1 t -> bool

        type 'elt coq_R_mem =
        | R_mem_0 of 'elt t
        | R_mem_1 of 'elt t * X.t * 'elt * (X.t * 'elt) list
        | R_mem_2 of 'elt t * X.t * 'elt * (X.t * 'elt) list
        | R_mem_3 of 'elt t * X.t * 'elt * (X.t * 'elt) list * bool
           * 'elt coq_R_mem

        val coq_R_mem_rect :
          key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
          list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 ->
          (X.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1
          -> (X.t * 'a1) list -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem ->
          'a2 -> 'a2) -> 'a1 t -> bool -> 'a1 coq_R_mem -> 'a2

        val coq_R_mem_rec :
          key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
          list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 ->
          (X.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1
          -> (X.t * 'a1) list -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem ->
          'a2 -> 'a2) -> 'a1 t -> bool -> 'a1 coq_R_mem -> 'a2

        val mem_rect :
          key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
          list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 ->
          (X.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1
          -> (X.t * 'a1) list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

        val mem_rec :
          key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
          list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 ->
          (X.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1
          -> (X.t * 'a1) list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

        val coq_R_mem_correct : key -> 'a1 t -> bool -> 'a1 coq_R_mem

        val find : key -> 'a1 t -> 'a1 option

        type 'elt coq_R_find =
        | R_find_0 of 'elt t
        | R_find_1 of 'elt t * X.t * 'elt * (X.t * 'elt) list
        | R_find_2 of 'elt t * X.t * 'elt * (X.t * 'elt) list
        | R_find_3 of 'elt t * X.t * 'elt * (X.t * 'elt) list * 'elt option
           * 'elt coq_R_find

        val coq_R_find_rect :
          key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
          list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 ->
          (X.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1
          -> (X.t * 'a1) list -> __ -> __ -> __ -> 'a1 option -> 'a1
          coq_R_find -> 'a2 -> 'a2) -> 'a1 t -> 'a1 option -> 'a1 coq_R_find
          -> 'a2

        val coq_R_find_rec :
          key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
          list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 ->
          (X.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1
          -> (X.t * 'a1) list -> __ -> __ -> __ -> 'a1 option -> 'a1
          coq_R_find -> 'a2 -> 'a2) -> 'a1 t -> 'a1 option -> 'a1 coq_R_find
          -> 'a2

        val find_rect :
          key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
          list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 ->
          (X.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1
          -> (X.t * 'a1) list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

        val find_rec :
          key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
          list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 ->
          (X.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1
          -> (X.t * 'a1) list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

        val coq_R_find_correct : key -> 'a1 t -> 'a1 option -> 'a1 coq_R_find

        val add : key -> 'a1 -> 'a1 t -> 'a1 t

        type 'elt coq_R_add =
        | R_add_0 of 'elt t
        | R_add_1 of 'elt t * X.t * 'elt * (X.t * 'elt) list
        | R_add_2 of 'elt t * X.t * 'elt * (X.t * 'elt) list
        | R_add_3 of 'elt t * X.t * 'elt * (X.t * 'elt) list * 'elt t
           * 'elt coq_R_add

        val coq_R_add_rect :
          key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 ->
          (X.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1
          -> (X.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t ->
          'a1 -> (X.t * 'a1) list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_add
          -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_add -> 'a2

        val coq_R_add_rec :
          key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 ->
          (X.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1
          -> (X.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t ->
          'a1 -> (X.t * 'a1) list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_add
          -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_add -> 'a2

        val add_rect :
          key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 ->
          (X.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1
          -> (X.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t ->
          'a1 -> (X.t * 'a1) list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t
          -> 'a2

        val add_rec :
          key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 ->
          (X.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1
          -> (X.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t ->
          'a1 -> (X.t * 'a1) list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t
          -> 'a2

        val coq_R_add_correct : key -> 'a1 -> 'a1 t -> 'a1 t -> 'a1 coq_R_add

        val remove : key -> 'a1 t -> 'a1 t

        type 'elt coq_R_remove =
        | R_remove_0 of 'elt t
        | R_remove_1 of 'elt t * X.t * 'elt * (X.t * 'elt) list
        | R_remove_2 of 'elt t * X.t * 'elt * (X.t * 'elt) list
        | R_remove_3 of 'elt t * X.t * 'elt * (X.t * 'elt) list * 'elt t
           * 'elt coq_R_remove

        val coq_R_remove_rect :
          key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
          list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 ->
          (X.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1
          -> (X.t * 'a1) list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_remove
          -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove -> 'a2

        val coq_R_remove_rec :
          key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
          list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 ->
          (X.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1
          -> (X.t * 'a1) list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_remove
          -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove -> 'a2

        val remove_rect :
          key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
          list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 ->
          (X.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1
          -> (X.t * 'a1) list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

        val remove_rec :
          key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 -> (X.t * 'a1)
          list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1 ->
          (X.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t -> X.t -> 'a1
          -> (X.t * 'a1) list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

        val coq_R_remove_correct : key -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove

        val elements : 'a1 t -> 'a1 t

        val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

        type ('elt, 'a) coq_R_fold =
        | R_fold_0 of 'elt t * 'a
        | R_fold_1 of 'elt t * 'a * X.t * 'elt * (X.t * 'elt) list * 
           'a * ('elt, 'a) coq_R_fold

        val coq_R_fold_rect :
          (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) -> ('a1 t
          -> 'a2 -> X.t -> 'a1 -> (X.t * 'a1) list -> __ -> 'a2 -> ('a1, 'a2)
          coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a2 -> ('a1, 'a2)
          coq_R_fold -> 'a3

        val coq_R_fold_rec :
          (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) -> ('a1 t
          -> 'a2 -> X.t -> 'a1 -> (X.t * 'a1) list -> __ -> 'a2 -> ('a1, 'a2)
          coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a2 -> ('a1, 'a2)
          coq_R_fold -> 'a3

        val fold_rect :
          (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) -> ('a1 t
          -> 'a2 -> X.t -> 'a1 -> (X.t * 'a1) list -> __ -> 'a3 -> 'a3) ->
          'a1 t -> 'a2 -> 'a3

        val fold_rec :
          (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) -> ('a1 t
          -> 'a2 -> X.t -> 'a1 -> (X.t * 'a1) list -> __ -> 'a3 -> 'a3) ->
          'a1 t -> 'a2 -> 'a3

        val coq_R_fold_correct :
          (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2 -> ('a1, 'a2)
          coq_R_fold

        val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool

        type 'elt coq_R_equal =
        | R_equal_0 of 'elt t * 'elt t
        | R_equal_1 of 'elt t * 'elt t * X.t * 'elt * (X.t * 'elt) list * 
           X.t * 'elt * (X.t * 'elt) list * bool * 'elt coq_R_equal
        | R_equal_2 of 'elt t * 'elt t * X.t * 'elt * (X.t * 'elt) list * 
           X.t * 'elt * (X.t * 'elt) list * X.t compare0
        | R_equal_3 of 'elt t * 'elt t * 'elt t * 'elt t

        val coq_R_equal_rect :
          ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) -> ('a1
          t -> 'a1 t -> X.t -> 'a1 -> (X.t * 'a1) list -> __ -> X.t -> 'a1 ->
          (X.t * 'a1) list -> __ -> __ -> __ -> bool -> 'a1 coq_R_equal ->
          'a2 -> 'a2) -> ('a1 t -> 'a1 t -> X.t -> 'a1 -> (X.t * 'a1) list ->
          __ -> X.t -> 'a1 -> (X.t * 'a1) list -> __ -> X.t compare0 -> __ ->
          __ -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __
          -> 'a2) -> 'a1 t -> 'a1 t -> bool -> 'a1 coq_R_equal -> 'a2

        val coq_R_equal_rec :
          ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) -> ('a1
          t -> 'a1 t -> X.t -> 'a1 -> (X.t * 'a1) list -> __ -> X.t -> 'a1 ->
          (X.t * 'a1) list -> __ -> __ -> __ -> bool -> 'a1 coq_R_equal ->
          'a2 -> 'a2) -> ('a1 t -> 'a1 t -> X.t -> 'a1 -> (X.t * 'a1) list ->
          __ -> X.t -> 'a1 -> (X.t * 'a1) list -> __ -> X.t compare0 -> __ ->
          __ -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __
          -> 'a2) -> 'a1 t -> 'a1 t -> bool -> 'a1 coq_R_equal -> 'a2

        val equal_rect :
          ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) -> ('a1
          t -> 'a1 t -> X.t -> 'a1 -> (X.t * 'a1) list -> __ -> X.t -> 'a1 ->
          (X.t * 'a1) list -> __ -> __ -> __ -> 'a2 -> 'a2) -> ('a1 t -> 'a1
          t -> X.t -> 'a1 -> (X.t * 'a1) list -> __ -> X.t -> 'a1 ->
          (X.t * 'a1) list -> __ -> X.t compare0 -> __ -> __ -> 'a2) -> ('a1
          t -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2) -> 'a1 t ->
          'a1 t -> 'a2

        val equal_rec :
          ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) -> ('a1
          t -> 'a1 t -> X.t -> 'a1 -> (X.t * 'a1) list -> __ -> X.t -> 'a1 ->
          (X.t * 'a1) list -> __ -> __ -> __ -> 'a2 -> 'a2) -> ('a1 t -> 'a1
          t -> X.t -> 'a1 -> (X.t * 'a1) list -> __ -> X.t -> 'a1 ->
          (X.t * 'a1) list -> __ -> X.t compare0 -> __ -> __ -> 'a2) -> ('a1
          t -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2) -> 'a1 t ->
          'a1 t -> 'a2

        val coq_R_equal_correct :
          ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool -> 'a1 coq_R_equal

        val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

        val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

        val option_cons :
          key -> 'a1 option -> (key * 'a1) list -> (key * 'a1) list

        val map2_l :
          ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a3 t

        val map2_r :
          ('a1 option -> 'a2 option -> 'a3 option) -> 'a2 t -> 'a3 t

        val map2 :
          ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t -> 'a3 t

        val combine : 'a1 t -> 'a2 t -> ('a1 option * 'a2 option) t

        val fold_right_pair :
          ('a1 -> 'a2 -> 'a3 -> 'a3) -> ('a1 * 'a2) list -> 'a3 -> 'a3

        val map2_alt :
          ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t ->
          (key * 'a3) list

        val at_least_one :
          'a1 option -> 'a2 option -> ('a1 option * 'a2 option) option

        val at_least_one_then_f :
          ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 option -> 'a2
          option -> 'a3 option
       end

      type 'elt coq_R_mem =
      | R_mem_0 of 'elt tree
      | R_mem_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
         * Z_as_Int.t * bool * 'elt coq_R_mem
      | R_mem_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t
      | R_mem_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
         * Z_as_Int.t * bool * 'elt coq_R_mem

      val coq_R_mem_rect :
        X.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
        -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem
        -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
        Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key
        -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> bool -> 'a1
        coq_R_mem -> 'a2 -> 'a2) -> 'a1 tree -> bool -> 'a1 coq_R_mem -> 'a2

      val coq_R_mem_rec :
        X.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
        -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem
        -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
        Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key
        -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> bool -> 'a1
        coq_R_mem -> 'a2 -> 'a2) -> 'a1 tree -> bool -> 'a1 coq_R_mem -> 'a2

      type 'elt coq_R_find =
      | R_find_0 of 'elt tree
      | R_find_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
         * Z_as_Int.t * 'elt option * 'elt coq_R_find
      | R_find_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
         * Z_as_Int.t
      | R_find_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
         * Z_as_Int.t * 'elt option * 'elt coq_R_find

      val coq_R_find_rect :
        X.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
        -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 option -> 'a1
        coq_R_find -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 ->
        'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
        tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
        option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 option ->
        'a1 coq_R_find -> 'a2

      val coq_R_find_rec :
        X.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
        -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 option -> 'a1
        coq_R_find -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 ->
        'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
        tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
        option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 option ->
        'a1 coq_R_find -> 'a2

      type 'elt coq_R_bal =
      | R_bal_0 of 'elt tree * key * 'elt * 'elt tree
      | R_bal_1 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * key
         * 'elt * 'elt tree * Z_as_Int.t
      | R_bal_2 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * key
         * 'elt * 'elt tree * Z_as_Int.t
      | R_bal_3 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * key
         * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 'elt * 'elt tree
         * Z_as_Int.t
      | R_bal_4 of 'elt tree * key * 'elt * 'elt tree
      | R_bal_5 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * key
         * 'elt * 'elt tree * Z_as_Int.t
      | R_bal_6 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * key
         * 'elt * 'elt tree * Z_as_Int.t
      | R_bal_7 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * key
         * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 'elt * 'elt tree
         * Z_as_Int.t
      | R_bal_8 of 'elt tree * key * 'elt * 'elt tree

      val coq_R_bal_rect :
        ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> 'a2) -> ('a1
        tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key -> 'a1
        -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree ->
        key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1
        tree -> Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree ->
        key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1
        tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1
        tree -> Z_as_Int.t -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1
        tree -> __ -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1
        -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1
        tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key ->
        'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 ->
        'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree
        -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key
        -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> key
        -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2) -> ('a1 tree -> key ->
        'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a2) -> 'a1 tree -> key ->
        'a1 -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_bal -> 'a2

      val coq_R_bal_rec :
        ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> 'a2) -> ('a1
        tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key -> 'a1
        -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree ->
        key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1
        tree -> Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree ->
        key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1
        tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1
        tree -> Z_as_Int.t -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1
        tree -> __ -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1
        -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1
        tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key ->
        'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 ->
        'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree
        -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key
        -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> key
        -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2) -> ('a1 tree -> key ->
        'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a2) -> 'a1 tree -> key ->
        'a1 -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_bal -> 'a2

      type 'elt coq_R_add =
      | R_add_0 of 'elt tree
      | R_add_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
         * Z_as_Int.t * 'elt tree * 'elt coq_R_add
      | R_add_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t
      | R_add_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
         * Z_as_Int.t * 'elt tree * 'elt coq_R_add

      val coq_R_add_rect :
        key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key
        -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> 'a1
        coq_R_add -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 ->
        'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
        tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
        tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1
        coq_R_add -> 'a2

      val coq_R_add_rec :
        key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key
        -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> 'a1
        coq_R_add -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 ->
        'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
        tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
        tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1
        coq_R_add -> 'a2

      type 'elt coq_R_remove_min =
      | R_remove_min_0 of 'elt tree * key * 'elt * 'elt tree
      | R_remove_min_1 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
         * key * 'elt * 'elt tree * Z_as_Int.t * ('elt tree * (key * 'elt))
         * 'elt coq_R_remove_min * 'elt tree * (key * 'elt)

      val coq_R_remove_min_rect :
        ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> key
        -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
        Z_as_Int.t -> __ -> ('a1 tree * (key * 'a1)) -> 'a1 coq_R_remove_min
        -> 'a2 -> 'a1 tree -> (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> key ->
        'a1 -> 'a1 tree -> ('a1 tree * (key * 'a1)) -> 'a1 coq_R_remove_min
        -> 'a2

      val coq_R_remove_min_rec :
        ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> key
        -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
        Z_as_Int.t -> __ -> ('a1 tree * (key * 'a1)) -> 'a1 coq_R_remove_min
        -> 'a2 -> 'a1 tree -> (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> key ->
        'a1 -> 'a1 tree -> ('a1 tree * (key * 'a1)) -> 'a1 coq_R_remove_min
        -> 'a2

      type 'elt coq_R_merge =
      | R_merge_0 of 'elt tree * 'elt tree
      | R_merge_1 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
         * 'elt tree * Z_as_Int.t
      | R_merge_2 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
         * 'elt tree * Z_as_Int.t * 'elt tree * key * 'elt * 'elt tree
         * Z_as_Int.t * 'elt tree * (key * 'elt) * key * 'elt

      val coq_R_merge_rect :
        ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1
        tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a2) ->
        ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
        Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
        -> __ -> 'a1 tree -> (key * 'a1) -> __ -> key -> 'a1 -> __ -> 'a2) ->
        'a1 tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_merge -> 'a2

      val coq_R_merge_rec :
        ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1
        tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a2) ->
        ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
        Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
        -> __ -> 'a1 tree -> (key * 'a1) -> __ -> key -> 'a1 -> __ -> 'a2) ->
        'a1 tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_merge -> 'a2

      type 'elt coq_R_remove =
      | R_remove_0 of 'elt tree
      | R_remove_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
         * Z_as_Int.t * 'elt tree * 'elt coq_R_remove
      | R_remove_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
         * Z_as_Int.t
      | R_remove_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
         * Z_as_Int.t * 'elt tree * 'elt coq_R_remove

      val coq_R_remove_rect :
        X.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
        -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> 'a1
        coq_R_remove -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 ->
        'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
        tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
        tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 tree ->
        'a1 coq_R_remove -> 'a2

      val coq_R_remove_rec :
        X.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
        -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> 'a1
        coq_R_remove -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 ->
        'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
        tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
        tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 tree ->
        'a1 coq_R_remove -> 'a2

      type 'elt coq_R_concat =
      | R_concat_0 of 'elt tree * 'elt tree
      | R_concat_1 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
         * 'elt tree * Z_as_Int.t
      | R_concat_2 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
         * 'elt tree * Z_as_Int.t * 'elt tree * key * 'elt * 'elt tree
         * Z_as_Int.t * 'elt tree * (key * 'elt)

      val coq_R_concat_rect :
        ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1
        tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a2) ->
        ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
        Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
        -> __ -> 'a1 tree -> (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> 'a1
        tree -> 'a1 tree -> 'a1 coq_R_concat -> 'a2

      val coq_R_concat_rec :
        ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1
        tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a2) ->
        ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
        Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
        -> __ -> 'a1 tree -> (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> 'a1
        tree -> 'a1 tree -> 'a1 coq_R_concat -> 'a2

      type 'elt coq_R_split =
      | R_split_0 of 'elt tree
      | R_split_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
         * Z_as_Int.t * 'elt triple * 'elt coq_R_split * 'elt tree
         * 'elt option * 'elt tree
      | R_split_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
         * Z_as_Int.t
      | R_split_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
         * Z_as_Int.t * 'elt triple * 'elt coq_R_split * 'elt tree
         * 'elt option * 'elt tree

      val coq_R_split_rect :
        X.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
        -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 triple -> 'a1
        coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option -> 'a1 tree -> __ ->
        'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
        -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 ->
        'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 triple -> 'a1
        coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option -> 'a1 tree -> __ ->
        'a2) -> 'a1 tree -> 'a1 triple -> 'a1 coq_R_split -> 'a2

      val coq_R_split_rec :
        X.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
        -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 triple -> 'a1
        coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option -> 'a1 tree -> __ ->
        'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
        -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 ->
        'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 triple -> 'a1
        coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option -> 'a1 tree -> __ ->
        'a2) -> 'a1 tree -> 'a1 triple -> 'a1 coq_R_split -> 'a2

      type ('elt, 'x) coq_R_map_option =
      | R_map_option_0 of 'elt tree
      | R_map_option_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
         * Z_as_Int.t * 'x * 'x tree * ('elt, 'x) coq_R_map_option * 
         'x tree * ('elt, 'x) coq_R_map_option
      | R_map_option_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
         * Z_as_Int.t * 'x tree * ('elt, 'x) coq_R_map_option * 'x tree
         * ('elt, 'x) coq_R_map_option

      val coq_R_map_option_rect :
        (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) -> ('a1 tree ->
        'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 -> __
        -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2 tree ->
        ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> ('a1 tree -> 'a1 tree
        -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a2 tree ->
        ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2 tree -> ('a1, 'a2)
        coq_R_map_option -> 'a3 -> 'a3) -> 'a1 tree -> 'a2 tree -> ('a1, 'a2)
        coq_R_map_option -> 'a3

      val coq_R_map_option_rec :
        (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) -> ('a1 tree ->
        'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 -> __
        -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2 tree ->
        ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> ('a1 tree -> 'a1 tree
        -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a2 tree ->
        ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2 tree -> ('a1, 'a2)
        coq_R_map_option -> 'a3 -> 'a3) -> 'a1 tree -> 'a2 tree -> ('a1, 'a2)
        coq_R_map_option -> 'a3

      type ('elt, 'x0, 'x) coq_R_map2_opt =
      | R_map2_opt_0 of 'elt tree * 'x0 tree
      | R_map2_opt_1 of 'elt tree * 'x0 tree * 'elt tree * key * 'elt
         * 'elt tree * Z_as_Int.t
      | R_map2_opt_2 of 'elt tree * 'x0 tree * 'elt tree * key * 'elt
         * 'elt tree * Z_as_Int.t * 'x0 tree * key * 'x0 * 'x0 tree
         * Z_as_Int.t * 'x0 tree * 'x0 option * 'x0 tree * 'x * 'x tree
         * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
         * ('elt, 'x0, 'x) coq_R_map2_opt
      | R_map2_opt_3 of 'elt tree * 'x0 tree * 'elt tree * key * 'elt
         * 'elt tree * Z_as_Int.t * 'x0 tree * key * 'x0 * 'x0 tree
         * Z_as_Int.t * 'x0 tree * 'x0 option * 'x0 tree * 'x tree
         * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
         * ('elt, 'x0, 'x) coq_R_map2_opt

      val coq_R_map2_opt_rect :
        (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3 tree) ->
        ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2 tree -> __ -> 'a4) -> ('a1
        tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
        -> __ -> __ -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key ->
        'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 tree -> key -> 'a2 -> 'a2
        tree -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2 option -> 'a2 tree -> __
        -> 'a3 -> __ -> 'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 ->
        'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1
        tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
        -> __ -> 'a2 tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ ->
        'a2 tree -> 'a2 option -> 'a2 tree -> __ -> __ -> 'a3 tree -> ('a1,
        'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
        coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1 tree -> 'a2 tree -> 'a3 tree ->
        ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4

      val coq_R_map2_opt_rec :
        (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3 tree) ->
        ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2 tree -> __ -> 'a4) -> ('a1
        tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
        -> __ -> __ -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key ->
        'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 tree -> key -> 'a2 -> 'a2
        tree -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2 option -> 'a2 tree -> __
        -> 'a3 -> __ -> 'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 ->
        'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1
        tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
        -> __ -> 'a2 tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ ->
        'a2 tree -> 'a2 option -> 'a2 tree -> __ -> __ -> 'a3 tree -> ('a1,
        'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
        coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1 tree -> 'a2 tree -> 'a3 tree ->
        ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4

      val fold' : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

      val flatten_e : 'a1 enumeration -> (key * 'a1) list
     end
   end

  type 'elt bst =
    'elt Raw.tree
    (* singleton inductive, whose constructor was Bst *)

  val this : 'a1 bst -> 'a1 Raw.tree

  type 'elt t = 'elt bst

  type key = E.t

  val empty : 'a1 t

  val is_empty : 'a1 t -> bool

  val add : key -> 'a1 -> 'a1 t -> 'a1 t

  val remove : key -> 'a1 t -> 'a1 t

  val mem : key -> 'a1 t -> bool

  val find : key -> 'a1 t -> 'a1 option

  val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

  val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

  val map2 :
    ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t -> 'a3 t

  val elements : 'a1 t -> (key * 'a1) list

  val cardinal : 'a1 t -> nat

  val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

  val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool
 end

module Coq_WFacts_fun :
 functor (E:DecidableType) ->
 functor (M:sig
  type key = E.t

  type 'x t

  val empty : 'a1 t

  val is_empty : 'a1 t -> bool

  val add : key -> 'a1 -> 'a1 t -> 'a1 t

  val find : key -> 'a1 t -> 'a1 option

  val remove : key -> 'a1 t -> 'a1 t

  val mem : key -> 'a1 t -> bool

  val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

  val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

  val map2 :
    ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t -> 'a3 t

  val elements : 'a1 t -> (key * 'a1) list

  val cardinal : 'a1 t -> nat

  val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

  val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool
 end) ->
 sig
  val eqb : E.t -> E.t -> bool

  val coq_In_dec : 'a1 M.t -> M.key -> bool
 end

module Coq_WFacts :
 functor (M:Coq_WS) ->
 sig
  val eqb : M.E.t -> M.E.t -> bool

  val coq_In_dec : 'a1 M.t -> M.key -> bool
 end

module Coq_Facts :
 functor (M:Coq_WS) ->
 sig
  val eqb : M.E.t -> M.E.t -> bool

  val coq_In_dec : 'a1 M.t -> M.key -> bool
 end

module UOT_Facts :
 functor (U:UsualOrderedType) ->
 sig
 end

module type UsualComparableType =
 sig
  type t

  val compare : t -> t -> comparison
 end

module UOT_from_UCT :
 functor (C:UsualComparableType) ->
 sig
  type t = C.t

  val compare : t -> t -> t compare0

  val eq_dec : t -> t -> bool
 end

module Pair_as_UOT :
 functor (A:UsualOrderedType) ->
 functor (B:UsualOrderedType) ->
 sig
  module FA :
   sig
   end

  module FB :
   sig
   end

  type t = A.t * B.t

  val compare : t -> t -> (A.t * B.t) compare0

  val eq_dec : t -> t -> bool
 end

module type SIGMA =
 sig
  type coq_Sigma

  val coq_SigmaEnum : coq_Sigma list

  val coq_Sigma_dec : coq_Sigma -> coq_Sigma -> bool

  val compareT : coq_Sigma -> coq_Sigma -> comparison

  val ascii2Sigma : char -> coq_Sigma
 end

module DefsFn :
 functor (Ty:SIGMA) ->
 sig
  module T_as_UCT :
   sig
    type t = Ty.coq_Sigma

    val compare : Ty.coq_Sigma -> Ty.coq_Sigma -> comparison
   end

  module T_as_UOT :
   sig
    type t = T_as_UCT.t

    val compare : t -> t -> t compare0

    val eq_dec : t -> t -> bool
   end

  module SigFS :
   sig
    module X' :
     sig
      type t = T_as_UCT.t

      val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

      val compare : T_as_UCT.t -> T_as_UCT.t -> comparison
     end

    module MSet :
     sig
      module Raw :
       sig
        type elt = T_as_UCT.t

        type tree =
        | Leaf
        | Node of Z_as_Int.t * tree * T_as_UCT.t * tree

        val empty : tree

        val is_empty : tree -> bool

        val mem : T_as_UCT.t -> tree -> bool

        val min_elt : tree -> elt option

        val max_elt : tree -> elt option

        val choose : tree -> elt option

        val fold : (elt -> 'a1 -> 'a1) -> tree -> 'a1 -> 'a1

        val elements_aux : T_as_UCT.t list -> tree -> T_as_UCT.t list

        val elements : tree -> T_as_UCT.t list

        val rev_elements_aux : T_as_UCT.t list -> tree -> T_as_UCT.t list

        val rev_elements : tree -> T_as_UCT.t list

        val cardinal : tree -> nat

        val maxdepth : tree -> nat

        val mindepth : tree -> nat

        val for_all : (elt -> bool) -> tree -> bool

        val exists_ : (elt -> bool) -> tree -> bool

        type enumeration =
        | End
        | More of elt * tree * enumeration

        val cons : tree -> enumeration -> enumeration

        val compare_more :
          T_as_UCT.t -> (enumeration -> comparison) -> enumeration ->
          comparison

        val compare_cont :
          tree -> (enumeration -> comparison) -> enumeration -> comparison

        val compare_end : enumeration -> comparison

        val compare : tree -> tree -> comparison

        val equal : tree -> tree -> bool

        val subsetl : (tree -> bool) -> T_as_UCT.t -> tree -> bool

        val subsetr : (tree -> bool) -> T_as_UCT.t -> tree -> bool

        val subset : tree -> tree -> bool

        type t = tree

        val height : t -> Z_as_Int.t

        val singleton : T_as_UCT.t -> tree

        val create : t -> T_as_UCT.t -> t -> tree

        val assert_false : t -> T_as_UCT.t -> t -> tree

        val bal : t -> T_as_UCT.t -> t -> tree

        val add : T_as_UCT.t -> tree -> tree

        val join : tree -> elt -> t -> t

        val remove_min : tree -> elt -> t -> t * elt

        val merge : tree -> tree -> tree

        val remove : T_as_UCT.t -> tree -> tree

        val concat : tree -> tree -> tree

        type triple = { t_left : t; t_in : bool; t_right : t }

        val t_left : triple -> t

        val t_in : triple -> bool

        val t_right : triple -> t

        val split : T_as_UCT.t -> tree -> triple

        val inter : tree -> tree -> tree

        val diff : tree -> tree -> tree

        val union : tree -> tree -> tree

        val filter : (elt -> bool) -> tree -> tree

        val partition : (elt -> bool) -> t -> t * t

        val ltb_tree : T_as_UCT.t -> tree -> bool

        val gtb_tree : T_as_UCT.t -> tree -> bool

        val isok : tree -> bool

        module MX :
         sig
          module OrderTac :
           sig
            module OTF :
             sig
              type t = T_as_UCT.t

              val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

              val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
             end

            module TO :
             sig
              type t = T_as_UCT.t

              val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

              val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
             end
           end

          val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

          val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

          val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
         end

        type coq_R_min_elt =
        | R_min_elt_0 of tree
        | R_min_elt_1 of tree * Z_as_Int.t * tree * T_as_UCT.t * tree
        | R_min_elt_2 of tree * Z_as_Int.t * tree * T_as_UCT.t * tree
           * Z_as_Int.t * tree * T_as_UCT.t * tree * elt option
           * coq_R_min_elt

        type coq_R_max_elt =
        | R_max_elt_0 of tree
        | R_max_elt_1 of tree * Z_as_Int.t * tree * T_as_UCT.t * tree
        | R_max_elt_2 of tree * Z_as_Int.t * tree * T_as_UCT.t * tree
           * Z_as_Int.t * tree * T_as_UCT.t * tree * elt option
           * coq_R_max_elt

        module L :
         sig
          module MO :
           sig
            module OrderTac :
             sig
              module OTF :
               sig
                type t = T_as_UCT.t

                val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

                val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
               end

              module TO :
               sig
                type t = T_as_UCT.t

                val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

                val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
               end
             end

            val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

            val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

            val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
           end
         end

        val flatten_e : enumeration -> elt list

        type coq_R_bal =
        | R_bal_0 of t * T_as_UCT.t * t
        | R_bal_1 of t * T_as_UCT.t * t * Z_as_Int.t * tree * T_as_UCT.t
           * tree
        | R_bal_2 of t * T_as_UCT.t * t * Z_as_Int.t * tree * T_as_UCT.t
           * tree
        | R_bal_3 of t * T_as_UCT.t * t * Z_as_Int.t * tree * T_as_UCT.t
           * tree * Z_as_Int.t * tree * T_as_UCT.t * tree
        | R_bal_4 of t * T_as_UCT.t * t
        | R_bal_5 of t * T_as_UCT.t * t * Z_as_Int.t * tree * T_as_UCT.t
           * tree
        | R_bal_6 of t * T_as_UCT.t * t * Z_as_Int.t * tree * T_as_UCT.t
           * tree
        | R_bal_7 of t * T_as_UCT.t * t * Z_as_Int.t * tree * T_as_UCT.t
           * tree * Z_as_Int.t * tree * T_as_UCT.t * tree
        | R_bal_8 of t * T_as_UCT.t * t

        type coq_R_remove_min =
        | R_remove_min_0 of tree * elt * t
        | R_remove_min_1 of tree * elt * t * Z_as_Int.t * tree * T_as_UCT.t
           * tree * (t * elt) * coq_R_remove_min * t * elt

        type coq_R_merge =
        | R_merge_0 of tree * tree
        | R_merge_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * tree
        | R_merge_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * 
           tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * elt

        type coq_R_concat =
        | R_concat_0 of tree * tree
        | R_concat_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * tree
        | R_concat_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * 
           tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * elt

        type coq_R_inter =
        | R_inter_0 of tree * tree
        | R_inter_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * tree
        | R_inter_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * 
           tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * bool * 
           t * tree * coq_R_inter * tree * coq_R_inter
        | R_inter_3 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * 
           tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * bool * 
           t * tree * coq_R_inter * tree * coq_R_inter

        type coq_R_diff =
        | R_diff_0 of tree * tree
        | R_diff_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * tree
        | R_diff_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * 
           tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * bool * 
           t * tree * coq_R_diff * tree * coq_R_diff
        | R_diff_3 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * 
           tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * bool * 
           t * tree * coq_R_diff * tree * coq_R_diff

        type coq_R_union =
        | R_union_0 of tree * tree
        | R_union_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * tree
        | R_union_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * 
           tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * bool * 
           t * tree * coq_R_union * tree * coq_R_union
       end

      module E :
       sig
        type t = T_as_UCT.t

        val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

        val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
       end

      type elt = T_as_UCT.t

      type t_ = Raw.t
        (* singleton inductive, whose constructor was Mkt *)

      val this : t_ -> Raw.t

      type t = t_

      val mem : elt -> t -> bool

      val add : elt -> t -> t

      val remove : elt -> t -> t

      val singleton : elt -> t

      val union : t -> t -> t

      val inter : t -> t -> t

      val diff : t -> t -> t

      val equal : t -> t -> bool

      val subset : t -> t -> bool

      val empty : t

      val is_empty : t -> bool

      val elements : t -> elt list

      val choose : t -> elt option

      val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

      val cardinal : t -> nat

      val filter : (elt -> bool) -> t -> t

      val for_all : (elt -> bool) -> t -> bool

      val exists_ : (elt -> bool) -> t -> bool

      val partition : (elt -> bool) -> t -> t * t

      val eq_dec : t -> t -> bool

      val compare : t -> t -> comparison

      val min_elt : t -> elt option

      val max_elt : t -> elt option
     end

    type elt = T_as_UCT.t

    type t = MSet.t

    val empty : t

    val is_empty : t -> bool

    val mem : elt -> t -> bool

    val add : elt -> t -> t

    val singleton : elt -> t

    val remove : elt -> t -> t

    val union : t -> t -> t

    val inter : t -> t -> t

    val diff : t -> t -> t

    val eq_dec : t -> t -> bool

    val equal : t -> t -> bool

    val subset : t -> t -> bool

    val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

    val for_all : (elt -> bool) -> t -> bool

    val exists_ : (elt -> bool) -> t -> bool

    val filter : (elt -> bool) -> t -> t

    val partition : (elt -> bool) -> t -> t * t

    val cardinal : t -> nat

    val elements : t -> elt list

    val choose : t -> elt option

    module MF :
     sig
      val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
     end

    val min_elt : t -> elt option

    val max_elt : t -> elt option

    val compare : t -> t -> t compare0

    module E :
     sig
      type t = T_as_UCT.t

      val compare : T_as_UCT.t -> T_as_UCT.t -> T_as_UCT.t compare0

      val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
     end
   end

  module SigFSF :
   sig
    val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
   end

  module SigFM :
   sig
    module E :
     sig
      type t = T_as_UCT.t

      val compare : T_as_UCT.t -> T_as_UCT.t -> T_as_UCT.t compare0

      val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
     end

    module Raw :
     sig
      type key = T_as_UCT.t

      type 'elt tree =
      | Leaf
      | Node of 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t

      val tree_rect :
        'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
        Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

      val tree_rec :
        'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
        Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

      val height : 'a1 tree -> Z_as_Int.t

      val cardinal : 'a1 tree -> nat

      val empty : 'a1 tree

      val is_empty : 'a1 tree -> bool

      val mem : T_as_UCT.t -> 'a1 tree -> bool

      val find : T_as_UCT.t -> 'a1 tree -> 'a1 option

      val create : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

      val assert_false : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

      val bal : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

      val add : key -> 'a1 -> 'a1 tree -> 'a1 tree

      val remove_min :
        'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree * (key * 'a1)

      val merge : 'a1 tree -> 'a1 tree -> 'a1 tree

      val remove : T_as_UCT.t -> 'a1 tree -> 'a1 tree

      val join : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

      type 'elt triple = { t_left : 'elt tree; t_opt : 'elt option;
                           t_right : 'elt tree }

      val t_left : 'a1 triple -> 'a1 tree

      val t_opt : 'a1 triple -> 'a1 option

      val t_right : 'a1 triple -> 'a1 tree

      val split : T_as_UCT.t -> 'a1 tree -> 'a1 triple

      val concat : 'a1 tree -> 'a1 tree -> 'a1 tree

      val elements_aux : (key * 'a1) list -> 'a1 tree -> (key * 'a1) list

      val elements : 'a1 tree -> (key * 'a1) list

      val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

      type 'elt enumeration =
      | End
      | More of key * 'elt * 'elt tree * 'elt enumeration

      val enumeration_rect :
        'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 -> 'a2) ->
        'a1 enumeration -> 'a2

      val enumeration_rec :
        'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 -> 'a2) ->
        'a1 enumeration -> 'a2

      val cons : 'a1 tree -> 'a1 enumeration -> 'a1 enumeration

      val equal_more :
        ('a1 -> 'a1 -> bool) -> T_as_UCT.t -> 'a1 -> ('a1 enumeration ->
        bool) -> 'a1 enumeration -> bool

      val equal_cont :
        ('a1 -> 'a1 -> bool) -> 'a1 tree -> ('a1 enumeration -> bool) -> 'a1
        enumeration -> bool

      val equal_end : 'a1 enumeration -> bool

      val equal : ('a1 -> 'a1 -> bool) -> 'a1 tree -> 'a1 tree -> bool

      val map : ('a1 -> 'a2) -> 'a1 tree -> 'a2 tree

      val mapi : (key -> 'a1 -> 'a2) -> 'a1 tree -> 'a2 tree

      val map_option : (key -> 'a1 -> 'a2 option) -> 'a1 tree -> 'a2 tree

      val map2_opt :
        (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3 tree) ->
        ('a2 tree -> 'a3 tree) -> 'a1 tree -> 'a2 tree -> 'a3 tree

      val map2 :
        ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 tree -> 'a2 tree ->
        'a3 tree

      module Proofs :
       sig
        module MX :
         sig
          module TO :
           sig
            type t = T_as_UCT.t
           end

          module IsTO :
           sig
           end

          module OrderTac :
           sig
           end

          val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

          val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

          val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
         end

        module PX :
         sig
          module MO :
           sig
            module TO :
             sig
              type t = T_as_UCT.t
             end

            module IsTO :
             sig
             end

            module OrderTac :
             sig
             end

            val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

            val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

            val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
           end
         end

        module L :
         sig
          module MX :
           sig
            module TO :
             sig
              type t = T_as_UCT.t
             end

            module IsTO :
             sig
             end

            module OrderTac :
             sig
             end

            val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

            val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

            val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
           end

          module PX :
           sig
            module MO :
             sig
              module TO :
               sig
                type t = T_as_UCT.t
               end

              module IsTO :
               sig
               end

              module OrderTac :
               sig
               end

              val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

              val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

              val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
             end
           end

          type key = T_as_UCT.t

          type 'elt t = (T_as_UCT.t * 'elt) list

          val empty : 'a1 t

          val is_empty : 'a1 t -> bool

          val mem : key -> 'a1 t -> bool

          type 'elt coq_R_mem =
          | R_mem_0 of 'elt t
          | R_mem_1 of 'elt t * T_as_UCT.t * 'elt * (T_as_UCT.t * 'elt) list
          | R_mem_2 of 'elt t * T_as_UCT.t * 'elt * (T_as_UCT.t * 'elt) list
          | R_mem_3 of 'elt t * T_as_UCT.t * 'elt * (T_as_UCT.t * 'elt) list
             * bool * 'elt coq_R_mem

          val coq_R_mem_rect :
            key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
            (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
            T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
            'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list ->
            __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 t
            -> bool -> 'a1 coq_R_mem -> 'a2

          val coq_R_mem_rec :
            key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
            (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
            T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
            'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list ->
            __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 t
            -> bool -> 'a1 coq_R_mem -> 'a2

          val mem_rect :
            key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
            (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
            T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
            'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list ->
            __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

          val mem_rec :
            key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
            (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
            T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
            'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list ->
            __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

          val coq_R_mem_correct : key -> 'a1 t -> bool -> 'a1 coq_R_mem

          val find : key -> 'a1 t -> 'a1 option

          type 'elt coq_R_find =
          | R_find_0 of 'elt t
          | R_find_1 of 'elt t * T_as_UCT.t * 'elt * (T_as_UCT.t * 'elt) list
          | R_find_2 of 'elt t * T_as_UCT.t * 'elt * (T_as_UCT.t * 'elt) list
          | R_find_3 of 'elt t * T_as_UCT.t * 'elt * (T_as_UCT.t * 'elt) list
             * 'elt option * 'elt coq_R_find

          val coq_R_find_rect :
            key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
            (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
            T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
            'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list ->
            __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) ->
            'a1 t -> 'a1 option -> 'a1 coq_R_find -> 'a2

          val coq_R_find_rec :
            key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
            (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
            T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
            'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list ->
            __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) ->
            'a1 t -> 'a1 option -> 'a1 coq_R_find -> 'a2

          val find_rect :
            key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
            (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
            T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
            'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list ->
            __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

          val find_rec :
            key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
            (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
            T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
            'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list ->
            __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

          val coq_R_find_correct :
            key -> 'a1 t -> 'a1 option -> 'a1 coq_R_find

          val add : key -> 'a1 -> 'a1 t -> 'a1 t

          type 'elt coq_R_add =
          | R_add_0 of 'elt t
          | R_add_1 of 'elt t * T_as_UCT.t * 'elt * (T_as_UCT.t * 'elt) list
          | R_add_2 of 'elt t * T_as_UCT.t * 'elt * (T_as_UCT.t * 'elt) list
          | R_add_3 of 'elt t * T_as_UCT.t * 'elt * (T_as_UCT.t * 'elt) list
             * 'elt t * 'elt coq_R_add

          val coq_R_add_rect :
            key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1
            -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
            T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
            'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list ->
            __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 t
            -> 'a1 t -> 'a1 coq_R_add -> 'a2

          val coq_R_add_rec :
            key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1
            -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
            T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
            'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list ->
            __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 t
            -> 'a1 t -> 'a1 coq_R_add -> 'a2

          val add_rect :
            key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1
            -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
            T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
            'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list ->
            __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

          val add_rec :
            key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1
            -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
            T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
            'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list ->
            __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

          val coq_R_add_correct :
            key -> 'a1 -> 'a1 t -> 'a1 t -> 'a1 coq_R_add

          val remove : key -> 'a1 t -> 'a1 t

          type 'elt coq_R_remove =
          | R_remove_0 of 'elt t
          | R_remove_1 of 'elt t * T_as_UCT.t * 'elt
             * (T_as_UCT.t * 'elt) list
          | R_remove_2 of 'elt t * T_as_UCT.t * 'elt
             * (T_as_UCT.t * 'elt) list
          | R_remove_3 of 'elt t * T_as_UCT.t * 'elt
             * (T_as_UCT.t * 'elt) list * 'elt t * 'elt coq_R_remove

          val coq_R_remove_rect :
            key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
            (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
            T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
            'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list ->
            __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> 'a1
            t -> 'a1 t -> 'a1 coq_R_remove -> 'a2

          val coq_R_remove_rec :
            key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
            (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
            T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
            'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list ->
            __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> 'a1
            t -> 'a1 t -> 'a1 coq_R_remove -> 'a2

          val remove_rect :
            key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
            (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
            T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
            'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list ->
            __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

          val remove_rec :
            key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
            (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
            T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
            'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list ->
            __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

          val coq_R_remove_correct : key -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove

          val elements : 'a1 t -> 'a1 t

          val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

          type ('elt, 'a) coq_R_fold =
          | R_fold_0 of 'elt t * 'a
          | R_fold_1 of 'elt t * 'a * T_as_UCT.t * 'elt
             * (T_as_UCT.t * 'elt) list * 'a * ('elt, 'a) coq_R_fold

          val coq_R_fold_rect :
            (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) -> ('a1
            t -> 'a2 -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
            'a2 -> ('a1, 'a2) coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 ->
            'a2 -> ('a1, 'a2) coq_R_fold -> 'a3

          val coq_R_fold_rec :
            (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) -> ('a1
            t -> 'a2 -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
            'a2 -> ('a1, 'a2) coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 ->
            'a2 -> ('a1, 'a2) coq_R_fold -> 'a3

          val fold_rect :
            (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) -> ('a1
            t -> 'a2 -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
            'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a3

          val fold_rec :
            (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) -> ('a1
            t -> 'a2 -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
            'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a3

          val coq_R_fold_correct :
            (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2 -> ('a1, 'a2)
            coq_R_fold

          val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool

          type 'elt coq_R_equal =
          | R_equal_0 of 'elt t * 'elt t
          | R_equal_1 of 'elt t * 'elt t * T_as_UCT.t * 'elt
             * (T_as_UCT.t * 'elt) list * T_as_UCT.t * 'elt
             * (T_as_UCT.t * 'elt) list * bool * 'elt coq_R_equal
          | R_equal_2 of 'elt t * 'elt t * T_as_UCT.t * 'elt
             * (T_as_UCT.t * 'elt) list * T_as_UCT.t * 'elt
             * (T_as_UCT.t * 'elt) list * T_as_UCT.t compare0
          | R_equal_3 of 'elt t * 'elt t * 'elt t * 'elt t

          val coq_R_equal_rect :
            ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) ->
            ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
            -> __ -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __
            -> __ -> bool -> 'a1 coq_R_equal -> 'a2 -> 'a2) -> ('a1 t -> 'a1
            t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
            T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t
            compare0 -> __ -> __ -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ ->
            'a1 t -> __ -> __ -> 'a2) -> 'a1 t -> 'a1 t -> bool -> 'a1
            coq_R_equal -> 'a2

          val coq_R_equal_rec :
            ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) ->
            ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
            -> __ -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __
            -> __ -> bool -> 'a1 coq_R_equal -> 'a2 -> 'a2) -> ('a1 t -> 'a1
            t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
            T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t
            compare0 -> __ -> __ -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ ->
            'a1 t -> __ -> __ -> 'a2) -> 'a1 t -> 'a1 t -> bool -> 'a1
            coq_R_equal -> 'a2

          val equal_rect :
            ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) ->
            ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
            -> __ -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __
            -> __ -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 ->
            (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t -> 'a1 ->
            (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t compare0 -> __ -> __
            -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __ ->
            'a2) -> 'a1 t -> 'a1 t -> 'a2

          val equal_rec :
            ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) ->
            ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
            -> __ -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __
            -> __ -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 ->
            (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t -> 'a1 ->
            (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t compare0 -> __ -> __
            -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __ ->
            'a2) -> 'a1 t -> 'a1 t -> 'a2

          val coq_R_equal_correct :
            ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool -> 'a1 coq_R_equal

          val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

          val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

          val option_cons :
            key -> 'a1 option -> (key * 'a1) list -> (key * 'a1) list

          val map2_l :
            ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a3 t

          val map2_r :
            ('a1 option -> 'a2 option -> 'a3 option) -> 'a2 t -> 'a3 t

          val map2 :
            ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t -> 'a3
            t

          val combine : 'a1 t -> 'a2 t -> ('a1 option * 'a2 option) t

          val fold_right_pair :
            ('a1 -> 'a2 -> 'a3 -> 'a3) -> ('a1 * 'a2) list -> 'a3 -> 'a3

          val map2_alt :
            ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t ->
            (key * 'a3) list

          val at_least_one :
            'a1 option -> 'a2 option -> ('a1 option * 'a2 option) option

          val at_least_one_then_f :
            ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 option -> 'a2
            option -> 'a3 option
         end

        type 'elt coq_R_mem =
        | R_mem_0 of 'elt tree
        | R_mem_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * bool * 'elt coq_R_mem
        | R_mem_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t
        | R_mem_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * bool * 'elt coq_R_mem

        val coq_R_mem_rect :
          T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
          key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> bool ->
          'a1 coq_R_mem -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
          -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree ->
          'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __
          -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 tree -> bool -> 'a1
          coq_R_mem -> 'a2

        val coq_R_mem_rec :
          T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
          key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> bool ->
          'a1 coq_R_mem -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
          -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree ->
          'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __
          -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 tree -> bool -> 'a1
          coq_R_mem -> 'a2

        type 'elt coq_R_find =
        | R_find_0 of 'elt tree
        | R_find_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * 'elt option * 'elt coq_R_find
        | R_find_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t
        | R_find_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * 'elt option * 'elt coq_R_find

        val coq_R_find_rect :
          T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
          key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
          option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree ->
          key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) ->
          ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
          -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> 'a1
          tree -> 'a1 option -> 'a1 coq_R_find -> 'a2

        val coq_R_find_rec :
          T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
          key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
          option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree ->
          key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) ->
          ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
          -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> 'a1
          tree -> 'a1 option -> 'a1 coq_R_find -> 'a2

        type 'elt coq_R_bal =
        | R_bal_0 of 'elt tree * key * 'elt * 'elt tree
        | R_bal_1 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
           key * 'elt * 'elt tree * Z_as_Int.t
        | R_bal_2 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
           key * 'elt * 'elt tree * Z_as_Int.t
        | R_bal_3 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
           key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 'elt
           * 'elt tree * Z_as_Int.t
        | R_bal_4 of 'elt tree * key * 'elt * 'elt tree
        | R_bal_5 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
           key * 'elt * 'elt tree * Z_as_Int.t
        | R_bal_6 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
           key * 'elt * 'elt tree * Z_as_Int.t
        | R_bal_7 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
           key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 'elt
           * 'elt tree * Z_as_Int.t
        | R_bal_8 of 'elt tree * key * 'elt * 'elt tree

        val coq_R_bal_rect :
          ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> 'a2) ->
          ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key
          -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1
          tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key ->
          'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) ->
          ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key
          -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree ->
          key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2) -> ('a1 tree ->
          key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> __ -> 'a2) ->
          ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1
          tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
          'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __
          -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
          __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
          -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
          __ -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
          -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ ->
          __ -> __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree
          -> 'a1 coq_R_bal -> 'a2

        val coq_R_bal_rec :
          ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> 'a2) ->
          ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key
          -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1
          tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key ->
          'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) ->
          ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key
          -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree ->
          key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2) -> ('a1 tree ->
          key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> __ -> 'a2) ->
          ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1
          tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
          'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __
          -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
          __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
          -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
          __ -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
          -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ ->
          __ -> __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree
          -> 'a1 coq_R_bal -> 'a2

        type 'elt coq_R_add =
        | R_add_0 of 'elt tree
        | R_add_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * 'elt tree * 'elt coq_R_add
        | R_add_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t
        | R_add_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * 'elt tree * 'elt coq_R_add

        val coq_R_add_rect :
          key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
          key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree
          -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree -> key ->
          'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1
          tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
          __ -> __ -> 'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 tree ->
          'a1 tree -> 'a1 coq_R_add -> 'a2

        val coq_R_add_rec :
          key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
          key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree
          -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree -> key ->
          'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1
          tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
          __ -> __ -> 'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 tree ->
          'a1 tree -> 'a1 coq_R_add -> 'a2

        type 'elt coq_R_remove_min =
        | R_remove_min_0 of 'elt tree * key * 'elt * 'elt tree
        | R_remove_min_1 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
           * key * 'elt * 'elt tree * Z_as_Int.t * ('elt tree * (key * 'elt))
           * 'elt coq_R_remove_min * 'elt tree * (key * 'elt)

        val coq_R_remove_min_rect :
          ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1 tree ->
          key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> ('a1 tree * (key * 'a1)) -> 'a1
          coq_R_remove_min -> 'a2 -> 'a1 tree -> (key * 'a1) -> __ -> 'a2) ->
          'a1 tree -> key -> 'a1 -> 'a1 tree -> ('a1 tree * (key * 'a1)) ->
          'a1 coq_R_remove_min -> 'a2

        val coq_R_remove_min_rec :
          ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1 tree ->
          key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> ('a1 tree * (key * 'a1)) -> 'a1
          coq_R_remove_min -> 'a2 -> 'a1 tree -> (key * 'a1) -> __ -> 'a2) ->
          'a1 tree -> key -> 'a1 -> 'a1 tree -> ('a1 tree * (key * 'a1)) ->
          'a1 coq_R_remove_min -> 'a2

        type 'elt coq_R_merge =
        | R_merge_0 of 'elt tree * 'elt tree
        | R_merge_1 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
           * 'elt tree * Z_as_Int.t
        | R_merge_2 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
           * 'elt tree * Z_as_Int.t * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * 'elt tree * (key * 'elt) * key * 'elt

        val coq_R_merge_rect :
          ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1
          tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a2) ->
          ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> key -> 'a1 ->
          __ -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_merge
          -> 'a2

        val coq_R_merge_rec :
          ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1
          tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a2) ->
          ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> key -> 'a1 ->
          __ -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_merge
          -> 'a2

        type 'elt coq_R_remove =
        | R_remove_0 of 'elt tree
        | R_remove_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * 'elt tree * 'elt coq_R_remove
        | R_remove_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t
        | R_remove_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * 'elt tree * 'elt coq_R_remove

        val coq_R_remove_rect :
          T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
          key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree
          -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree -> key
          -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1
          tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
          __ -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> 'a1 tree
          -> 'a1 tree -> 'a1 coq_R_remove -> 'a2

        val coq_R_remove_rec :
          T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
          key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree
          -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree -> key
          -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1
          tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
          __ -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> 'a1 tree
          -> 'a1 tree -> 'a1 coq_R_remove -> 'a2

        type 'elt coq_R_concat =
        | R_concat_0 of 'elt tree * 'elt tree
        | R_concat_1 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
           * 'elt tree * Z_as_Int.t
        | R_concat_2 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
           * 'elt tree * Z_as_Int.t * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * 'elt tree * (key * 'elt)

        val coq_R_concat_rect :
          ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1
          tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a2) ->
          ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> 'a2) -> 'a1
          tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_concat -> 'a2

        val coq_R_concat_rec :
          ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1
          tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a2) ->
          ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> 'a2) -> 'a1
          tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_concat -> 'a2

        type 'elt coq_R_split =
        | R_split_0 of 'elt tree
        | R_split_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * 'elt triple * 'elt coq_R_split * 'elt tree
           * 'elt option * 'elt tree
        | R_split_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t
        | R_split_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * 'elt triple * 'elt coq_R_split * 'elt tree
           * 'elt option * 'elt tree

        val coq_R_split_rect :
          T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
          key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
          triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option -> 'a1
          tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
          tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
          tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
          'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option ->
          'a1 tree -> __ -> 'a2) -> 'a1 tree -> 'a1 triple -> 'a1 coq_R_split
          -> 'a2

        val coq_R_split_rec :
          T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
          key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
          triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option -> 'a1
          tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
          tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
          tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
          'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option ->
          'a1 tree -> __ -> 'a2) -> 'a1 tree -> 'a1 triple -> 'a1 coq_R_split
          -> 'a2

        type ('elt, 'x) coq_R_map_option =
        | R_map_option_0 of 'elt tree
        | R_map_option_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * 'x * 'x tree * ('elt, 'x) coq_R_map_option
           * 'x tree * ('elt, 'x) coq_R_map_option
        | R_map_option_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * 'x tree * ('elt, 'x) coq_R_map_option * 'x tree
           * ('elt, 'x) coq_R_map_option

        val coq_R_map_option_rect :
          (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) -> ('a1 tree
          -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 ->
          __ -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2 tree ->
          ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> ('a1 tree -> 'a1 tree
          -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a2 tree ->
          ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2 tree -> ('a1, 'a2)
          coq_R_map_option -> 'a3 -> 'a3) -> 'a1 tree -> 'a2 tree -> ('a1,
          'a2) coq_R_map_option -> 'a3

        val coq_R_map_option_rec :
          (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) -> ('a1 tree
          -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 ->
          __ -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2 tree ->
          ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> ('a1 tree -> 'a1 tree
          -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a2 tree ->
          ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2 tree -> ('a1, 'a2)
          coq_R_map_option -> 'a3 -> 'a3) -> 'a1 tree -> 'a2 tree -> ('a1,
          'a2) coq_R_map_option -> 'a3

        type ('elt, 'x0, 'x) coq_R_map2_opt =
        | R_map2_opt_0 of 'elt tree * 'x0 tree
        | R_map2_opt_1 of 'elt tree * 'x0 tree * 'elt tree * key * 'elt
           * 'elt tree * Z_as_Int.t
        | R_map2_opt_2 of 'elt tree * 'x0 tree * 'elt tree * key * 'elt
           * 'elt tree * Z_as_Int.t * 'x0 tree * key * 'x0 * 'x0 tree
           * Z_as_Int.t * 'x0 tree * 'x0 option * 'x0 tree * 'x * 'x tree
           * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
           * ('elt, 'x0, 'x) coq_R_map2_opt
        | R_map2_opt_3 of 'elt tree * 'x0 tree * 'elt tree * key * 'elt
           * 'elt tree * Z_as_Int.t * 'x0 tree * key * 'x0 * 'x0 tree
           * Z_as_Int.t * 'x0 tree * 'x0 option * 'x0 tree * 'x tree
           * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
           * ('elt, 'x0, 'x) coq_R_map2_opt

        val coq_R_map2_opt_rect :
          (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3 tree)
          -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2 tree -> __ -> 'a4) ->
          ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> __ -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree
          -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 tree -> key ->
          'a2 -> 'a2 tree -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2 option ->
          'a2 tree -> __ -> 'a3 -> __ -> 'a3 tree -> ('a1, 'a2, 'a3)
          coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt
          -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1
          -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 tree -> key -> 'a2 -> 'a2
          tree -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2 option -> 'a2 tree ->
          __ -> __ -> 'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 ->
          'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1
          tree -> 'a2 tree -> 'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt ->
          'a4

        val coq_R_map2_opt_rec :
          (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3 tree)
          -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2 tree -> __ -> 'a4) ->
          ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> __ -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree
          -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 tree -> key ->
          'a2 -> 'a2 tree -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2 option ->
          'a2 tree -> __ -> 'a3 -> __ -> 'a3 tree -> ('a1, 'a2, 'a3)
          coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt
          -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1
          -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 tree -> key -> 'a2 -> 'a2
          tree -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2 option -> 'a2 tree ->
          __ -> __ -> 'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 ->
          'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1
          tree -> 'a2 tree -> 'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt ->
          'a4

        val fold' : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

        val flatten_e : 'a1 enumeration -> (key * 'a1) list
       end
     end

    type 'elt bst =
      'elt Raw.tree
      (* singleton inductive, whose constructor was Bst *)

    val this : 'a1 bst -> 'a1 Raw.tree

    type 'elt t = 'elt bst

    type key = T_as_UCT.t

    val empty : 'a1 t

    val is_empty : 'a1 t -> bool

    val add : key -> 'a1 -> 'a1 t -> 'a1 t

    val remove : key -> 'a1 t -> 'a1 t

    val mem : key -> 'a1 t -> bool

    val find : key -> 'a1 t -> 'a1 option

    val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

    val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

    val map2 :
      ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t -> 'a3 t

    val elements : 'a1 t -> (key * 'a1) list

    val cardinal : 'a1 t -> nat

    val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

    val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool
   end

  module SigFMF :
   sig
    val eqb : T_as_UCT.t -> T_as_UCT.t -> bool

    val coq_In_dec : 'a1 SigFM.t -> SigFM.key -> bool
   end

  module Strings :
   sig
    type coq_String = Ty.coq_Sigma list

    val coq_String_dec : coq_String -> coq_String -> bool

    val rm_empty : coq_String list -> Ty.coq_Sigma list list
   end

  module Regexes :
   sig
    type regex =
    | EmptySet
    | EmptyStr
    | Char of Ty.coq_Sigma
    | App of regex * regex
    | Union of regex * regex
    | Star of regex

    val regex_rect :
      'a1 -> 'a1 -> (Ty.coq_Sigma -> 'a1) -> (regex -> 'a1 -> regex -> 'a1 ->
      'a1) -> (regex -> 'a1 -> regex -> 'a1 -> 'a1) -> (regex -> 'a1 -> 'a1)
      -> regex -> 'a1

    val regex_rec :
      'a1 -> 'a1 -> (Ty.coq_Sigma -> 'a1) -> (regex -> 'a1 -> regex -> 'a1 ->
      'a1) -> (regex -> 'a1 -> regex -> 'a1 -> 'a1) -> (regex -> 'a1 -> 'a1)
      -> regex -> 'a1

    val regex_dec : regex -> regex -> bool

    val regex_eq : regex -> regex -> bool

    val nullable' : regex -> bool

    val nullable : regex -> bool

    val derivative : Ty.coq_Sigma -> regex -> regex

    val derivative_list : Ty.coq_Sigma list -> regex -> regex

    val re_compare : regex -> regex -> comparison
   end

  module Coq_regex_as_UCT :
   sig
    type t = Regexes.regex

    val compare : Regexes.regex -> Regexes.regex -> comparison
   end

  module Coq_regex_as_UOT :
   sig
    type t = Coq_regex_as_UCT.t

    val compare : t -> t -> t compare0

    val eq_dec : t -> t -> bool
   end

  module Coq_reFS :
   sig
    module X' :
     sig
      type t = Coq_regex_as_UCT.t

      val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

      val compare : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> comparison
     end

    module MSet :
     sig
      module Raw :
       sig
        type elt = Coq_regex_as_UCT.t

        type tree =
        | Leaf
        | Node of Z_as_Int.t * tree * Coq_regex_as_UCT.t * tree

        val empty : tree

        val is_empty : tree -> bool

        val mem : Coq_regex_as_UCT.t -> tree -> bool

        val min_elt : tree -> elt option

        val max_elt : tree -> elt option

        val choose : tree -> elt option

        val fold : (elt -> 'a1 -> 'a1) -> tree -> 'a1 -> 'a1

        val elements_aux :
          Coq_regex_as_UCT.t list -> tree -> Coq_regex_as_UCT.t list

        val elements : tree -> Coq_regex_as_UCT.t list

        val rev_elements_aux :
          Coq_regex_as_UCT.t list -> tree -> Coq_regex_as_UCT.t list

        val rev_elements : tree -> Coq_regex_as_UCT.t list

        val cardinal : tree -> nat

        val maxdepth : tree -> nat

        val mindepth : tree -> nat

        val for_all : (elt -> bool) -> tree -> bool

        val exists_ : (elt -> bool) -> tree -> bool

        type enumeration =
        | End
        | More of elt * tree * enumeration

        val cons : tree -> enumeration -> enumeration

        val compare_more :
          Coq_regex_as_UCT.t -> (enumeration -> comparison) -> enumeration ->
          comparison

        val compare_cont :
          tree -> (enumeration -> comparison) -> enumeration -> comparison

        val compare_end : enumeration -> comparison

        val compare : tree -> tree -> comparison

        val equal : tree -> tree -> bool

        val subsetl : (tree -> bool) -> Coq_regex_as_UCT.t -> tree -> bool

        val subsetr : (tree -> bool) -> Coq_regex_as_UCT.t -> tree -> bool

        val subset : tree -> tree -> bool

        type t = tree

        val height : t -> Z_as_Int.t

        val singleton : Coq_regex_as_UCT.t -> tree

        val create : t -> Coq_regex_as_UCT.t -> t -> tree

        val assert_false : t -> Coq_regex_as_UCT.t -> t -> tree

        val bal : t -> Coq_regex_as_UCT.t -> t -> tree

        val add : Coq_regex_as_UCT.t -> tree -> tree

        val join : tree -> elt -> t -> t

        val remove_min : tree -> elt -> t -> t * elt

        val merge : tree -> tree -> tree

        val remove : Coq_regex_as_UCT.t -> tree -> tree

        val concat : tree -> tree -> tree

        type triple = { t_left : t; t_in : bool; t_right : t }

        val t_left : triple -> t

        val t_in : triple -> bool

        val t_right : triple -> t

        val split : Coq_regex_as_UCT.t -> tree -> triple

        val inter : tree -> tree -> tree

        val diff : tree -> tree -> tree

        val union : tree -> tree -> tree

        val filter : (elt -> bool) -> tree -> tree

        val partition : (elt -> bool) -> t -> t * t

        val ltb_tree : Coq_regex_as_UCT.t -> tree -> bool

        val gtb_tree : Coq_regex_as_UCT.t -> tree -> bool

        val isok : tree -> bool

        module MX :
         sig
          module OrderTac :
           sig
            module OTF :
             sig
              type t = Coq_regex_as_UCT.t

              val compare :
                Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> comparison

              val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
             end

            module TO :
             sig
              type t = Coq_regex_as_UCT.t

              val compare :
                Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> comparison

              val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
             end
           end

          val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

          val lt_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

          val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
         end

        type coq_R_min_elt =
        | R_min_elt_0 of tree
        | R_min_elt_1 of tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t * tree
        | R_min_elt_2 of tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t * 
           tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t * tree * elt option
           * coq_R_min_elt

        type coq_R_max_elt =
        | R_max_elt_0 of tree
        | R_max_elt_1 of tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t * tree
        | R_max_elt_2 of tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t * 
           tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t * tree * elt option
           * coq_R_max_elt

        module L :
         sig
          module MO :
           sig
            module OrderTac :
             sig
              module OTF :
               sig
                type t = Coq_regex_as_UCT.t

                val compare :
                  Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> comparison

                val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
               end

              module TO :
               sig
                type t = Coq_regex_as_UCT.t

                val compare :
                  Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> comparison

                val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
               end
             end

            val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

            val lt_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

            val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
           end
         end

        val flatten_e : enumeration -> elt list

        type coq_R_bal =
        | R_bal_0 of t * Coq_regex_as_UCT.t * t
        | R_bal_1 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * tree
           * Coq_regex_as_UCT.t * tree
        | R_bal_2 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * tree
           * Coq_regex_as_UCT.t * tree
        | R_bal_3 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * tree
           * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
           * Coq_regex_as_UCT.t * tree
        | R_bal_4 of t * Coq_regex_as_UCT.t * t
        | R_bal_5 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * tree
           * Coq_regex_as_UCT.t * tree
        | R_bal_6 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * tree
           * Coq_regex_as_UCT.t * tree
        | R_bal_7 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * tree
           * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
           * Coq_regex_as_UCT.t * tree
        | R_bal_8 of t * Coq_regex_as_UCT.t * t

        type coq_R_remove_min =
        | R_remove_min_0 of tree * elt * t
        | R_remove_min_1 of tree * elt * t * Z_as_Int.t * tree
           * Coq_regex_as_UCT.t * tree * (t * elt) * coq_R_remove_min * 
           t * elt

        type coq_R_merge =
        | R_merge_0 of tree * tree
        | R_merge_1 of tree * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
           * tree
        | R_merge_2 of tree * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
           * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t * tree * t * 
           elt

        type coq_R_concat =
        | R_concat_0 of tree * tree
        | R_concat_1 of tree * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
           * tree
        | R_concat_2 of tree * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
           * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t * tree * t * 
           elt

        type coq_R_inter =
        | R_inter_0 of tree * tree
        | R_inter_1 of tree * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
           * tree
        | R_inter_2 of tree * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
           * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t * tree * t * 
           bool * t * tree * coq_R_inter * tree * coq_R_inter
        | R_inter_3 of tree * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
           * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t * tree * t * 
           bool * t * tree * coq_R_inter * tree * coq_R_inter

        type coq_R_diff =
        | R_diff_0 of tree * tree
        | R_diff_1 of tree * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
           * tree
        | R_diff_2 of tree * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
           * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t * tree * t * 
           bool * t * tree * coq_R_diff * tree * coq_R_diff
        | R_diff_3 of tree * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
           * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t * tree * t * 
           bool * t * tree * coq_R_diff * tree * coq_R_diff

        type coq_R_union =
        | R_union_0 of tree * tree
        | R_union_1 of tree * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
           * tree
        | R_union_2 of tree * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
           * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t * tree * t * 
           bool * t * tree * coq_R_union * tree * coq_R_union
       end

      module E :
       sig
        type t = Coq_regex_as_UCT.t

        val compare : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> comparison

        val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
       end

      type elt = Coq_regex_as_UCT.t

      type t_ = Raw.t
        (* singleton inductive, whose constructor was Mkt *)

      val this : t_ -> Raw.t

      type t = t_

      val mem : elt -> t -> bool

      val add : elt -> t -> t

      val remove : elt -> t -> t

      val singleton : elt -> t

      val union : t -> t -> t

      val inter : t -> t -> t

      val diff : t -> t -> t

      val equal : t -> t -> bool

      val subset : t -> t -> bool

      val empty : t

      val is_empty : t -> bool

      val elements : t -> elt list

      val choose : t -> elt option

      val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

      val cardinal : t -> nat

      val filter : (elt -> bool) -> t -> t

      val for_all : (elt -> bool) -> t -> bool

      val exists_ : (elt -> bool) -> t -> bool

      val partition : (elt -> bool) -> t -> t * t

      val eq_dec : t -> t -> bool

      val compare : t -> t -> comparison

      val min_elt : t -> elt option

      val max_elt : t -> elt option
     end

    type elt = Coq_regex_as_UCT.t

    type t = MSet.t

    val empty : t

    val is_empty : t -> bool

    val mem : elt -> t -> bool

    val add : elt -> t -> t

    val singleton : elt -> t

    val remove : elt -> t -> t

    val union : t -> t -> t

    val inter : t -> t -> t

    val diff : t -> t -> t

    val eq_dec : t -> t -> bool

    val equal : t -> t -> bool

    val subset : t -> t -> bool

    val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

    val for_all : (elt -> bool) -> t -> bool

    val exists_ : (elt -> bool) -> t -> bool

    val filter : (elt -> bool) -> t -> t

    val partition : (elt -> bool) -> t -> t * t

    val cardinal : t -> nat

    val elements : t -> elt list

    val choose : t -> elt option

    module MF :
     sig
      val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
     end

    val min_elt : t -> elt option

    val max_elt : t -> elt option

    val compare : t -> t -> t compare0

    module E :
     sig
      type t = Coq_regex_as_UCT.t

      val compare :
        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t
        compare0

      val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
     end
   end

  module Coq_reFSF :
   sig
    val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
   end

  module Coq_reFM :
   sig
    module E :
     sig
      type t = Coq_regex_as_UCT.t

      val compare :
        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t
        compare0

      val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
     end

    module Raw :
     sig
      type key = Coq_regex_as_UCT.t

      type 'elt tree =
      | Leaf
      | Node of 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t

      val tree_rect :
        'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
        Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

      val tree_rec :
        'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
        Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

      val height : 'a1 tree -> Z_as_Int.t

      val cardinal : 'a1 tree -> nat

      val empty : 'a1 tree

      val is_empty : 'a1 tree -> bool

      val mem : Coq_regex_as_UCT.t -> 'a1 tree -> bool

      val find : Coq_regex_as_UCT.t -> 'a1 tree -> 'a1 option

      val create : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

      val assert_false : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

      val bal : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

      val add : key -> 'a1 -> 'a1 tree -> 'a1 tree

      val remove_min :
        'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree * (key * 'a1)

      val merge : 'a1 tree -> 'a1 tree -> 'a1 tree

      val remove : Coq_regex_as_UCT.t -> 'a1 tree -> 'a1 tree

      val join : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

      type 'elt triple = { t_left : 'elt tree; t_opt : 'elt option;
                           t_right : 'elt tree }

      val t_left : 'a1 triple -> 'a1 tree

      val t_opt : 'a1 triple -> 'a1 option

      val t_right : 'a1 triple -> 'a1 tree

      val split : Coq_regex_as_UCT.t -> 'a1 tree -> 'a1 triple

      val concat : 'a1 tree -> 'a1 tree -> 'a1 tree

      val elements_aux : (key * 'a1) list -> 'a1 tree -> (key * 'a1) list

      val elements : 'a1 tree -> (key * 'a1) list

      val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

      type 'elt enumeration =
      | End
      | More of key * 'elt * 'elt tree * 'elt enumeration

      val enumeration_rect :
        'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 -> 'a2) ->
        'a1 enumeration -> 'a2

      val enumeration_rec :
        'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 -> 'a2) ->
        'a1 enumeration -> 'a2

      val cons : 'a1 tree -> 'a1 enumeration -> 'a1 enumeration

      val equal_more :
        ('a1 -> 'a1 -> bool) -> Coq_regex_as_UCT.t -> 'a1 -> ('a1 enumeration
        -> bool) -> 'a1 enumeration -> bool

      val equal_cont :
        ('a1 -> 'a1 -> bool) -> 'a1 tree -> ('a1 enumeration -> bool) -> 'a1
        enumeration -> bool

      val equal_end : 'a1 enumeration -> bool

      val equal : ('a1 -> 'a1 -> bool) -> 'a1 tree -> 'a1 tree -> bool

      val map : ('a1 -> 'a2) -> 'a1 tree -> 'a2 tree

      val mapi : (key -> 'a1 -> 'a2) -> 'a1 tree -> 'a2 tree

      val map_option : (key -> 'a1 -> 'a2 option) -> 'a1 tree -> 'a2 tree

      val map2_opt :
        (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3 tree) ->
        ('a2 tree -> 'a3 tree) -> 'a1 tree -> 'a2 tree -> 'a3 tree

      val map2 :
        ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 tree -> 'a2 tree ->
        'a3 tree

      module Proofs :
       sig
        module MX :
         sig
          module TO :
           sig
            type t = Coq_regex_as_UCT.t
           end

          module IsTO :
           sig
           end

          module OrderTac :
           sig
           end

          val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

          val lt_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

          val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
         end

        module PX :
         sig
          module MO :
           sig
            module TO :
             sig
              type t = Coq_regex_as_UCT.t
             end

            module IsTO :
             sig
             end

            module OrderTac :
             sig
             end

            val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

            val lt_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

            val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
           end
         end

        module L :
         sig
          module MX :
           sig
            module TO :
             sig
              type t = Coq_regex_as_UCT.t
             end

            module IsTO :
             sig
             end

            module OrderTac :
             sig
             end

            val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

            val lt_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

            val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
           end

          module PX :
           sig
            module MO :
             sig
              module TO :
               sig
                type t = Coq_regex_as_UCT.t
               end

              module IsTO :
               sig
               end

              module OrderTac :
               sig
               end

              val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

              val lt_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

              val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
             end
           end

          type key = Coq_regex_as_UCT.t

          type 'elt t = (Coq_regex_as_UCT.t * 'elt) list

          val empty : 'a1 t

          val is_empty : 'a1 t -> bool

          val mem : key -> 'a1 t -> bool

          type 'elt coq_R_mem =
          | R_mem_0 of 'elt t
          | R_mem_1 of 'elt t * Coq_regex_as_UCT.t * 'elt
             * (Coq_regex_as_UCT.t * 'elt) list
          | R_mem_2 of 'elt t * Coq_regex_as_UCT.t * 'elt
             * (Coq_regex_as_UCT.t * 'elt) list
          | R_mem_3 of 'elt t * Coq_regex_as_UCT.t * 'elt
             * (Coq_regex_as_UCT.t * 'elt) list * bool * 'elt coq_R_mem

          val coq_R_mem_rect :
            key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
            'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
            -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
            (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1
            t -> Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list
            -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1
            t -> bool -> 'a1 coq_R_mem -> 'a2

          val coq_R_mem_rec :
            key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
            'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
            -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
            (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1
            t -> Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list
            -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1
            t -> bool -> 'a1 coq_R_mem -> 'a2

          val mem_rect :
            key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
            'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
            -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
            (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1
            t -> Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list
            -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

          val mem_rec :
            key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
            'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
            -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
            (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1
            t -> Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list
            -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

          val coq_R_mem_correct : key -> 'a1 t -> bool -> 'a1 coq_R_mem

          val find : key -> 'a1 t -> 'a1 option

          type 'elt coq_R_find =
          | R_find_0 of 'elt t
          | R_find_1 of 'elt t * Coq_regex_as_UCT.t * 'elt
             * (Coq_regex_as_UCT.t * 'elt) list
          | R_find_2 of 'elt t * Coq_regex_as_UCT.t * 'elt
             * (Coq_regex_as_UCT.t * 'elt) list
          | R_find_3 of 'elt t * Coq_regex_as_UCT.t * 'elt
             * (Coq_regex_as_UCT.t * 'elt) list * 'elt option
             * 'elt coq_R_find

          val coq_R_find_rect :
            key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
            'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
            -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
            (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1
            t -> Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list
            -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2)
            -> 'a1 t -> 'a1 option -> 'a1 coq_R_find -> 'a2

          val coq_R_find_rec :
            key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
            'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
            -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
            (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1
            t -> Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list
            -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2)
            -> 'a1 t -> 'a1 option -> 'a1 coq_R_find -> 'a2

          val find_rect :
            key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
            'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
            -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
            (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1
            t -> Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list
            -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

          val find_rec :
            key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
            'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
            -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
            (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1
            t -> Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list
            -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

          val coq_R_find_correct :
            key -> 'a1 t -> 'a1 option -> 'a1 coq_R_find

          val add : key -> 'a1 -> 'a1 t -> 'a1 t

          type 'elt coq_R_add =
          | R_add_0 of 'elt t
          | R_add_1 of 'elt t * Coq_regex_as_UCT.t * 'elt
             * (Coq_regex_as_UCT.t * 'elt) list
          | R_add_2 of 'elt t * Coq_regex_as_UCT.t * 'elt
             * (Coq_regex_as_UCT.t * 'elt) list
          | R_add_3 of 'elt t * Coq_regex_as_UCT.t * 'elt
             * (Coq_regex_as_UCT.t * 'elt) list * 'elt t * 'elt coq_R_add

          val coq_R_add_rect :
            key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
            Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list ->
            __ -> __ -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
            (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1
            t -> Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list
            -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1
            t -> 'a1 t -> 'a1 coq_R_add -> 'a2

          val coq_R_add_rec :
            key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
            Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list ->
            __ -> __ -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
            (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1
            t -> Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list
            -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1
            t -> 'a1 t -> 'a1 coq_R_add -> 'a2

          val add_rect :
            key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
            Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list ->
            __ -> __ -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
            (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1
            t -> Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list
            -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

          val add_rec :
            key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
            Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list ->
            __ -> __ -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
            (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1
            t -> Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list
            -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

          val coq_R_add_correct :
            key -> 'a1 -> 'a1 t -> 'a1 t -> 'a1 coq_R_add

          val remove : key -> 'a1 t -> 'a1 t

          type 'elt coq_R_remove =
          | R_remove_0 of 'elt t
          | R_remove_1 of 'elt t * Coq_regex_as_UCT.t * 'elt
             * (Coq_regex_as_UCT.t * 'elt) list
          | R_remove_2 of 'elt t * Coq_regex_as_UCT.t * 'elt
             * (Coq_regex_as_UCT.t * 'elt) list
          | R_remove_3 of 'elt t * Coq_regex_as_UCT.t * 'elt
             * (Coq_regex_as_UCT.t * 'elt) list * 'elt t * 'elt coq_R_remove

          val coq_R_remove_rect :
            key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
            'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
            -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
            (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1
            t -> Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list
            -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_remove -> 'a2 -> 'a2) ->
            'a1 t -> 'a1 t -> 'a1 coq_R_remove -> 'a2

          val coq_R_remove_rec :
            key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
            'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
            -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
            (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1
            t -> Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list
            -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_remove -> 'a2 -> 'a2) ->
            'a1 t -> 'a1 t -> 'a1 coq_R_remove -> 'a2

          val remove_rect :
            key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
            'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
            -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
            (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1
            t -> Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list
            -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

          val remove_rec :
            key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
            'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
            -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
            (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1
            t -> Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list
            -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

          val coq_R_remove_correct : key -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove

          val elements : 'a1 t -> 'a1 t

          val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

          type ('elt, 'a) coq_R_fold =
          | R_fold_0 of 'elt t * 'a
          | R_fold_1 of 'elt t * 'a * Coq_regex_as_UCT.t * 'elt
             * (Coq_regex_as_UCT.t * 'elt) list * 'a * ('elt, 'a) coq_R_fold

          val coq_R_fold_rect :
            (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) -> ('a1
            t -> 'a2 -> Coq_regex_as_UCT.t -> 'a1 ->
            (Coq_regex_as_UCT.t * 'a1) list -> __ -> 'a2 -> ('a1, 'a2)
            coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a2 -> ('a1, 'a2)
            coq_R_fold -> 'a3

          val coq_R_fold_rec :
            (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) -> ('a1
            t -> 'a2 -> Coq_regex_as_UCT.t -> 'a1 ->
            (Coq_regex_as_UCT.t * 'a1) list -> __ -> 'a2 -> ('a1, 'a2)
            coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a2 -> ('a1, 'a2)
            coq_R_fold -> 'a3

          val fold_rect :
            (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) -> ('a1
            t -> 'a2 -> Coq_regex_as_UCT.t -> 'a1 ->
            (Coq_regex_as_UCT.t * 'a1) list -> __ -> 'a3 -> 'a3) -> 'a1 t ->
            'a2 -> 'a3

          val fold_rec :
            (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) -> ('a1
            t -> 'a2 -> Coq_regex_as_UCT.t -> 'a1 ->
            (Coq_regex_as_UCT.t * 'a1) list -> __ -> 'a3 -> 'a3) -> 'a1 t ->
            'a2 -> 'a3

          val coq_R_fold_correct :
            (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2 -> ('a1, 'a2)
            coq_R_fold

          val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool

          type 'elt coq_R_equal =
          | R_equal_0 of 'elt t * 'elt t
          | R_equal_1 of 'elt t * 'elt t * Coq_regex_as_UCT.t * 'elt
             * (Coq_regex_as_UCT.t * 'elt) list * Coq_regex_as_UCT.t * 
             'elt * (Coq_regex_as_UCT.t * 'elt) list * bool * 'elt coq_R_equal
          | R_equal_2 of 'elt t * 'elt t * Coq_regex_as_UCT.t * 'elt
             * (Coq_regex_as_UCT.t * 'elt) list * Coq_regex_as_UCT.t * 
             'elt * (Coq_regex_as_UCT.t * 'elt) list
             * Coq_regex_as_UCT.t compare0
          | R_equal_3 of 'elt t * 'elt t * 'elt t * 'elt t

          val coq_R_equal_rect :
            ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) ->
            ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
            (Coq_regex_as_UCT.t * 'a1) list -> __ -> Coq_regex_as_UCT.t ->
            'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> bool
            -> 'a1 coq_R_equal -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t ->
            Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list ->
            __ -> Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
            list -> __ -> Coq_regex_as_UCT.t compare0 -> __ -> __ -> 'a2) ->
            ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2) ->
            'a1 t -> 'a1 t -> bool -> 'a1 coq_R_equal -> 'a2

          val coq_R_equal_rec :
            ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) ->
            ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
            (Coq_regex_as_UCT.t * 'a1) list -> __ -> Coq_regex_as_UCT.t ->
            'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> bool
            -> 'a1 coq_R_equal -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t ->
            Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list ->
            __ -> Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
            list -> __ -> Coq_regex_as_UCT.t compare0 -> __ -> __ -> 'a2) ->
            ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2) ->
            'a1 t -> 'a1 t -> bool -> 'a1 coq_R_equal -> 'a2

          val equal_rect :
            ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) ->
            ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
            (Coq_regex_as_UCT.t * 'a1) list -> __ -> Coq_regex_as_UCT.t ->
            'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2
            -> 'a2) -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
            (Coq_regex_as_UCT.t * 'a1) list -> __ -> Coq_regex_as_UCT.t ->
            'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ ->
            Coq_regex_as_UCT.t compare0 -> __ -> __ -> 'a2) -> ('a1 t -> 'a1
            t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2) -> 'a1 t -> 'a1 t
            -> 'a2

          val equal_rec :
            ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) ->
            ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
            (Coq_regex_as_UCT.t * 'a1) list -> __ -> Coq_regex_as_UCT.t ->
            'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2
            -> 'a2) -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
            (Coq_regex_as_UCT.t * 'a1) list -> __ -> Coq_regex_as_UCT.t ->
            'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ ->
            Coq_regex_as_UCT.t compare0 -> __ -> __ -> 'a2) -> ('a1 t -> 'a1
            t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2) -> 'a1 t -> 'a1 t
            -> 'a2

          val coq_R_equal_correct :
            ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool -> 'a1 coq_R_equal

          val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

          val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

          val option_cons :
            key -> 'a1 option -> (key * 'a1) list -> (key * 'a1) list

          val map2_l :
            ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a3 t

          val map2_r :
            ('a1 option -> 'a2 option -> 'a3 option) -> 'a2 t -> 'a3 t

          val map2 :
            ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t -> 'a3
            t

          val combine : 'a1 t -> 'a2 t -> ('a1 option * 'a2 option) t

          val fold_right_pair :
            ('a1 -> 'a2 -> 'a3 -> 'a3) -> ('a1 * 'a2) list -> 'a3 -> 'a3

          val map2_alt :
            ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t ->
            (key * 'a3) list

          val at_least_one :
            'a1 option -> 'a2 option -> ('a1 option * 'a2 option) option

          val at_least_one_then_f :
            ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 option -> 'a2
            option -> 'a3 option
         end

        type 'elt coq_R_mem =
        | R_mem_0 of 'elt tree
        | R_mem_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * bool * 'elt coq_R_mem
        | R_mem_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t
        | R_mem_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * bool * 'elt coq_R_mem

        val coq_R_mem_rect :
          Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
          tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
          bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree ->
          key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) ->
          ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
          -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 tree ->
          bool -> 'a1 coq_R_mem -> 'a2

        val coq_R_mem_rec :
          Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
          tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
          bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree ->
          key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) ->
          ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
          -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 tree ->
          bool -> 'a1 coq_R_mem -> 'a2

        type 'elt coq_R_find =
        | R_find_0 of 'elt tree
        | R_find_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * 'elt option * 'elt coq_R_find
        | R_find_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t
        | R_find_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * 'elt option * 'elt coq_R_find

        val coq_R_find_rect :
          Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
          tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
          'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> ('a1 tree -> 'a1
          tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
          'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2
          -> 'a2) -> 'a1 tree -> 'a1 option -> 'a1 coq_R_find -> 'a2

        val coq_R_find_rec :
          Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
          tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
          'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> ('a1 tree -> 'a1
          tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
          'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2
          -> 'a2) -> 'a1 tree -> 'a1 option -> 'a1 coq_R_find -> 'a2

        type 'elt coq_R_bal =
        | R_bal_0 of 'elt tree * key * 'elt * 'elt tree
        | R_bal_1 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
           key * 'elt * 'elt tree * Z_as_Int.t
        | R_bal_2 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
           key * 'elt * 'elt tree * Z_as_Int.t
        | R_bal_3 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
           key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 'elt
           * 'elt tree * Z_as_Int.t
        | R_bal_4 of 'elt tree * key * 'elt * 'elt tree
        | R_bal_5 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
           key * 'elt * 'elt tree * Z_as_Int.t
        | R_bal_6 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
           key * 'elt * 'elt tree * Z_as_Int.t
        | R_bal_7 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
           key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 'elt
           * 'elt tree * Z_as_Int.t
        | R_bal_8 of 'elt tree * key * 'elt * 'elt tree

        val coq_R_bal_rect :
          ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> 'a2) ->
          ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key
          -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1
          tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key ->
          'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) ->
          ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key
          -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree ->
          key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2) -> ('a1 tree ->
          key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> __ -> 'a2) ->
          ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1
          tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
          'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __
          -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
          __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
          -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
          __ -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
          -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ ->
          __ -> __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree
          -> 'a1 coq_R_bal -> 'a2

        val coq_R_bal_rec :
          ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> 'a2) ->
          ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key
          -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1
          tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key ->
          'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) ->
          ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key
          -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree ->
          key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2) -> ('a1 tree ->
          key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> __ -> 'a2) ->
          ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1
          tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
          'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __
          -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
          __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
          -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
          __ -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
          -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ ->
          __ -> __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree
          -> 'a1 coq_R_bal -> 'a2

        type 'elt coq_R_add =
        | R_add_0 of 'elt tree
        | R_add_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * 'elt tree * 'elt coq_R_add
        | R_add_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t
        | R_add_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * 'elt tree * 'elt coq_R_add

        val coq_R_add_rect :
          key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
          key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree
          -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree -> key ->
          'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1
          tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
          __ -> __ -> 'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 tree ->
          'a1 tree -> 'a1 coq_R_add -> 'a2

        val coq_R_add_rec :
          key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
          key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree
          -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree -> key ->
          'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1
          tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
          __ -> __ -> 'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 tree ->
          'a1 tree -> 'a1 coq_R_add -> 'a2

        type 'elt coq_R_remove_min =
        | R_remove_min_0 of 'elt tree * key * 'elt * 'elt tree
        | R_remove_min_1 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
           * key * 'elt * 'elt tree * Z_as_Int.t * ('elt tree * (key * 'elt))
           * 'elt coq_R_remove_min * 'elt tree * (key * 'elt)

        val coq_R_remove_min_rect :
          ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1 tree ->
          key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> ('a1 tree * (key * 'a1)) -> 'a1
          coq_R_remove_min -> 'a2 -> 'a1 tree -> (key * 'a1) -> __ -> 'a2) ->
          'a1 tree -> key -> 'a1 -> 'a1 tree -> ('a1 tree * (key * 'a1)) ->
          'a1 coq_R_remove_min -> 'a2

        val coq_R_remove_min_rec :
          ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1 tree ->
          key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> ('a1 tree * (key * 'a1)) -> 'a1
          coq_R_remove_min -> 'a2 -> 'a1 tree -> (key * 'a1) -> __ -> 'a2) ->
          'a1 tree -> key -> 'a1 -> 'a1 tree -> ('a1 tree * (key * 'a1)) ->
          'a1 coq_R_remove_min -> 'a2

        type 'elt coq_R_merge =
        | R_merge_0 of 'elt tree * 'elt tree
        | R_merge_1 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
           * 'elt tree * Z_as_Int.t
        | R_merge_2 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
           * 'elt tree * Z_as_Int.t * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * 'elt tree * (key * 'elt) * key * 'elt

        val coq_R_merge_rect :
          ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1
          tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a2) ->
          ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> key -> 'a1 ->
          __ -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_merge
          -> 'a2

        val coq_R_merge_rec :
          ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1
          tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a2) ->
          ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> key -> 'a1 ->
          __ -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_merge
          -> 'a2

        type 'elt coq_R_remove =
        | R_remove_0 of 'elt tree
        | R_remove_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * 'elt tree * 'elt coq_R_remove
        | R_remove_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t
        | R_remove_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * 'elt tree * 'elt coq_R_remove

        val coq_R_remove_rect :
          Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
          tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
          'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> ('a1 tree -> 'a1
          tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
          'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2
          -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_remove -> 'a2

        val coq_R_remove_rec :
          Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
          tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
          'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> ('a1 tree -> 'a1
          tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
          'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2
          -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_remove -> 'a2

        type 'elt coq_R_concat =
        | R_concat_0 of 'elt tree * 'elt tree
        | R_concat_1 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
           * 'elt tree * Z_as_Int.t
        | R_concat_2 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
           * 'elt tree * Z_as_Int.t * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * 'elt tree * (key * 'elt)

        val coq_R_concat_rect :
          ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1
          tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a2) ->
          ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> 'a2) -> 'a1
          tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_concat -> 'a2

        val coq_R_concat_rec :
          ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1
          tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a2) ->
          ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> 'a2) -> 'a1
          tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_concat -> 'a2

        type 'elt coq_R_split =
        | R_split_0 of 'elt tree
        | R_split_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * 'elt triple * 'elt coq_R_split * 'elt tree
           * 'elt option * 'elt tree
        | R_split_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t
        | R_split_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * 'elt triple * 'elt coq_R_split * 'elt tree
           * 'elt option * 'elt tree

        val coq_R_split_rect :
          Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
          tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
          'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option ->
          'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 ->
          'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree ->
          'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __
          -> 'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option
          -> 'a1 tree -> __ -> 'a2) -> 'a1 tree -> 'a1 triple -> 'a1
          coq_R_split -> 'a2

        val coq_R_split_rec :
          Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
          tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
          'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option ->
          'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 ->
          'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree ->
          'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __
          -> 'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option
          -> 'a1 tree -> __ -> 'a2) -> 'a1 tree -> 'a1 triple -> 'a1
          coq_R_split -> 'a2

        type ('elt, 'x) coq_R_map_option =
        | R_map_option_0 of 'elt tree
        | R_map_option_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * 'x * 'x tree * ('elt, 'x) coq_R_map_option
           * 'x tree * ('elt, 'x) coq_R_map_option
        | R_map_option_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * 'x tree * ('elt, 'x) coq_R_map_option * 'x tree
           * ('elt, 'x) coq_R_map_option

        val coq_R_map_option_rect :
          (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) -> ('a1 tree
          -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 ->
          __ -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2 tree ->
          ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> ('a1 tree -> 'a1 tree
          -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a2 tree ->
          ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2 tree -> ('a1, 'a2)
          coq_R_map_option -> 'a3 -> 'a3) -> 'a1 tree -> 'a2 tree -> ('a1,
          'a2) coq_R_map_option -> 'a3

        val coq_R_map_option_rec :
          (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) -> ('a1 tree
          -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 ->
          __ -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2 tree ->
          ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> ('a1 tree -> 'a1 tree
          -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a2 tree ->
          ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2 tree -> ('a1, 'a2)
          coq_R_map_option -> 'a3 -> 'a3) -> 'a1 tree -> 'a2 tree -> ('a1,
          'a2) coq_R_map_option -> 'a3

        type ('elt, 'x0, 'x) coq_R_map2_opt =
        | R_map2_opt_0 of 'elt tree * 'x0 tree
        | R_map2_opt_1 of 'elt tree * 'x0 tree * 'elt tree * key * 'elt
           * 'elt tree * Z_as_Int.t
        | R_map2_opt_2 of 'elt tree * 'x0 tree * 'elt tree * key * 'elt
           * 'elt tree * Z_as_Int.t * 'x0 tree * key * 'x0 * 'x0 tree
           * Z_as_Int.t * 'x0 tree * 'x0 option * 'x0 tree * 'x * 'x tree
           * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
           * ('elt, 'x0, 'x) coq_R_map2_opt
        | R_map2_opt_3 of 'elt tree * 'x0 tree * 'elt tree * key * 'elt
           * 'elt tree * Z_as_Int.t * 'x0 tree * key * 'x0 * 'x0 tree
           * Z_as_Int.t * 'x0 tree * 'x0 option * 'x0 tree * 'x tree
           * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
           * ('elt, 'x0, 'x) coq_R_map2_opt

        val coq_R_map2_opt_rect :
          (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3 tree)
          -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2 tree -> __ -> 'a4) ->
          ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> __ -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree
          -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 tree -> key ->
          'a2 -> 'a2 tree -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2 option ->
          'a2 tree -> __ -> 'a3 -> __ -> 'a3 tree -> ('a1, 'a2, 'a3)
          coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt
          -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1
          -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 tree -> key -> 'a2 -> 'a2
          tree -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2 option -> 'a2 tree ->
          __ -> __ -> 'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 ->
          'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1
          tree -> 'a2 tree -> 'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt ->
          'a4

        val coq_R_map2_opt_rec :
          (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3 tree)
          -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2 tree -> __ -> 'a4) ->
          ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> __ -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree
          -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 tree -> key ->
          'a2 -> 'a2 tree -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2 option ->
          'a2 tree -> __ -> 'a3 -> __ -> 'a3 tree -> ('a1, 'a2, 'a3)
          coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt
          -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1
          -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 tree -> key -> 'a2 -> 'a2
          tree -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2 option -> 'a2 tree ->
          __ -> __ -> 'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 ->
          'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1
          tree -> 'a2 tree -> 'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt ->
          'a4

        val fold' : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

        val flatten_e : 'a1 enumeration -> (key * 'a1) list
       end
     end

    type 'elt bst =
      'elt Raw.tree
      (* singleton inductive, whose constructor was Bst *)

    val this : 'a1 bst -> 'a1 Raw.tree

    type 'elt t = 'elt bst

    type key = Coq_regex_as_UCT.t

    val empty : 'a1 t

    val is_empty : 'a1 t -> bool

    val add : key -> 'a1 -> 'a1 t -> 'a1 t

    val remove : key -> 'a1 t -> 'a1 t

    val mem : key -> 'a1 t -> bool

    val find : key -> 'a1 t -> 'a1 option

    val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

    val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

    val map2 :
      ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t -> 'a3 t

    val elements : 'a1 t -> (key * 'a1) list

    val cardinal : 'a1 t -> nat

    val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

    val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool
   end

  module Coq_reFMF :
   sig
    val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

    val coq_In_dec : 'a1 Coq_reFM.t -> Coq_reFM.key -> bool
   end

  module MatchSpec :
   sig
   end

  module MatchSpecLemmas :
   sig
   end

  module Notations :
   sig
   end

  module Helpers :
   sig
    val coq_Plus : Regexes.regex -> Regexes.regex

    val coq_IterUnion : Regexes.regex list -> Regexes.regex

    val coq_IterApp : Regexes.regex list -> Regexes.regex

    val coq_Optional : Regexes.regex -> Regexes.regex

    val coq_REString : Strings.coq_String -> Regexes.regex
   end
 end

module type T =
 sig
  module Ty :
   SIGMA

  module Defs :
   sig
    module T_as_UCT :
     sig
      type t = Ty.coq_Sigma

      val compare : Ty.coq_Sigma -> Ty.coq_Sigma -> comparison
     end

    module T_as_UOT :
     sig
      type t = T_as_UCT.t

      val compare : t -> t -> t compare0

      val eq_dec : t -> t -> bool
     end

    module SigFS :
     sig
      module X' :
       sig
        type t = T_as_UCT.t

        val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

        val compare : T_as_UCT.t -> T_as_UCT.t -> comparison
       end

      module MSet :
       sig
        module Raw :
         sig
          type elt = T_as_UCT.t

          type tree =
          | Leaf
          | Node of Z_as_Int.t * tree * T_as_UCT.t * tree

          val empty : tree

          val is_empty : tree -> bool

          val mem : T_as_UCT.t -> tree -> bool

          val min_elt : tree -> elt option

          val max_elt : tree -> elt option

          val choose : tree -> elt option

          val fold : (elt -> 'a1 -> 'a1) -> tree -> 'a1 -> 'a1

          val elements_aux : T_as_UCT.t list -> tree -> T_as_UCT.t list

          val elements : tree -> T_as_UCT.t list

          val rev_elements_aux : T_as_UCT.t list -> tree -> T_as_UCT.t list

          val rev_elements : tree -> T_as_UCT.t list

          val cardinal : tree -> nat

          val maxdepth : tree -> nat

          val mindepth : tree -> nat

          val for_all : (elt -> bool) -> tree -> bool

          val exists_ : (elt -> bool) -> tree -> bool

          type enumeration =
          | End
          | More of elt * tree * enumeration

          val cons : tree -> enumeration -> enumeration

          val compare_more :
            T_as_UCT.t -> (enumeration -> comparison) -> enumeration ->
            comparison

          val compare_cont :
            tree -> (enumeration -> comparison) -> enumeration -> comparison

          val compare_end : enumeration -> comparison

          val compare : tree -> tree -> comparison

          val equal : tree -> tree -> bool

          val subsetl : (tree -> bool) -> T_as_UCT.t -> tree -> bool

          val subsetr : (tree -> bool) -> T_as_UCT.t -> tree -> bool

          val subset : tree -> tree -> bool

          type t = tree

          val height : t -> Z_as_Int.t

          val singleton : T_as_UCT.t -> tree

          val create : t -> T_as_UCT.t -> t -> tree

          val assert_false : t -> T_as_UCT.t -> t -> tree

          val bal : t -> T_as_UCT.t -> t -> tree

          val add : T_as_UCT.t -> tree -> tree

          val join : tree -> elt -> t -> t

          val remove_min : tree -> elt -> t -> t * elt

          val merge : tree -> tree -> tree

          val remove : T_as_UCT.t -> tree -> tree

          val concat : tree -> tree -> tree

          type triple = { t_left : t; t_in : bool; t_right : t }

          val t_left : triple -> t

          val t_in : triple -> bool

          val t_right : triple -> t

          val split : T_as_UCT.t -> tree -> triple

          val inter : tree -> tree -> tree

          val diff : tree -> tree -> tree

          val union : tree -> tree -> tree

          val filter : (elt -> bool) -> tree -> tree

          val partition : (elt -> bool) -> t -> t * t

          val ltb_tree : T_as_UCT.t -> tree -> bool

          val gtb_tree : T_as_UCT.t -> tree -> bool

          val isok : tree -> bool

          module MX :
           sig
            module OrderTac :
             sig
              module OTF :
               sig
                type t = T_as_UCT.t

                val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

                val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
               end

              module TO :
               sig
                type t = T_as_UCT.t

                val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

                val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
               end
             end

            val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

            val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

            val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
           end

          type coq_R_min_elt =
          | R_min_elt_0 of tree
          | R_min_elt_1 of tree * Z_as_Int.t * tree * T_as_UCT.t * tree
          | R_min_elt_2 of tree * Z_as_Int.t * tree * T_as_UCT.t * tree
             * Z_as_Int.t * tree * T_as_UCT.t * tree * elt option
             * coq_R_min_elt

          type coq_R_max_elt =
          | R_max_elt_0 of tree
          | R_max_elt_1 of tree * Z_as_Int.t * tree * T_as_UCT.t * tree
          | R_max_elt_2 of tree * Z_as_Int.t * tree * T_as_UCT.t * tree
             * Z_as_Int.t * tree * T_as_UCT.t * tree * elt option
             * coq_R_max_elt

          module L :
           sig
            module MO :
             sig
              module OrderTac :
               sig
                module OTF :
                 sig
                  type t = T_as_UCT.t

                  val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

                  val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
                 end

                module TO :
                 sig
                  type t = T_as_UCT.t

                  val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

                  val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
                 end
               end

              val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

              val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

              val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
             end
           end

          val flatten_e : enumeration -> elt list

          type coq_R_bal =
          | R_bal_0 of t * T_as_UCT.t * t
          | R_bal_1 of t * T_as_UCT.t * t * Z_as_Int.t * tree * T_as_UCT.t
             * tree
          | R_bal_2 of t * T_as_UCT.t * t * Z_as_Int.t * tree * T_as_UCT.t
             * tree
          | R_bal_3 of t * T_as_UCT.t * t * Z_as_Int.t * tree * T_as_UCT.t
             * tree * Z_as_Int.t * tree * T_as_UCT.t * tree
          | R_bal_4 of t * T_as_UCT.t * t
          | R_bal_5 of t * T_as_UCT.t * t * Z_as_Int.t * tree * T_as_UCT.t
             * tree
          | R_bal_6 of t * T_as_UCT.t * t * Z_as_Int.t * tree * T_as_UCT.t
             * tree
          | R_bal_7 of t * T_as_UCT.t * t * Z_as_Int.t * tree * T_as_UCT.t
             * tree * Z_as_Int.t * tree * T_as_UCT.t * tree
          | R_bal_8 of t * T_as_UCT.t * t

          type coq_R_remove_min =
          | R_remove_min_0 of tree * elt * t
          | R_remove_min_1 of tree * elt * t * Z_as_Int.t * tree * T_as_UCT.t
             * tree * (t * elt) * coq_R_remove_min * t * elt

          type coq_R_merge =
          | R_merge_0 of tree * tree
          | R_merge_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * tree
          | R_merge_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * 
             tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * elt

          type coq_R_concat =
          | R_concat_0 of tree * tree
          | R_concat_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * tree
          | R_concat_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * 
             tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * elt

          type coq_R_inter =
          | R_inter_0 of tree * tree
          | R_inter_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * tree
          | R_inter_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * 
             tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * bool * 
             t * tree * coq_R_inter * tree * coq_R_inter
          | R_inter_3 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * 
             tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * bool * 
             t * tree * coq_R_inter * tree * coq_R_inter

          type coq_R_diff =
          | R_diff_0 of tree * tree
          | R_diff_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * tree
          | R_diff_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * 
             tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * bool * 
             t * tree * coq_R_diff * tree * coq_R_diff
          | R_diff_3 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * 
             tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * bool * 
             t * tree * coq_R_diff * tree * coq_R_diff

          type coq_R_union =
          | R_union_0 of tree * tree
          | R_union_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * tree
          | R_union_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * 
             tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * bool * 
             t * tree * coq_R_union * tree * coq_R_union
         end

        module E :
         sig
          type t = T_as_UCT.t

          val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

          val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
         end

        type elt = T_as_UCT.t

        type t_ = Raw.t
          (* singleton inductive, whose constructor was Mkt *)

        val this : t_ -> Raw.t

        type t = t_

        val mem : elt -> t -> bool

        val add : elt -> t -> t

        val remove : elt -> t -> t

        val singleton : elt -> t

        val union : t -> t -> t

        val inter : t -> t -> t

        val diff : t -> t -> t

        val equal : t -> t -> bool

        val subset : t -> t -> bool

        val empty : t

        val is_empty : t -> bool

        val elements : t -> elt list

        val choose : t -> elt option

        val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

        val cardinal : t -> nat

        val filter : (elt -> bool) -> t -> t

        val for_all : (elt -> bool) -> t -> bool

        val exists_ : (elt -> bool) -> t -> bool

        val partition : (elt -> bool) -> t -> t * t

        val eq_dec : t -> t -> bool

        val compare : t -> t -> comparison

        val min_elt : t -> elt option

        val max_elt : t -> elt option
       end

      type elt = T_as_UCT.t

      type t = MSet.t

      val empty : t

      val is_empty : t -> bool

      val mem : elt -> t -> bool

      val add : elt -> t -> t

      val singleton : elt -> t

      val remove : elt -> t -> t

      val union : t -> t -> t

      val inter : t -> t -> t

      val diff : t -> t -> t

      val eq_dec : t -> t -> bool

      val equal : t -> t -> bool

      val subset : t -> t -> bool

      val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

      val for_all : (elt -> bool) -> t -> bool

      val exists_ : (elt -> bool) -> t -> bool

      val filter : (elt -> bool) -> t -> t

      val partition : (elt -> bool) -> t -> t * t

      val cardinal : t -> nat

      val elements : t -> elt list

      val choose : t -> elt option

      module MF :
       sig
        val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
       end

      val min_elt : t -> elt option

      val max_elt : t -> elt option

      val compare : t -> t -> t compare0

      module E :
       sig
        type t = T_as_UCT.t

        val compare : T_as_UCT.t -> T_as_UCT.t -> T_as_UCT.t compare0

        val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
       end
     end

    module SigFSF :
     sig
      val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
     end

    module SigFM :
     sig
      module E :
       sig
        type t = T_as_UCT.t

        val compare : T_as_UCT.t -> T_as_UCT.t -> T_as_UCT.t compare0

        val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
       end

      module Raw :
       sig
        type key = T_as_UCT.t

        type 'elt tree =
        | Leaf
        | Node of 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t

        val tree_rect :
          'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
          Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

        val tree_rec :
          'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
          Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

        val height : 'a1 tree -> Z_as_Int.t

        val cardinal : 'a1 tree -> nat

        val empty : 'a1 tree

        val is_empty : 'a1 tree -> bool

        val mem : T_as_UCT.t -> 'a1 tree -> bool

        val find : T_as_UCT.t -> 'a1 tree -> 'a1 option

        val create : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

        val assert_false : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

        val bal : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

        val add : key -> 'a1 -> 'a1 tree -> 'a1 tree

        val remove_min :
          'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree * (key * 'a1)

        val merge : 'a1 tree -> 'a1 tree -> 'a1 tree

        val remove : T_as_UCT.t -> 'a1 tree -> 'a1 tree

        val join : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

        type 'elt triple = { t_left : 'elt tree; t_opt : 'elt option;
                             t_right : 'elt tree }

        val t_left : 'a1 triple -> 'a1 tree

        val t_opt : 'a1 triple -> 'a1 option

        val t_right : 'a1 triple -> 'a1 tree

        val split : T_as_UCT.t -> 'a1 tree -> 'a1 triple

        val concat : 'a1 tree -> 'a1 tree -> 'a1 tree

        val elements_aux : (key * 'a1) list -> 'a1 tree -> (key * 'a1) list

        val elements : 'a1 tree -> (key * 'a1) list

        val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

        type 'elt enumeration =
        | End
        | More of key * 'elt * 'elt tree * 'elt enumeration

        val enumeration_rect :
          'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 -> 'a2) ->
          'a1 enumeration -> 'a2

        val enumeration_rec :
          'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 -> 'a2) ->
          'a1 enumeration -> 'a2

        val cons : 'a1 tree -> 'a1 enumeration -> 'a1 enumeration

        val equal_more :
          ('a1 -> 'a1 -> bool) -> T_as_UCT.t -> 'a1 -> ('a1 enumeration ->
          bool) -> 'a1 enumeration -> bool

        val equal_cont :
          ('a1 -> 'a1 -> bool) -> 'a1 tree -> ('a1 enumeration -> bool) ->
          'a1 enumeration -> bool

        val equal_end : 'a1 enumeration -> bool

        val equal : ('a1 -> 'a1 -> bool) -> 'a1 tree -> 'a1 tree -> bool

        val map : ('a1 -> 'a2) -> 'a1 tree -> 'a2 tree

        val mapi : (key -> 'a1 -> 'a2) -> 'a1 tree -> 'a2 tree

        val map_option : (key -> 'a1 -> 'a2 option) -> 'a1 tree -> 'a2 tree

        val map2_opt :
          (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3 tree)
          -> ('a2 tree -> 'a3 tree) -> 'a1 tree -> 'a2 tree -> 'a3 tree

        val map2 :
          ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 tree -> 'a2 tree ->
          'a3 tree

        module Proofs :
         sig
          module MX :
           sig
            module TO :
             sig
              type t = T_as_UCT.t
             end

            module IsTO :
             sig
             end

            module OrderTac :
             sig
             end

            val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

            val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

            val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
           end

          module PX :
           sig
            module MO :
             sig
              module TO :
               sig
                type t = T_as_UCT.t
               end

              module IsTO :
               sig
               end

              module OrderTac :
               sig
               end

              val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

              val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

              val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
             end
           end

          module L :
           sig
            module MX :
             sig
              module TO :
               sig
                type t = T_as_UCT.t
               end

              module IsTO :
               sig
               end

              module OrderTac :
               sig
               end

              val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

              val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

              val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
             end

            module PX :
             sig
              module MO :
               sig
                module TO :
                 sig
                  type t = T_as_UCT.t
                 end

                module IsTO :
                 sig
                 end

                module OrderTac :
                 sig
                 end

                val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
               end
             end

            type key = T_as_UCT.t

            type 'elt t = (T_as_UCT.t * 'elt) list

            val empty : 'a1 t

            val is_empty : 'a1 t -> bool

            val mem : key -> 'a1 t -> bool

            type 'elt coq_R_mem =
            | R_mem_0 of 'elt t
            | R_mem_1 of 'elt t * T_as_UCT.t * 'elt * (T_as_UCT.t * 'elt) list
            | R_mem_2 of 'elt t * T_as_UCT.t * 'elt * (T_as_UCT.t * 'elt) list
            | R_mem_3 of 'elt t * T_as_UCT.t * 'elt
               * (T_as_UCT.t * 'elt) list * bool * 'elt coq_R_mem

            val coq_R_mem_rect :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
              T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __
              -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1)
              list -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2)
              -> 'a1 t -> bool -> 'a1 coq_R_mem -> 'a2

            val coq_R_mem_rec :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
              T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __
              -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1)
              list -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2)
              -> 'a1 t -> bool -> 'a1 coq_R_mem -> 'a2

            val mem_rect :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
              T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __
              -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1)
              list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

            val mem_rec :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
              T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __
              -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1)
              list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

            val coq_R_mem_correct : key -> 'a1 t -> bool -> 'a1 coq_R_mem

            val find : key -> 'a1 t -> 'a1 option

            type 'elt coq_R_find =
            | R_find_0 of 'elt t
            | R_find_1 of 'elt t * T_as_UCT.t * 'elt
               * (T_as_UCT.t * 'elt) list
            | R_find_2 of 'elt t * T_as_UCT.t * 'elt
               * (T_as_UCT.t * 'elt) list
            | R_find_3 of 'elt t * T_as_UCT.t * 'elt
               * (T_as_UCT.t * 'elt) list * 'elt option * 'elt coq_R_find

            val coq_R_find_rect :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
              T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __
              -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1)
              list -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2
              -> 'a2) -> 'a1 t -> 'a1 option -> 'a1 coq_R_find -> 'a2

            val coq_R_find_rec :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
              T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __
              -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1)
              list -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2
              -> 'a2) -> 'a1 t -> 'a1 option -> 'a1 coq_R_find -> 'a2

            val find_rect :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
              T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __
              -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1)
              list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

            val find_rec :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
              T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __
              -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1)
              list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

            val coq_R_find_correct :
              key -> 'a1 t -> 'a1 option -> 'a1 coq_R_find

            val add : key -> 'a1 -> 'a1 t -> 'a1 t

            type 'elt coq_R_add =
            | R_add_0 of 'elt t
            | R_add_1 of 'elt t * T_as_UCT.t * 'elt * (T_as_UCT.t * 'elt) list
            | R_add_2 of 'elt t * T_as_UCT.t * 'elt * (T_as_UCT.t * 'elt) list
            | R_add_3 of 'elt t * T_as_UCT.t * 'elt
               * (T_as_UCT.t * 'elt) list * 'elt t * 'elt coq_R_add

            val coq_R_add_rect :
              key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
              'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
              __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1 t -> 'a1
              coq_R_add -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_add ->
              'a2

            val coq_R_add_rec :
              key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
              'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
              __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1 t -> 'a1
              coq_R_add -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_add ->
              'a2

            val add_rect :
              key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
              'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
              __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1
              t -> 'a2

            val add_rec :
              key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
              'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
              __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1
              t -> 'a2

            val coq_R_add_correct :
              key -> 'a1 -> 'a1 t -> 'a1 t -> 'a1 coq_R_add

            val remove : key -> 'a1 t -> 'a1 t

            type 'elt coq_R_remove =
            | R_remove_0 of 'elt t
            | R_remove_1 of 'elt t * T_as_UCT.t * 'elt
               * (T_as_UCT.t * 'elt) list
            | R_remove_2 of 'elt t * T_as_UCT.t * 'elt
               * (T_as_UCT.t * 'elt) list
            | R_remove_3 of 'elt t * T_as_UCT.t * 'elt
               * (T_as_UCT.t * 'elt) list * 'elt t * 'elt coq_R_remove

            val coq_R_remove_rect :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
              T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __
              -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1)
              list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_remove -> 'a2 ->
              'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove -> 'a2

            val coq_R_remove_rec :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
              T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __
              -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1)
              list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_remove -> 'a2 ->
              'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove -> 'a2

            val remove_rect :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
              T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __
              -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1)
              list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

            val remove_rec :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
              T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __
              -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1)
              list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

            val coq_R_remove_correct :
              key -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove

            val elements : 'a1 t -> 'a1 t

            val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

            type ('elt, 'a) coq_R_fold =
            | R_fold_0 of 'elt t * 'a
            | R_fold_1 of 'elt t * 'a * T_as_UCT.t * 'elt
               * (T_as_UCT.t * 'elt) list * 'a * ('elt, 'a) coq_R_fold

            val coq_R_fold_rect :
              (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) ->
              ('a1 t -> 'a2 -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
              -> __ -> 'a2 -> ('a1, 'a2) coq_R_fold -> 'a3 -> 'a3) -> 'a1 t
              -> 'a2 -> 'a2 -> ('a1, 'a2) coq_R_fold -> 'a3

            val coq_R_fold_rec :
              (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) ->
              ('a1 t -> 'a2 -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
              -> __ -> 'a2 -> ('a1, 'a2) coq_R_fold -> 'a3 -> 'a3) -> 'a1 t
              -> 'a2 -> 'a2 -> ('a1, 'a2) coq_R_fold -> 'a3

            val fold_rect :
              (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) ->
              ('a1 t -> 'a2 -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
              -> __ -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a3

            val fold_rec :
              (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) ->
              ('a1 t -> 'a2 -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
              -> __ -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a3

            val coq_R_fold_correct :
              (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2 -> ('a1, 'a2)
              coq_R_fold

            val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool

            type 'elt coq_R_equal =
            | R_equal_0 of 'elt t * 'elt t
            | R_equal_1 of 'elt t * 'elt t * T_as_UCT.t * 'elt
               * (T_as_UCT.t * 'elt) list * T_as_UCT.t * 'elt
               * (T_as_UCT.t * 'elt) list * bool * 'elt coq_R_equal
            | R_equal_2 of 'elt t * 'elt t * T_as_UCT.t * 'elt
               * (T_as_UCT.t * 'elt) list * T_as_UCT.t * 'elt
               * (T_as_UCT.t * 'elt) list * T_as_UCT.t compare0
            | R_equal_3 of 'elt t * 'elt t * 'elt t * 'elt t

            val coq_R_equal_rect :
              ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) ->
              ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
              -> __ -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
              __ -> __ -> bool -> 'a1 coq_R_equal -> 'a2 -> 'a2) -> ('a1 t ->
              'a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
              T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
              T_as_UCT.t compare0 -> __ -> __ -> 'a2) -> ('a1 t -> 'a1 t ->
              'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2) -> 'a1 t -> 'a1 t ->
              bool -> 'a1 coq_R_equal -> 'a2

            val coq_R_equal_rec :
              ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) ->
              ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
              -> __ -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
              __ -> __ -> bool -> 'a1 coq_R_equal -> 'a2 -> 'a2) -> ('a1 t ->
              'a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
              T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
              T_as_UCT.t compare0 -> __ -> __ -> 'a2) -> ('a1 t -> 'a1 t ->
              'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2) -> 'a1 t -> 'a1 t ->
              bool -> 'a1 coq_R_equal -> 'a2

            val equal_rect :
              ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) ->
              ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
              -> __ -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
              __ -> __ -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1
              -> (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t compare0 -> __ ->
              __ -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ ->
              __ -> 'a2) -> 'a1 t -> 'a1 t -> 'a2

            val equal_rec :
              ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) ->
              ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
              -> __ -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
              __ -> __ -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1
              -> (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t compare0 -> __ ->
              __ -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ ->
              __ -> 'a2) -> 'a1 t -> 'a1 t -> 'a2

            val coq_R_equal_correct :
              ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool -> 'a1
              coq_R_equal

            val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

            val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

            val option_cons :
              key -> 'a1 option -> (key * 'a1) list -> (key * 'a1) list

            val map2_l :
              ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a3 t

            val map2_r :
              ('a1 option -> 'a2 option -> 'a3 option) -> 'a2 t -> 'a3 t

            val map2 :
              ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t ->
              'a3 t

            val combine : 'a1 t -> 'a2 t -> ('a1 option * 'a2 option) t

            val fold_right_pair :
              ('a1 -> 'a2 -> 'a3 -> 'a3) -> ('a1 * 'a2) list -> 'a3 -> 'a3

            val map2_alt :
              ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t ->
              (key * 'a3) list

            val at_least_one :
              'a1 option -> 'a2 option -> ('a1 option * 'a2 option) option

            val at_least_one_then_f :
              ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 option -> 'a2
              option -> 'a3 option
           end

          type 'elt coq_R_mem =
          | R_mem_0 of 'elt tree
          | R_mem_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * bool * 'elt coq_R_mem
          | R_mem_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t
          | R_mem_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * bool * 'elt coq_R_mem

          val coq_R_mem_rect :
            T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> bool ->
            'a1 coq_R_mem -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree -> key ->
            'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1
            tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
            __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 tree ->
            bool -> 'a1 coq_R_mem -> 'a2

          val coq_R_mem_rec :
            T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> bool ->
            'a1 coq_R_mem -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree -> key ->
            'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1
            tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
            __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 tree ->
            bool -> 'a1 coq_R_mem -> 'a2

          type 'elt coq_R_find =
          | R_find_0 of 'elt tree
          | R_find_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt option * 'elt coq_R_find
          | R_find_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t
          | R_find_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt option * 'elt coq_R_find

          val coq_R_find_rect :
            T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
            option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree
            -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2)
            -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
            -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2)
            -> 'a1 tree -> 'a1 option -> 'a1 coq_R_find -> 'a2

          val coq_R_find_rec :
            T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
            option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree
            -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2)
            -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
            -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2)
            -> 'a1 tree -> 'a1 option -> 'a1 coq_R_find -> 'a2

          type 'elt coq_R_bal =
          | R_bal_0 of 'elt tree * key * 'elt * 'elt tree
          | R_bal_1 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
             key * 'elt * 'elt tree * Z_as_Int.t
          | R_bal_2 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
             key * 'elt * 'elt tree * Z_as_Int.t
          | R_bal_3 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
             key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 
             'elt * 'elt tree * Z_as_Int.t
          | R_bal_4 of 'elt tree * key * 'elt * 'elt tree
          | R_bal_5 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
             key * 'elt * 'elt tree * Z_as_Int.t
          | R_bal_6 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
             key * 'elt * 'elt tree * Z_as_Int.t
          | R_bal_7 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
             key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 
             'elt * 'elt tree * Z_as_Int.t
          | R_bal_8 of 'elt tree * key * 'elt * 'elt tree

          val coq_R_bal_rect :
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> 'a2) ->
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) ->
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> __ ->
            'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2) ->
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> __
            -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __
            -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
            -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __
            -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key ->
            'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1
            -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> key ->
            'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2) -> ('a1 tree -> key
            -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a2) -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_bal -> 'a2

          val coq_R_bal_rec :
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> 'a2) ->
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) ->
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> __ ->
            'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2) ->
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> __
            -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __
            -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
            -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __
            -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key ->
            'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1
            -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> key ->
            'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2) -> ('a1 tree -> key
            -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a2) -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_bal -> 'a2

          type 'elt coq_R_add =
          | R_add_0 of 'elt tree
          | R_add_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt tree * 'elt coq_R_add
          | R_add_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t
          | R_add_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt tree * 'elt coq_R_add

          val coq_R_add_rect :
            key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
            tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) ->
            ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
            __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1
            tree -> 'a1 tree -> 'a1 coq_R_add -> 'a2

          val coq_R_add_rec :
            key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
            tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) ->
            ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
            __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1
            tree -> 'a1 tree -> 'a1 coq_R_add -> 'a2

          type 'elt coq_R_remove_min =
          | R_remove_min_0 of 'elt tree * key * 'elt * 'elt tree
          | R_remove_min_1 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
             * key * 'elt * 'elt tree * Z_as_Int.t
             * ('elt tree * (key * 'elt)) * 'elt coq_R_remove_min * 'elt tree
             * (key * 'elt)

          val coq_R_remove_min_rect :
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1 tree ->
            key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> ('a1 tree * (key * 'a1)) -> 'a1
            coq_R_remove_min -> 'a2 -> 'a1 tree -> (key * 'a1) -> __ -> 'a2)
            -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> ('a1 tree * (key * 'a1))
            -> 'a1 coq_R_remove_min -> 'a2

          val coq_R_remove_min_rec :
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1 tree ->
            key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> ('a1 tree * (key * 'a1)) -> 'a1
            coq_R_remove_min -> 'a2 -> 'a1 tree -> (key * 'a1) -> __ -> 'a2)
            -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> ('a1 tree * (key * 'a1))
            -> 'a1 coq_R_remove_min -> 'a2

          type 'elt coq_R_merge =
          | R_merge_0 of 'elt tree * 'elt tree
          | R_merge_1 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
             * 'elt tree * Z_as_Int.t
          | R_merge_2 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
             * 'elt tree * Z_as_Int.t * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt tree * (key * 'elt) * key * 'elt

          val coq_R_merge_rect :
            ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
            'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
            tree -> Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> key -> 'a1
            -> __ -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 tree -> 'a1
            coq_R_merge -> 'a2

          val coq_R_merge_rec :
            ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
            'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
            tree -> Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> key -> 'a1
            -> __ -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 tree -> 'a1
            coq_R_merge -> 'a2

          type 'elt coq_R_remove =
          | R_remove_0 of 'elt tree
          | R_remove_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt tree * 'elt coq_R_remove
          | R_remove_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t
          | R_remove_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt tree * 'elt coq_R_remove

          val coq_R_remove_rect :
            T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
            tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree
            -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2)
            -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
            -> __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2)
            -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_remove -> 'a2

          val coq_R_remove_rec :
            T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
            tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree
            -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2)
            -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
            -> __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2)
            -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_remove -> 'a2

          type 'elt coq_R_concat =
          | R_concat_0 of 'elt tree * 'elt tree
          | R_concat_1 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
             * 'elt tree * Z_as_Int.t
          | R_concat_2 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
             * 'elt tree * Z_as_Int.t * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt tree * (key * 'elt)

          val coq_R_concat_rect :
            ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
            'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
            tree -> Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> 'a2) -> 'a1
            tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_concat -> 'a2

          val coq_R_concat_rec :
            ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
            'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
            tree -> Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> 'a2) -> 'a1
            tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_concat -> 'a2

          type 'elt coq_R_split =
          | R_split_0 of 'elt tree
          | R_split_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt triple * 'elt coq_R_split * 'elt tree
             * 'elt option * 'elt tree
          | R_split_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t
          | R_split_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt triple * 'elt coq_R_split * 'elt tree
             * 'elt option * 'elt tree

          val coq_R_split_rect :
            T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
            triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option -> 'a1
            tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
            tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option ->
            'a1 tree -> __ -> 'a2) -> 'a1 tree -> 'a1 triple -> 'a1
            coq_R_split -> 'a2

          val coq_R_split_rec :
            T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
            triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option -> 'a1
            tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
            tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option ->
            'a1 tree -> __ -> 'a2) -> 'a1 tree -> 'a1 triple -> 'a1
            coq_R_split -> 'a2

          type ('elt, 'x) coq_R_map_option =
          | R_map_option_0 of 'elt tree
          | R_map_option_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'x * 'x tree * ('elt, 'x) coq_R_map_option
             * 'x tree * ('elt, 'x) coq_R_map_option
          | R_map_option_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'x tree * ('elt, 'x) coq_R_map_option * 'x tree
             * ('elt, 'x) coq_R_map_option

          val coq_R_map_option_rect :
            (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) -> ('a1
            tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
            'a2 -> __ -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 ->
            'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> ('a1
            tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
            __ -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2 tree
            -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> 'a1 tree -> 'a2
            tree -> ('a1, 'a2) coq_R_map_option -> 'a3

          val coq_R_map_option_rec :
            (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) -> ('a1
            tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
            'a2 -> __ -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 ->
            'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> ('a1
            tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
            __ -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2 tree
            -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> 'a1 tree -> 'a2
            tree -> ('a1, 'a2) coq_R_map_option -> 'a3

          type ('elt, 'x0, 'x) coq_R_map2_opt =
          | R_map2_opt_0 of 'elt tree * 'x0 tree
          | R_map2_opt_1 of 'elt tree * 'x0 tree * 'elt tree * key * 
             'elt * 'elt tree * Z_as_Int.t
          | R_map2_opt_2 of 'elt tree * 'x0 tree * 'elt tree * key * 
             'elt * 'elt tree * Z_as_Int.t * 'x0 tree * key * 'x0 * 'x0 tree
             * Z_as_Int.t * 'x0 tree * 'x0 option * 'x0 tree * 'x * 'x tree
             * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
             * ('elt, 'x0, 'x) coq_R_map2_opt
          | R_map2_opt_3 of 'elt tree * 'x0 tree * 'elt tree * key * 
             'elt * 'elt tree * Z_as_Int.t * 'x0 tree * key * 'x0 * 'x0 tree
             * Z_as_Int.t * 'x0 tree * 'x0 option * 'x0 tree * 'x tree
             * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
             * ('elt, 'x0, 'x) coq_R_map2_opt

          val coq_R_map2_opt_rect :
            (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3
            tree) -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2 tree -> __ ->
            'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1
            tree -> Z_as_Int.t -> __ -> __ -> 'a4) -> ('a1 tree -> 'a2 tree
            -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2
            tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ -> 'a2 tree ->
            'a2 option -> 'a2 tree -> __ -> 'a3 -> __ -> 'a3 tree -> ('a1,
            'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
            coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 tree ->
            key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2
            option -> 'a2 tree -> __ -> __ -> 'a3 tree -> ('a1, 'a2, 'a3)
            coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
            coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1 tree -> 'a2 tree -> 'a3 tree
            -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4

          val coq_R_map2_opt_rec :
            (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3
            tree) -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2 tree -> __ ->
            'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1
            tree -> Z_as_Int.t -> __ -> __ -> 'a4) -> ('a1 tree -> 'a2 tree
            -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2
            tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ -> 'a2 tree ->
            'a2 option -> 'a2 tree -> __ -> 'a3 -> __ -> 'a3 tree -> ('a1,
            'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
            coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 tree ->
            key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2
            option -> 'a2 tree -> __ -> __ -> 'a3 tree -> ('a1, 'a2, 'a3)
            coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
            coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1 tree -> 'a2 tree -> 'a3 tree
            -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4

          val fold' : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

          val flatten_e : 'a1 enumeration -> (key * 'a1) list
         end
       end

      type 'elt bst =
        'elt Raw.tree
        (* singleton inductive, whose constructor was Bst *)

      val this : 'a1 bst -> 'a1 Raw.tree

      type 'elt t = 'elt bst

      type key = T_as_UCT.t

      val empty : 'a1 t

      val is_empty : 'a1 t -> bool

      val add : key -> 'a1 -> 'a1 t -> 'a1 t

      val remove : key -> 'a1 t -> 'a1 t

      val mem : key -> 'a1 t -> bool

      val find : key -> 'a1 t -> 'a1 option

      val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

      val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

      val map2 :
        ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t -> 'a3 t

      val elements : 'a1 t -> (key * 'a1) list

      val cardinal : 'a1 t -> nat

      val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

      val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool
     end

    module SigFMF :
     sig
      val eqb : T_as_UCT.t -> T_as_UCT.t -> bool

      val coq_In_dec : 'a1 SigFM.t -> SigFM.key -> bool
     end

    module Strings :
     sig
      type coq_String = Ty.coq_Sigma list

      val coq_String_dec : coq_String -> coq_String -> bool

      val rm_empty : coq_String list -> Ty.coq_Sigma list list
     end

    module Regexes :
     sig
      type regex =
      | EmptySet
      | EmptyStr
      | Char of Ty.coq_Sigma
      | App of regex * regex
      | Union of regex * regex
      | Star of regex

      val regex_rect :
        'a1 -> 'a1 -> (Ty.coq_Sigma -> 'a1) -> (regex -> 'a1 -> regex -> 'a1
        -> 'a1) -> (regex -> 'a1 -> regex -> 'a1 -> 'a1) -> (regex -> 'a1 ->
        'a1) -> regex -> 'a1

      val regex_rec :
        'a1 -> 'a1 -> (Ty.coq_Sigma -> 'a1) -> (regex -> 'a1 -> regex -> 'a1
        -> 'a1) -> (regex -> 'a1 -> regex -> 'a1 -> 'a1) -> (regex -> 'a1 ->
        'a1) -> regex -> 'a1

      val regex_dec : regex -> regex -> bool

      val regex_eq : regex -> regex -> bool

      val nullable' : regex -> bool

      val nullable : regex -> bool

      val derivative : Ty.coq_Sigma -> regex -> regex

      val derivative_list : Ty.coq_Sigma list -> regex -> regex

      val re_compare : regex -> regex -> comparison
     end

    module Coq_regex_as_UCT :
     sig
      type t = Regexes.regex

      val compare : Regexes.regex -> Regexes.regex -> comparison
     end

    module Coq_regex_as_UOT :
     sig
      type t = Coq_regex_as_UCT.t

      val compare : t -> t -> t compare0

      val eq_dec : t -> t -> bool
     end

    module Coq_reFS :
     sig
      module X' :
       sig
        type t = Coq_regex_as_UCT.t

        val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

        val compare : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> comparison
       end

      module MSet :
       sig
        module Raw :
         sig
          type elt = Coq_regex_as_UCT.t

          type tree =
          | Leaf
          | Node of Z_as_Int.t * tree * Coq_regex_as_UCT.t * tree

          val empty : tree

          val is_empty : tree -> bool

          val mem : Coq_regex_as_UCT.t -> tree -> bool

          val min_elt : tree -> elt option

          val max_elt : tree -> elt option

          val choose : tree -> elt option

          val fold : (elt -> 'a1 -> 'a1) -> tree -> 'a1 -> 'a1

          val elements_aux :
            Coq_regex_as_UCT.t list -> tree -> Coq_regex_as_UCT.t list

          val elements : tree -> Coq_regex_as_UCT.t list

          val rev_elements_aux :
            Coq_regex_as_UCT.t list -> tree -> Coq_regex_as_UCT.t list

          val rev_elements : tree -> Coq_regex_as_UCT.t list

          val cardinal : tree -> nat

          val maxdepth : tree -> nat

          val mindepth : tree -> nat

          val for_all : (elt -> bool) -> tree -> bool

          val exists_ : (elt -> bool) -> tree -> bool

          type enumeration =
          | End
          | More of elt * tree * enumeration

          val cons : tree -> enumeration -> enumeration

          val compare_more :
            Coq_regex_as_UCT.t -> (enumeration -> comparison) -> enumeration
            -> comparison

          val compare_cont :
            tree -> (enumeration -> comparison) -> enumeration -> comparison

          val compare_end : enumeration -> comparison

          val compare : tree -> tree -> comparison

          val equal : tree -> tree -> bool

          val subsetl : (tree -> bool) -> Coq_regex_as_UCT.t -> tree -> bool

          val subsetr : (tree -> bool) -> Coq_regex_as_UCT.t -> tree -> bool

          val subset : tree -> tree -> bool

          type t = tree

          val height : t -> Z_as_Int.t

          val singleton : Coq_regex_as_UCT.t -> tree

          val create : t -> Coq_regex_as_UCT.t -> t -> tree

          val assert_false : t -> Coq_regex_as_UCT.t -> t -> tree

          val bal : t -> Coq_regex_as_UCT.t -> t -> tree

          val add : Coq_regex_as_UCT.t -> tree -> tree

          val join : tree -> elt -> t -> t

          val remove_min : tree -> elt -> t -> t * elt

          val merge : tree -> tree -> tree

          val remove : Coq_regex_as_UCT.t -> tree -> tree

          val concat : tree -> tree -> tree

          type triple = { t_left : t; t_in : bool; t_right : t }

          val t_left : triple -> t

          val t_in : triple -> bool

          val t_right : triple -> t

          val split : Coq_regex_as_UCT.t -> tree -> triple

          val inter : tree -> tree -> tree

          val diff : tree -> tree -> tree

          val union : tree -> tree -> tree

          val filter : (elt -> bool) -> tree -> tree

          val partition : (elt -> bool) -> t -> t * t

          val ltb_tree : Coq_regex_as_UCT.t -> tree -> bool

          val gtb_tree : Coq_regex_as_UCT.t -> tree -> bool

          val isok : tree -> bool

          module MX :
           sig
            module OrderTac :
             sig
              module OTF :
               sig
                type t = Coq_regex_as_UCT.t

                val compare :
                  Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> comparison

                val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
               end

              module TO :
               sig
                type t = Coq_regex_as_UCT.t

                val compare :
                  Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> comparison

                val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
               end
             end

            val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

            val lt_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

            val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
           end

          type coq_R_min_elt =
          | R_min_elt_0 of tree
          | R_min_elt_1 of tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
             * tree
          | R_min_elt_2 of tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
             * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t * tree
             * elt option * coq_R_min_elt

          type coq_R_max_elt =
          | R_max_elt_0 of tree
          | R_max_elt_1 of tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
             * tree
          | R_max_elt_2 of tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
             * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t * tree
             * elt option * coq_R_max_elt

          module L :
           sig
            module MO :
             sig
              module OrderTac :
               sig
                module OTF :
                 sig
                  type t = Coq_regex_as_UCT.t

                  val compare :
                    Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> comparison

                  val eq_dec :
                    Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                 end

                module TO :
                 sig
                  type t = Coq_regex_as_UCT.t

                  val compare :
                    Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> comparison

                  val eq_dec :
                    Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                 end
               end

              val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

              val lt_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

              val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
             end
           end

          val flatten_e : enumeration -> elt list

          type coq_R_bal =
          | R_bal_0 of t * Coq_regex_as_UCT.t * t
          | R_bal_1 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * tree
             * Coq_regex_as_UCT.t * tree
          | R_bal_2 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * tree
             * Coq_regex_as_UCT.t * tree
          | R_bal_3 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * tree
             * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
             * Coq_regex_as_UCT.t * tree
          | R_bal_4 of t * Coq_regex_as_UCT.t * t
          | R_bal_5 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * tree
             * Coq_regex_as_UCT.t * tree
          | R_bal_6 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * tree
             * Coq_regex_as_UCT.t * tree
          | R_bal_7 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * tree
             * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
             * Coq_regex_as_UCT.t * tree
          | R_bal_8 of t * Coq_regex_as_UCT.t * t

          type coq_R_remove_min =
          | R_remove_min_0 of tree * elt * t
          | R_remove_min_1 of tree * elt * t * Z_as_Int.t * tree
             * Coq_regex_as_UCT.t * tree * (t * elt) * coq_R_remove_min * 
             t * elt

          type coq_R_merge =
          | R_merge_0 of tree * tree
          | R_merge_1 of tree * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
             * tree
          | R_merge_2 of tree * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
             * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t * tree * 
             t * elt

          type coq_R_concat =
          | R_concat_0 of tree * tree
          | R_concat_1 of tree * tree * Z_as_Int.t * tree
             * Coq_regex_as_UCT.t * tree
          | R_concat_2 of tree * tree * Z_as_Int.t * tree
             * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
             * Coq_regex_as_UCT.t * tree * t * elt

          type coq_R_inter =
          | R_inter_0 of tree * tree
          | R_inter_1 of tree * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
             * tree
          | R_inter_2 of tree * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
             * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t * tree * 
             t * bool * t * tree * coq_R_inter * tree * coq_R_inter
          | R_inter_3 of tree * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
             * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t * tree * 
             t * bool * t * tree * coq_R_inter * tree * coq_R_inter

          type coq_R_diff =
          | R_diff_0 of tree * tree
          | R_diff_1 of tree * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
             * tree
          | R_diff_2 of tree * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
             * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t * tree * 
             t * bool * t * tree * coq_R_diff * tree * coq_R_diff
          | R_diff_3 of tree * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
             * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t * tree * 
             t * bool * t * tree * coq_R_diff * tree * coq_R_diff

          type coq_R_union =
          | R_union_0 of tree * tree
          | R_union_1 of tree * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
             * tree
          | R_union_2 of tree * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
             * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t * tree * 
             t * bool * t * tree * coq_R_union * tree * coq_R_union
         end

        module E :
         sig
          type t = Coq_regex_as_UCT.t

          val compare : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> comparison

          val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
         end

        type elt = Coq_regex_as_UCT.t

        type t_ = Raw.t
          (* singleton inductive, whose constructor was Mkt *)

        val this : t_ -> Raw.t

        type t = t_

        val mem : elt -> t -> bool

        val add : elt -> t -> t

        val remove : elt -> t -> t

        val singleton : elt -> t

        val union : t -> t -> t

        val inter : t -> t -> t

        val diff : t -> t -> t

        val equal : t -> t -> bool

        val subset : t -> t -> bool

        val empty : t

        val is_empty : t -> bool

        val elements : t -> elt list

        val choose : t -> elt option

        val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

        val cardinal : t -> nat

        val filter : (elt -> bool) -> t -> t

        val for_all : (elt -> bool) -> t -> bool

        val exists_ : (elt -> bool) -> t -> bool

        val partition : (elt -> bool) -> t -> t * t

        val eq_dec : t -> t -> bool

        val compare : t -> t -> comparison

        val min_elt : t -> elt option

        val max_elt : t -> elt option
       end

      type elt = Coq_regex_as_UCT.t

      type t = MSet.t

      val empty : t

      val is_empty : t -> bool

      val mem : elt -> t -> bool

      val add : elt -> t -> t

      val singleton : elt -> t

      val remove : elt -> t -> t

      val union : t -> t -> t

      val inter : t -> t -> t

      val diff : t -> t -> t

      val eq_dec : t -> t -> bool

      val equal : t -> t -> bool

      val subset : t -> t -> bool

      val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

      val for_all : (elt -> bool) -> t -> bool

      val exists_ : (elt -> bool) -> t -> bool

      val filter : (elt -> bool) -> t -> t

      val partition : (elt -> bool) -> t -> t * t

      val cardinal : t -> nat

      val elements : t -> elt list

      val choose : t -> elt option

      module MF :
       sig
        val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
       end

      val min_elt : t -> elt option

      val max_elt : t -> elt option

      val compare : t -> t -> t compare0

      module E :
       sig
        type t = Coq_regex_as_UCT.t

        val compare :
          Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t
          compare0

        val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
       end
     end

    module Coq_reFSF :
     sig
      val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
     end

    module Coq_reFM :
     sig
      module E :
       sig
        type t = Coq_regex_as_UCT.t

        val compare :
          Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t
          compare0

        val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
       end

      module Raw :
       sig
        type key = Coq_regex_as_UCT.t

        type 'elt tree =
        | Leaf
        | Node of 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t

        val tree_rect :
          'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
          Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

        val tree_rec :
          'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
          Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

        val height : 'a1 tree -> Z_as_Int.t

        val cardinal : 'a1 tree -> nat

        val empty : 'a1 tree

        val is_empty : 'a1 tree -> bool

        val mem : Coq_regex_as_UCT.t -> 'a1 tree -> bool

        val find : Coq_regex_as_UCT.t -> 'a1 tree -> 'a1 option

        val create : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

        val assert_false : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

        val bal : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

        val add : key -> 'a1 -> 'a1 tree -> 'a1 tree

        val remove_min :
          'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree * (key * 'a1)

        val merge : 'a1 tree -> 'a1 tree -> 'a1 tree

        val remove : Coq_regex_as_UCT.t -> 'a1 tree -> 'a1 tree

        val join : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

        type 'elt triple = { t_left : 'elt tree; t_opt : 'elt option;
                             t_right : 'elt tree }

        val t_left : 'a1 triple -> 'a1 tree

        val t_opt : 'a1 triple -> 'a1 option

        val t_right : 'a1 triple -> 'a1 tree

        val split : Coq_regex_as_UCT.t -> 'a1 tree -> 'a1 triple

        val concat : 'a1 tree -> 'a1 tree -> 'a1 tree

        val elements_aux : (key * 'a1) list -> 'a1 tree -> (key * 'a1) list

        val elements : 'a1 tree -> (key * 'a1) list

        val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

        type 'elt enumeration =
        | End
        | More of key * 'elt * 'elt tree * 'elt enumeration

        val enumeration_rect :
          'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 -> 'a2) ->
          'a1 enumeration -> 'a2

        val enumeration_rec :
          'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 -> 'a2) ->
          'a1 enumeration -> 'a2

        val cons : 'a1 tree -> 'a1 enumeration -> 'a1 enumeration

        val equal_more :
          ('a1 -> 'a1 -> bool) -> Coq_regex_as_UCT.t -> 'a1 -> ('a1
          enumeration -> bool) -> 'a1 enumeration -> bool

        val equal_cont :
          ('a1 -> 'a1 -> bool) -> 'a1 tree -> ('a1 enumeration -> bool) ->
          'a1 enumeration -> bool

        val equal_end : 'a1 enumeration -> bool

        val equal : ('a1 -> 'a1 -> bool) -> 'a1 tree -> 'a1 tree -> bool

        val map : ('a1 -> 'a2) -> 'a1 tree -> 'a2 tree

        val mapi : (key -> 'a1 -> 'a2) -> 'a1 tree -> 'a2 tree

        val map_option : (key -> 'a1 -> 'a2 option) -> 'a1 tree -> 'a2 tree

        val map2_opt :
          (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3 tree)
          -> ('a2 tree -> 'a3 tree) -> 'a1 tree -> 'a2 tree -> 'a3 tree

        val map2 :
          ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 tree -> 'a2 tree ->
          'a3 tree

        module Proofs :
         sig
          module MX :
           sig
            module TO :
             sig
              type t = Coq_regex_as_UCT.t
             end

            module IsTO :
             sig
             end

            module OrderTac :
             sig
             end

            val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

            val lt_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

            val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
           end

          module PX :
           sig
            module MO :
             sig
              module TO :
               sig
                type t = Coq_regex_as_UCT.t
               end

              module IsTO :
               sig
               end

              module OrderTac :
               sig
               end

              val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

              val lt_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

              val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
             end
           end

          module L :
           sig
            module MX :
             sig
              module TO :
               sig
                type t = Coq_regex_as_UCT.t
               end

              module IsTO :
               sig
               end

              module OrderTac :
               sig
               end

              val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

              val lt_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

              val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
             end

            module PX :
             sig
              module MO :
               sig
                module TO :
                 sig
                  type t = Coq_regex_as_UCT.t
                 end

                module IsTO :
                 sig
                 end

                module OrderTac :
                 sig
                 end

                val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                val lt_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
               end
             end

            type key = Coq_regex_as_UCT.t

            type 'elt t = (Coq_regex_as_UCT.t * 'elt) list

            val empty : 'a1 t

            val is_empty : 'a1 t -> bool

            val mem : key -> 'a1 t -> bool

            type 'elt coq_R_mem =
            | R_mem_0 of 'elt t
            | R_mem_1 of 'elt t * Coq_regex_as_UCT.t * 'elt
               * (Coq_regex_as_UCT.t * 'elt) list
            | R_mem_2 of 'elt t * Coq_regex_as_UCT.t * 'elt
               * (Coq_regex_as_UCT.t * 'elt) list
            | R_mem_3 of 'elt t * Coq_regex_as_UCT.t * 'elt
               * (Coq_regex_as_UCT.t * 'elt) list * bool * 'elt coq_R_mem

            val coq_R_mem_rect :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
              'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> bool ->
              'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 t -> bool -> 'a1 coq_R_mem
              -> 'a2

            val coq_R_mem_rec :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
              'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> bool ->
              'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 t -> bool -> 'a1 coq_R_mem
              -> 'a2

            val mem_rect :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
              'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
              'a2) -> 'a1 t -> 'a2

            val mem_rec :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
              'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
              'a2) -> 'a1 t -> 'a2

            val coq_R_mem_correct : key -> 'a1 t -> bool -> 'a1 coq_R_mem

            val find : key -> 'a1 t -> 'a1 option

            type 'elt coq_R_find =
            | R_find_0 of 'elt t
            | R_find_1 of 'elt t * Coq_regex_as_UCT.t * 'elt
               * (Coq_regex_as_UCT.t * 'elt) list
            | R_find_2 of 'elt t * Coq_regex_as_UCT.t * 'elt
               * (Coq_regex_as_UCT.t * 'elt) list
            | R_find_3 of 'elt t * Coq_regex_as_UCT.t * 'elt
               * (Coq_regex_as_UCT.t * 'elt) list * 'elt option
               * 'elt coq_R_find

            val coq_R_find_rect :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
              'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1 option
              -> 'a1 coq_R_find -> 'a2 -> 'a2) -> 'a1 t -> 'a1 option -> 'a1
              coq_R_find -> 'a2

            val coq_R_find_rec :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
              'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1 option
              -> 'a1 coq_R_find -> 'a2 -> 'a2) -> 'a1 t -> 'a1 option -> 'a1
              coq_R_find -> 'a2

            val find_rect :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
              'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
              'a2) -> 'a1 t -> 'a2

            val find_rec :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
              'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
              'a2) -> 'a1 t -> 'a2

            val coq_R_find_correct :
              key -> 'a1 t -> 'a1 option -> 'a1 coq_R_find

            val add : key -> 'a1 -> 'a1 t -> 'a1 t

            type 'elt coq_R_add =
            | R_add_0 of 'elt t
            | R_add_1 of 'elt t * Coq_regex_as_UCT.t * 'elt
               * (Coq_regex_as_UCT.t * 'elt) list
            | R_add_2 of 'elt t * Coq_regex_as_UCT.t * 'elt
               * (Coq_regex_as_UCT.t * 'elt) list
            | R_add_3 of 'elt t * Coq_regex_as_UCT.t * 'elt
               * (Coq_regex_as_UCT.t * 'elt) list * 'elt t * 'elt coq_R_add

            val coq_R_add_rect :
              key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
              Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list ->
              __ -> __ -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1
              -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1 t ->
              'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_add
              -> 'a2

            val coq_R_add_rec :
              key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
              Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list ->
              __ -> __ -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1
              -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1 t ->
              'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_add
              -> 'a2

            val add_rect :
              key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
              Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list ->
              __ -> __ -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1
              -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
              'a2) -> 'a1 t -> 'a2

            val add_rec :
              key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
              Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list ->
              __ -> __ -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1
              -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
              'a2) -> 'a1 t -> 'a2

            val coq_R_add_correct :
              key -> 'a1 -> 'a1 t -> 'a1 t -> 'a1 coq_R_add

            val remove : key -> 'a1 t -> 'a1 t

            type 'elt coq_R_remove =
            | R_remove_0 of 'elt t
            | R_remove_1 of 'elt t * Coq_regex_as_UCT.t * 'elt
               * (Coq_regex_as_UCT.t * 'elt) list
            | R_remove_2 of 'elt t * Coq_regex_as_UCT.t * 'elt
               * (Coq_regex_as_UCT.t * 'elt) list
            | R_remove_3 of 'elt t * Coq_regex_as_UCT.t * 'elt
               * (Coq_regex_as_UCT.t * 'elt) list * 'elt t * 'elt coq_R_remove

            val coq_R_remove_rect :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
              'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1 t ->
              'a1 coq_R_remove -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1
              coq_R_remove -> 'a2

            val coq_R_remove_rec :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
              'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1 t ->
              'a1 coq_R_remove -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1
              coq_R_remove -> 'a2

            val remove_rect :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
              'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
              'a2) -> 'a1 t -> 'a2

            val remove_rec :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
              'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
              'a2) -> 'a1 t -> 'a2

            val coq_R_remove_correct :
              key -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove

            val elements : 'a1 t -> 'a1 t

            val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

            type ('elt, 'a) coq_R_fold =
            | R_fold_0 of 'elt t * 'a
            | R_fold_1 of 'elt t * 'a * Coq_regex_as_UCT.t * 'elt
               * (Coq_regex_as_UCT.t * 'elt) list * 'a * ('elt, 'a) coq_R_fold

            val coq_R_fold_rect :
              (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) ->
              ('a1 t -> 'a2 -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> 'a2 -> ('a1, 'a2)
              coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a2 -> ('a1, 'a2)
              coq_R_fold -> 'a3

            val coq_R_fold_rec :
              (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) ->
              ('a1 t -> 'a2 -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> 'a2 -> ('a1, 'a2)
              coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a2 -> ('a1, 'a2)
              coq_R_fold -> 'a3

            val fold_rect :
              (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) ->
              ('a1 t -> 'a2 -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> 'a3 -> 'a3) -> 'a1 t
              -> 'a2 -> 'a3

            val fold_rec :
              (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) ->
              ('a1 t -> 'a2 -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> 'a3 -> 'a3) -> 'a1 t
              -> 'a2 -> 'a3

            val coq_R_fold_correct :
              (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2 -> ('a1, 'a2)
              coq_R_fold

            val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool

            type 'elt coq_R_equal =
            | R_equal_0 of 'elt t * 'elt t
            | R_equal_1 of 'elt t * 'elt t * Coq_regex_as_UCT.t * 'elt
               * (Coq_regex_as_UCT.t * 'elt) list * Coq_regex_as_UCT.t * 
               'elt * (Coq_regex_as_UCT.t * 'elt) list * bool
               * 'elt coq_R_equal
            | R_equal_2 of 'elt t * 'elt t * Coq_regex_as_UCT.t * 'elt
               * (Coq_regex_as_UCT.t * 'elt) list * Coq_regex_as_UCT.t * 
               'elt * (Coq_regex_as_UCT.t * 'elt) list
               * Coq_regex_as_UCT.t compare0
            | R_equal_3 of 'elt t * 'elt t * 'elt t * 'elt t

            val coq_R_equal_rect :
              ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) ->
              ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
              bool -> 'a1 coq_R_equal -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t ->
              Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list ->
              __ -> Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
              list -> __ -> Coq_regex_as_UCT.t compare0 -> __ -> __ -> 'a2)
              -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2)
              -> 'a1 t -> 'a1 t -> bool -> 'a1 coq_R_equal -> 'a2

            val coq_R_equal_rec :
              ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) ->
              ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
              bool -> 'a1 coq_R_equal -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t ->
              Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list ->
              __ -> Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
              list -> __ -> Coq_regex_as_UCT.t compare0 -> __ -> __ -> 'a2)
              -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2)
              -> 'a1 t -> 'a1 t -> bool -> 'a1 coq_R_equal -> 'a2

            val equal_rect :
              ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) ->
              ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2
              -> 'a2) -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ ->
              Coq_regex_as_UCT.t compare0 -> __ -> __ -> 'a2) -> ('a1 t ->
              'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2) -> 'a1 t ->
              'a1 t -> 'a2

            val equal_rec :
              ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) ->
              ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2
              -> 'a2) -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ ->
              Coq_regex_as_UCT.t compare0 -> __ -> __ -> 'a2) -> ('a1 t ->
              'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2) -> 'a1 t ->
              'a1 t -> 'a2

            val coq_R_equal_correct :
              ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool -> 'a1
              coq_R_equal

            val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

            val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

            val option_cons :
              key -> 'a1 option -> (key * 'a1) list -> (key * 'a1) list

            val map2_l :
              ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a3 t

            val map2_r :
              ('a1 option -> 'a2 option -> 'a3 option) -> 'a2 t -> 'a3 t

            val map2 :
              ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t ->
              'a3 t

            val combine : 'a1 t -> 'a2 t -> ('a1 option * 'a2 option) t

            val fold_right_pair :
              ('a1 -> 'a2 -> 'a3 -> 'a3) -> ('a1 * 'a2) list -> 'a3 -> 'a3

            val map2_alt :
              ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t ->
              (key * 'a3) list

            val at_least_one :
              'a1 option -> 'a2 option -> ('a1 option * 'a2 option) option

            val at_least_one_then_f :
              ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 option -> 'a2
              option -> 'a3 option
           end

          type 'elt coq_R_mem =
          | R_mem_0 of 'elt tree
          | R_mem_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * bool * 'elt coq_R_mem
          | R_mem_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t
          | R_mem_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * bool * 'elt coq_R_mem

          val coq_R_mem_rect :
            Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) ->
            ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
            __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1
            tree -> bool -> 'a1 coq_R_mem -> 'a2

          val coq_R_mem_rec :
            Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) ->
            ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
            __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1
            tree -> bool -> 'a1 coq_R_mem -> 'a2

          type 'elt coq_R_find =
          | R_find_0 of 'elt tree
          | R_find_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt option * 'elt coq_R_find
          | R_find_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t
          | R_find_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt option * 'elt coq_R_find

          val coq_R_find_rect :
            Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> ('a1 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find ->
            'a2 -> 'a2) -> 'a1 tree -> 'a1 option -> 'a1 coq_R_find -> 'a2

          val coq_R_find_rec :
            Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> ('a1 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find ->
            'a2 -> 'a2) -> 'a1 tree -> 'a1 option -> 'a1 coq_R_find -> 'a2

          type 'elt coq_R_bal =
          | R_bal_0 of 'elt tree * key * 'elt * 'elt tree
          | R_bal_1 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
             key * 'elt * 'elt tree * Z_as_Int.t
          | R_bal_2 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
             key * 'elt * 'elt tree * Z_as_Int.t
          | R_bal_3 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
             key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 
             'elt * 'elt tree * Z_as_Int.t
          | R_bal_4 of 'elt tree * key * 'elt * 'elt tree
          | R_bal_5 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
             key * 'elt * 'elt tree * Z_as_Int.t
          | R_bal_6 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
             key * 'elt * 'elt tree * Z_as_Int.t
          | R_bal_7 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
             key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 
             'elt * 'elt tree * Z_as_Int.t
          | R_bal_8 of 'elt tree * key * 'elt * 'elt tree

          val coq_R_bal_rect :
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> 'a2) ->
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) ->
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> __ ->
            'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2) ->
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> __
            -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __
            -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
            -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __
            -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key ->
            'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1
            -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> key ->
            'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2) -> ('a1 tree -> key
            -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a2) -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_bal -> 'a2

          val coq_R_bal_rec :
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> 'a2) ->
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) ->
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> __ ->
            'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2) ->
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> __
            -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __
            -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
            -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __
            -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key ->
            'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1
            -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> key ->
            'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2) -> ('a1 tree -> key
            -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a2) -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_bal -> 'a2

          type 'elt coq_R_add =
          | R_add_0 of 'elt tree
          | R_add_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt tree * 'elt coq_R_add
          | R_add_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t
          | R_add_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt tree * 'elt coq_R_add

          val coq_R_add_rect :
            key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
            tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) ->
            ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
            __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1
            tree -> 'a1 tree -> 'a1 coq_R_add -> 'a2

          val coq_R_add_rec :
            key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
            tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) ->
            ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
            __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1
            tree -> 'a1 tree -> 'a1 coq_R_add -> 'a2

          type 'elt coq_R_remove_min =
          | R_remove_min_0 of 'elt tree * key * 'elt * 'elt tree
          | R_remove_min_1 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
             * key * 'elt * 'elt tree * Z_as_Int.t
             * ('elt tree * (key * 'elt)) * 'elt coq_R_remove_min * 'elt tree
             * (key * 'elt)

          val coq_R_remove_min_rect :
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1 tree ->
            key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> ('a1 tree * (key * 'a1)) -> 'a1
            coq_R_remove_min -> 'a2 -> 'a1 tree -> (key * 'a1) -> __ -> 'a2)
            -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> ('a1 tree * (key * 'a1))
            -> 'a1 coq_R_remove_min -> 'a2

          val coq_R_remove_min_rec :
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1 tree ->
            key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> ('a1 tree * (key * 'a1)) -> 'a1
            coq_R_remove_min -> 'a2 -> 'a1 tree -> (key * 'a1) -> __ -> 'a2)
            -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> ('a1 tree * (key * 'a1))
            -> 'a1 coq_R_remove_min -> 'a2

          type 'elt coq_R_merge =
          | R_merge_0 of 'elt tree * 'elt tree
          | R_merge_1 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
             * 'elt tree * Z_as_Int.t
          | R_merge_2 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
             * 'elt tree * Z_as_Int.t * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt tree * (key * 'elt) * key * 'elt

          val coq_R_merge_rect :
            ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
            'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
            tree -> Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> key -> 'a1
            -> __ -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 tree -> 'a1
            coq_R_merge -> 'a2

          val coq_R_merge_rec :
            ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
            'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
            tree -> Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> key -> 'a1
            -> __ -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 tree -> 'a1
            coq_R_merge -> 'a2

          type 'elt coq_R_remove =
          | R_remove_0 of 'elt tree
          | R_remove_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt tree * 'elt coq_R_remove
          | R_remove_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t
          | R_remove_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt tree * 'elt coq_R_remove

          val coq_R_remove_rect :
            Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> ('a1 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove ->
            'a2 -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_remove -> 'a2

          val coq_R_remove_rec :
            Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> ('a1 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove ->
            'a2 -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_remove -> 'a2

          type 'elt coq_R_concat =
          | R_concat_0 of 'elt tree * 'elt tree
          | R_concat_1 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
             * 'elt tree * Z_as_Int.t
          | R_concat_2 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
             * 'elt tree * Z_as_Int.t * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt tree * (key * 'elt)

          val coq_R_concat_rect :
            ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
            'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
            tree -> Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> 'a2) -> 'a1
            tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_concat -> 'a2

          val coq_R_concat_rec :
            ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
            'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
            tree -> Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> 'a2) -> 'a1
            tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_concat -> 'a2

          type 'elt coq_R_split =
          | R_split_0 of 'elt tree
          | R_split_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt triple * 'elt coq_R_split * 'elt tree
             * 'elt option * 'elt tree
          | R_split_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t
          | R_split_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt triple * 'elt coq_R_split * 'elt tree
             * 'elt option * 'elt tree

          val coq_R_split_rect :
            Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option ->
            'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 ->
            'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree ->
            'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
            __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1
            option -> 'a1 tree -> __ -> 'a2) -> 'a1 tree -> 'a1 triple -> 'a1
            coq_R_split -> 'a2

          val coq_R_split_rec :
            Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option ->
            'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 ->
            'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree ->
            'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
            __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1
            option -> 'a1 tree -> __ -> 'a2) -> 'a1 tree -> 'a1 triple -> 'a1
            coq_R_split -> 'a2

          type ('elt, 'x) coq_R_map_option =
          | R_map_option_0 of 'elt tree
          | R_map_option_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'x * 'x tree * ('elt, 'x) coq_R_map_option
             * 'x tree * ('elt, 'x) coq_R_map_option
          | R_map_option_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'x tree * ('elt, 'x) coq_R_map_option * 'x tree
             * ('elt, 'x) coq_R_map_option

          val coq_R_map_option_rect :
            (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) -> ('a1
            tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
            'a2 -> __ -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 ->
            'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> ('a1
            tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
            __ -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2 tree
            -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> 'a1 tree -> 'a2
            tree -> ('a1, 'a2) coq_R_map_option -> 'a3

          val coq_R_map_option_rec :
            (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) -> ('a1
            tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
            'a2 -> __ -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 ->
            'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> ('a1
            tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
            __ -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2 tree
            -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> 'a1 tree -> 'a2
            tree -> ('a1, 'a2) coq_R_map_option -> 'a3

          type ('elt, 'x0, 'x) coq_R_map2_opt =
          | R_map2_opt_0 of 'elt tree * 'x0 tree
          | R_map2_opt_1 of 'elt tree * 'x0 tree * 'elt tree * key * 
             'elt * 'elt tree * Z_as_Int.t
          | R_map2_opt_2 of 'elt tree * 'x0 tree * 'elt tree * key * 
             'elt * 'elt tree * Z_as_Int.t * 'x0 tree * key * 'x0 * 'x0 tree
             * Z_as_Int.t * 'x0 tree * 'x0 option * 'x0 tree * 'x * 'x tree
             * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
             * ('elt, 'x0, 'x) coq_R_map2_opt
          | R_map2_opt_3 of 'elt tree * 'x0 tree * 'elt tree * key * 
             'elt * 'elt tree * Z_as_Int.t * 'x0 tree * key * 'x0 * 'x0 tree
             * Z_as_Int.t * 'x0 tree * 'x0 option * 'x0 tree * 'x tree
             * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
             * ('elt, 'x0, 'x) coq_R_map2_opt

          val coq_R_map2_opt_rect :
            (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3
            tree) -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2 tree -> __ ->
            'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1
            tree -> Z_as_Int.t -> __ -> __ -> 'a4) -> ('a1 tree -> 'a2 tree
            -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2
            tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ -> 'a2 tree ->
            'a2 option -> 'a2 tree -> __ -> 'a3 -> __ -> 'a3 tree -> ('a1,
            'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
            coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 tree ->
            key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2
            option -> 'a2 tree -> __ -> __ -> 'a3 tree -> ('a1, 'a2, 'a3)
            coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
            coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1 tree -> 'a2 tree -> 'a3 tree
            -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4

          val coq_R_map2_opt_rec :
            (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3
            tree) -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2 tree -> __ ->
            'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1
            tree -> Z_as_Int.t -> __ -> __ -> 'a4) -> ('a1 tree -> 'a2 tree
            -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2
            tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ -> 'a2 tree ->
            'a2 option -> 'a2 tree -> __ -> 'a3 -> __ -> 'a3 tree -> ('a1,
            'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
            coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 tree ->
            key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2
            option -> 'a2 tree -> __ -> __ -> 'a3 tree -> ('a1, 'a2, 'a3)
            coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
            coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1 tree -> 'a2 tree -> 'a3 tree
            -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4

          val fold' : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

          val flatten_e : 'a1 enumeration -> (key * 'a1) list
         end
       end

      type 'elt bst =
        'elt Raw.tree
        (* singleton inductive, whose constructor was Bst *)

      val this : 'a1 bst -> 'a1 Raw.tree

      type 'elt t = 'elt bst

      type key = Coq_regex_as_UCT.t

      val empty : 'a1 t

      val is_empty : 'a1 t -> bool

      val add : key -> 'a1 -> 'a1 t -> 'a1 t

      val remove : key -> 'a1 t -> 'a1 t

      val mem : key -> 'a1 t -> bool

      val find : key -> 'a1 t -> 'a1 option

      val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

      val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

      val map2 :
        ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t -> 'a3 t

      val elements : 'a1 t -> (key * 'a1) list

      val cardinal : 'a1 t -> nat

      val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

      val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool
     end

    module Coq_reFMF :
     sig
      val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

      val coq_In_dec : 'a1 Coq_reFM.t -> Coq_reFM.key -> bool
     end

    module MatchSpec :
     sig
     end

    module MatchSpecLemmas :
     sig
     end

    module Notations :
     sig
     end

    module Helpers :
     sig
      val coq_Plus : Regexes.regex -> Regexes.regex

      val coq_IterUnion : Regexes.regex list -> Regexes.regex

      val coq_IterApp : Regexes.regex list -> Regexes.regex

      val coq_Optional : Regexes.regex -> Regexes.regex

      val coq_REString : Strings.coq_String -> Regexes.regex
     end
   end
 end

module type LABEL =
 sig
  type coq_Label

  val defLabel : coq_Label

  val coq_Label_eq_dec : coq_Label -> coq_Label -> bool
 end

module Coq_DefsFn :
 functor (R:T) ->
 functor (Ty:sig
  type coq_Label

  val coq_Label_eq_dec : coq_Label -> coq_Label -> bool

  val defLabel : coq_Label

  type coq_Pointer

  val defPointer : coq_Pointer

  val pointer_compare : coq_Pointer -> coq_Pointer -> comparison

  type coq_Delta

  val defDelta : coq_Delta

  type coq_State = coq_Pointer * coq_Delta

  val defState : coq_State

  type index

  val index0 : index

  val index_eq_dec : index -> index -> bool

  val incr : index -> index

  val decr : index -> index

  val init_index : nat -> index

  val index2list : index -> bool list

  val list2index : bool list -> index

  val transition : R.Ty.coq_Sigma -> coq_State -> coq_State

  val transition_list : R.Ty.coq_Sigma list -> coq_State -> coq_State

  val accepts : R.Defs.Strings.coq_String -> coq_State -> bool

  val accepting : coq_State -> bool

  val init_state : R.Defs.Regexes.regex -> coq_State

  val init_state_inv : coq_State -> R.Defs.Regexes.regex
 end) ->
 sig
  module Pointer_as_UCT :
   sig
    type t = Ty.coq_Pointer

    val compare : Ty.coq_Pointer -> Ty.coq_Pointer -> comparison

    val coq_Pointer_eq_dec : Ty.coq_Pointer -> Ty.coq_Pointer -> bool
   end

  module Coredefs :
   sig
    type coq_Prefix = R.Defs.Strings.coq_String

    type coq_Suffix = R.Defs.Strings.coq_String

    type coq_Token = Ty.coq_Label * coq_Prefix

    type coq_Rule = Ty.coq_Label * R.Defs.Regexes.regex

    type sRule = Ty.coq_Label * Ty.coq_State
   end

  module MaxMunchSpec :
   sig
   end

  module Corollaries :
   sig
    val ru_dec : Coredefs.coq_Rule -> Coredefs.coq_Rule -> bool
   end
 end

module type Coq_T =
 sig
  module R :
   T

  module Ty :
   sig
    type coq_Label

    val coq_Label_eq_dec : coq_Label -> coq_Label -> bool

    val defLabel : coq_Label

    type coq_Pointer

    val defPointer : coq_Pointer

    val pointer_compare : coq_Pointer -> coq_Pointer -> comparison

    type coq_Delta

    val defDelta : coq_Delta

    type coq_State = coq_Pointer * coq_Delta

    val defState : coq_State

    type index

    val index0 : index

    val index_eq_dec : index -> index -> bool

    val incr : index -> index

    val decr : index -> index

    val init_index : nat -> index

    val index2list : index -> bool list

    val list2index : bool list -> index

    val transition : R.Ty.coq_Sigma -> coq_State -> coq_State

    val transition_list : R.Ty.coq_Sigma list -> coq_State -> coq_State

    val accepts : R.Defs.Strings.coq_String -> coq_State -> bool

    val accepting : coq_State -> bool

    val init_state : R.Defs.Regexes.regex -> coq_State

    val init_state_inv : coq_State -> R.Defs.Regexes.regex
   end

  module Defs :
   sig
    module Pointer_as_UCT :
     sig
      type t = Ty.coq_Pointer

      val compare : Ty.coq_Pointer -> Ty.coq_Pointer -> comparison

      val coq_Pointer_eq_dec : Ty.coq_Pointer -> Ty.coq_Pointer -> bool
     end

    module Coredefs :
     sig
      type coq_Prefix = R.Defs.Strings.coq_String

      type coq_Suffix = R.Defs.Strings.coq_String

      type coq_Token = Ty.coq_Label * coq_Prefix

      type coq_Rule = Ty.coq_Label * R.Defs.Regexes.regex

      type sRule = Ty.coq_Label * Ty.coq_State
     end

    module MaxMunchSpec :
     sig
     end

    module Corollaries :
     sig
      val ru_dec : Coredefs.coq_Rule -> Coredefs.coq_Rule -> bool
     end
   end
 end

val asciiEnumFn : nat -> char list

val asciiEnum : char list

val ascii2list : char -> bool list

val bool_order : bool -> bool -> comparison

val bool_list_order : bool list -> bool list -> comparison

val ascii_order : char -> char -> comparison

module ALPHABET :
 sig
  type coq_Sigma = char

  val coq_SigmaEnum : coq_Sigma list

  val compareT : char -> char -> comparison

  val coq_Sigma_dec : coq_Sigma -> coq_Sigma -> bool

  val ascii2Sigma : char -> coq_Sigma
 end

module Coq0_DefsFn :
 functor (R:T) ->
 functor (TabTy:sig
  module DS :
   sig
    module T_as_UCT :
     sig
      type t = R.Ty.coq_Sigma

      val compare : R.Ty.coq_Sigma -> R.Ty.coq_Sigma -> comparison
     end

    module T_as_UOT :
     sig
      type t = T_as_UCT.t

      val compare : t -> t -> t compare0

      val eq_dec : t -> t -> bool
     end

    module SigFS :
     sig
      module X' :
       sig
        type t = T_as_UCT.t

        val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

        val compare : T_as_UCT.t -> T_as_UCT.t -> comparison
       end

      module MSet :
       sig
        module Raw :
         sig
          type elt = T_as_UCT.t

          type tree = R.Defs.SigFS.MSet.Raw.tree =
          | Leaf
          | Node of Z_as_Int.t * tree * T_as_UCT.t * tree

          val empty : tree

          val is_empty : tree -> bool

          val mem : T_as_UCT.t -> tree -> bool

          val min_elt : tree -> elt option

          val max_elt : tree -> elt option

          val choose : tree -> elt option

          val fold : (elt -> 'a1 -> 'a1) -> tree -> 'a1 -> 'a1

          val elements_aux : T_as_UCT.t list -> tree -> T_as_UCT.t list

          val elements : tree -> T_as_UCT.t list

          val rev_elements_aux : T_as_UCT.t list -> tree -> T_as_UCT.t list

          val rev_elements : tree -> T_as_UCT.t list

          val cardinal : tree -> nat

          val maxdepth : tree -> nat

          val mindepth : tree -> nat

          val for_all : (elt -> bool) -> tree -> bool

          val exists_ : (elt -> bool) -> tree -> bool

          type enumeration = R.Defs.SigFS.MSet.Raw.enumeration =
          | End
          | More of elt * tree * enumeration

          val cons : tree -> enumeration -> enumeration

          val compare_more :
            T_as_UCT.t -> (enumeration -> comparison) -> enumeration ->
            comparison

          val compare_cont :
            tree -> (enumeration -> comparison) -> enumeration -> comparison

          val compare_end : enumeration -> comparison

          val compare : tree -> tree -> comparison

          val equal : tree -> tree -> bool

          val subsetl : (tree -> bool) -> T_as_UCT.t -> tree -> bool

          val subsetr : (tree -> bool) -> T_as_UCT.t -> tree -> bool

          val subset : tree -> tree -> bool

          type t = tree

          val height : t -> Z_as_Int.t

          val singleton : T_as_UCT.t -> tree

          val create : t -> T_as_UCT.t -> t -> tree

          val assert_false : t -> T_as_UCT.t -> t -> tree

          val bal : t -> T_as_UCT.t -> t -> tree

          val add : T_as_UCT.t -> tree -> tree

          val join : tree -> elt -> t -> t

          val remove_min : tree -> elt -> t -> t * elt

          val merge : tree -> tree -> tree

          val remove : T_as_UCT.t -> tree -> tree

          val concat : tree -> tree -> tree

          type triple = R.Defs.SigFS.MSet.Raw.triple = { t_left : t;
                                                         t_in : bool;
                                                         t_right : t }

          val t_left : triple -> t

          val t_in : triple -> bool

          val t_right : triple -> t

          val split : T_as_UCT.t -> tree -> triple

          val inter : tree -> tree -> tree

          val diff : tree -> tree -> tree

          val union : tree -> tree -> tree

          val filter : (elt -> bool) -> tree -> tree

          val partition : (elt -> bool) -> t -> t * t

          val ltb_tree : T_as_UCT.t -> tree -> bool

          val gtb_tree : T_as_UCT.t -> tree -> bool

          val isok : tree -> bool

          module MX :
           sig
            module OrderTac :
             sig
              module OTF :
               sig
                type t = T_as_UCT.t

                val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

                val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
               end

              module TO :
               sig
                type t = T_as_UCT.t

                val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

                val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
               end
             end

            val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

            val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

            val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
           end

          type coq_R_min_elt = R.Defs.SigFS.MSet.Raw.coq_R_min_elt =
          | R_min_elt_0 of tree
          | R_min_elt_1 of tree * Z_as_Int.t * tree * T_as_UCT.t * tree
          | R_min_elt_2 of tree * Z_as_Int.t * tree * T_as_UCT.t * tree
             * Z_as_Int.t * tree * T_as_UCT.t * tree * elt option
             * coq_R_min_elt

          type coq_R_max_elt = R.Defs.SigFS.MSet.Raw.coq_R_max_elt =
          | R_max_elt_0 of tree
          | R_max_elt_1 of tree * Z_as_Int.t * tree * T_as_UCT.t * tree
          | R_max_elt_2 of tree * Z_as_Int.t * tree * T_as_UCT.t * tree
             * Z_as_Int.t * tree * T_as_UCT.t * tree * elt option
             * coq_R_max_elt

          module L :
           sig
            module MO :
             sig
              module OrderTac :
               sig
                module OTF :
                 sig
                  type t = T_as_UCT.t

                  val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

                  val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
                 end

                module TO :
                 sig
                  type t = T_as_UCT.t

                  val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

                  val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
                 end
               end

              val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

              val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

              val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
             end
           end

          val flatten_e : enumeration -> elt list

          type coq_R_bal = R.Defs.SigFS.MSet.Raw.coq_R_bal =
          | R_bal_0 of t * T_as_UCT.t * t
          | R_bal_1 of t * T_as_UCT.t * t * Z_as_Int.t * tree * T_as_UCT.t
             * tree
          | R_bal_2 of t * T_as_UCT.t * t * Z_as_Int.t * tree * T_as_UCT.t
             * tree
          | R_bal_3 of t * T_as_UCT.t * t * Z_as_Int.t * tree * T_as_UCT.t
             * tree * Z_as_Int.t * tree * T_as_UCT.t * tree
          | R_bal_4 of t * T_as_UCT.t * t
          | R_bal_5 of t * T_as_UCT.t * t * Z_as_Int.t * tree * T_as_UCT.t
             * tree
          | R_bal_6 of t * T_as_UCT.t * t * Z_as_Int.t * tree * T_as_UCT.t
             * tree
          | R_bal_7 of t * T_as_UCT.t * t * Z_as_Int.t * tree * T_as_UCT.t
             * tree * Z_as_Int.t * tree * T_as_UCT.t * tree
          | R_bal_8 of t * T_as_UCT.t * t

          type coq_R_remove_min = R.Defs.SigFS.MSet.Raw.coq_R_remove_min =
          | R_remove_min_0 of tree * elt * t
          | R_remove_min_1 of tree * elt * t * Z_as_Int.t * tree * T_as_UCT.t
             * tree * (t * elt) * coq_R_remove_min * t * elt

          type coq_R_merge = R.Defs.SigFS.MSet.Raw.coq_R_merge =
          | R_merge_0 of tree * tree
          | R_merge_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * tree
          | R_merge_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * 
             tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * elt

          type coq_R_concat = R.Defs.SigFS.MSet.Raw.coq_R_concat =
          | R_concat_0 of tree * tree
          | R_concat_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * tree
          | R_concat_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * 
             tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * elt

          type coq_R_inter = R.Defs.SigFS.MSet.Raw.coq_R_inter =
          | R_inter_0 of tree * tree
          | R_inter_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * tree
          | R_inter_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * 
             tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * bool * 
             t * tree * coq_R_inter * tree * coq_R_inter
          | R_inter_3 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * 
             tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * bool * 
             t * tree * coq_R_inter * tree * coq_R_inter

          type coq_R_diff = R.Defs.SigFS.MSet.Raw.coq_R_diff =
          | R_diff_0 of tree * tree
          | R_diff_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * tree
          | R_diff_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * 
             tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * bool * 
             t * tree * coq_R_diff * tree * coq_R_diff
          | R_diff_3 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * 
             tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * bool * 
             t * tree * coq_R_diff * tree * coq_R_diff

          type coq_R_union = R.Defs.SigFS.MSet.Raw.coq_R_union =
          | R_union_0 of tree * tree
          | R_union_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * tree
          | R_union_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * 
             tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * bool * 
             t * tree * coq_R_union * tree * coq_R_union
         end

        module E :
         sig
          type t = T_as_UCT.t

          val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

          val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
         end

        type elt = T_as_UCT.t

        type t_ = Raw.t
          (* singleton inductive, whose constructor was Mkt *)

        val this : t_ -> Raw.t

        type t = t_

        val mem : elt -> t -> bool

        val add : elt -> t -> t

        val remove : elt -> t -> t

        val singleton : elt -> t

        val union : t -> t -> t

        val inter : t -> t -> t

        val diff : t -> t -> t

        val equal : t -> t -> bool

        val subset : t -> t -> bool

        val empty : t

        val is_empty : t -> bool

        val elements : t -> elt list

        val choose : t -> elt option

        val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

        val cardinal : t -> nat

        val filter : (elt -> bool) -> t -> t

        val for_all : (elt -> bool) -> t -> bool

        val exists_ : (elt -> bool) -> t -> bool

        val partition : (elt -> bool) -> t -> t * t

        val eq_dec : t -> t -> bool

        val compare : t -> t -> comparison

        val min_elt : t -> elt option

        val max_elt : t -> elt option
       end

      type elt = T_as_UCT.t

      type t = MSet.t

      val empty : t

      val is_empty : t -> bool

      val mem : elt -> t -> bool

      val add : elt -> t -> t

      val singleton : elt -> t

      val remove : elt -> t -> t

      val union : t -> t -> t

      val inter : t -> t -> t

      val diff : t -> t -> t

      val eq_dec : t -> t -> bool

      val equal : t -> t -> bool

      val subset : t -> t -> bool

      val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

      val for_all : (elt -> bool) -> t -> bool

      val exists_ : (elt -> bool) -> t -> bool

      val filter : (elt -> bool) -> t -> t

      val partition : (elt -> bool) -> t -> t * t

      val cardinal : t -> nat

      val elements : t -> elt list

      val choose : t -> elt option

      module MF :
       sig
        val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
       end

      val min_elt : t -> elt option

      val max_elt : t -> elt option

      val compare : t -> t -> t compare0

      module E :
       sig
        type t = T_as_UCT.t

        val compare : T_as_UCT.t -> T_as_UCT.t -> T_as_UCT.t compare0

        val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
       end
     end

    module SigFSF :
     sig
      val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
     end

    module SigFM :
     sig
      module E :
       sig
        type t = T_as_UCT.t

        val compare : T_as_UCT.t -> T_as_UCT.t -> T_as_UCT.t compare0

        val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
       end

      module Raw :
       sig
        type key = T_as_UCT.t

        type 'elt tree = 'elt R.Defs.SigFM.Raw.tree =
        | Leaf
        | Node of 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t

        val tree_rect :
          'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
          Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

        val tree_rec :
          'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
          Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

        val height : 'a1 tree -> Z_as_Int.t

        val cardinal : 'a1 tree -> nat

        val empty : 'a1 tree

        val is_empty : 'a1 tree -> bool

        val mem : T_as_UCT.t -> 'a1 tree -> bool

        val find : T_as_UCT.t -> 'a1 tree -> 'a1 option

        val create : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

        val assert_false : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

        val bal : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

        val add : key -> 'a1 -> 'a1 tree -> 'a1 tree

        val remove_min :
          'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree * (key * 'a1)

        val merge : 'a1 tree -> 'a1 tree -> 'a1 tree

        val remove : T_as_UCT.t -> 'a1 tree -> 'a1 tree

        val join : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

        type 'elt triple = 'elt R.Defs.SigFM.Raw.triple = { t_left : 
                                                            'elt tree;
                                                            t_opt : 'elt
                                                                    option;
                                                            t_right : 
                                                            'elt tree }

        val t_left : 'a1 triple -> 'a1 tree

        val t_opt : 'a1 triple -> 'a1 option

        val t_right : 'a1 triple -> 'a1 tree

        val split : T_as_UCT.t -> 'a1 tree -> 'a1 triple

        val concat : 'a1 tree -> 'a1 tree -> 'a1 tree

        val elements_aux : (key * 'a1) list -> 'a1 tree -> (key * 'a1) list

        val elements : 'a1 tree -> (key * 'a1) list

        val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

        type 'elt enumeration = 'elt R.Defs.SigFM.Raw.enumeration =
        | End
        | More of key * 'elt * 'elt tree * 'elt enumeration

        val enumeration_rect :
          'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 -> 'a2) ->
          'a1 enumeration -> 'a2

        val enumeration_rec :
          'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 -> 'a2) ->
          'a1 enumeration -> 'a2

        val cons : 'a1 tree -> 'a1 enumeration -> 'a1 enumeration

        val equal_more :
          ('a1 -> 'a1 -> bool) -> T_as_UCT.t -> 'a1 -> ('a1 enumeration ->
          bool) -> 'a1 enumeration -> bool

        val equal_cont :
          ('a1 -> 'a1 -> bool) -> 'a1 tree -> ('a1 enumeration -> bool) ->
          'a1 enumeration -> bool

        val equal_end : 'a1 enumeration -> bool

        val equal : ('a1 -> 'a1 -> bool) -> 'a1 tree -> 'a1 tree -> bool

        val map : ('a1 -> 'a2) -> 'a1 tree -> 'a2 tree

        val mapi : (key -> 'a1 -> 'a2) -> 'a1 tree -> 'a2 tree

        val map_option : (key -> 'a1 -> 'a2 option) -> 'a1 tree -> 'a2 tree

        val map2_opt :
          (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3 tree)
          -> ('a2 tree -> 'a3 tree) -> 'a1 tree -> 'a2 tree -> 'a3 tree

        val map2 :
          ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 tree -> 'a2 tree ->
          'a3 tree

        module Proofs :
         sig
          module MX :
           sig
            module TO :
             sig
              type t = T_as_UCT.t
             end

            module IsTO :
             sig
             end

            module OrderTac :
             sig
             end

            val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

            val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

            val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
           end

          module PX :
           sig
            module MO :
             sig
              module TO :
               sig
                type t = T_as_UCT.t
               end

              module IsTO :
               sig
               end

              module OrderTac :
               sig
               end

              val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

              val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

              val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
             end
           end

          module L :
           sig
            module MX :
             sig
              module TO :
               sig
                type t = T_as_UCT.t
               end

              module IsTO :
               sig
               end

              module OrderTac :
               sig
               end

              val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

              val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

              val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
             end

            module PX :
             sig
              module MO :
               sig
                module TO :
                 sig
                  type t = T_as_UCT.t
                 end

                module IsTO :
                 sig
                 end

                module OrderTac :
                 sig
                 end

                val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
               end
             end

            type key = T_as_UCT.t

            type 'elt t = (T_as_UCT.t * 'elt) list

            val empty : 'a1 t

            val is_empty : 'a1 t -> bool

            val mem : key -> 'a1 t -> bool

            type 'elt coq_R_mem = 'elt R.Defs.SigFM.Raw.Proofs.L.coq_R_mem =
            | R_mem_0 of 'elt t
            | R_mem_1 of 'elt t * T_as_UCT.t * 'elt * (T_as_UCT.t * 'elt) list
            | R_mem_2 of 'elt t * T_as_UCT.t * 'elt * (T_as_UCT.t * 'elt) list
            | R_mem_3 of 'elt t * T_as_UCT.t * 'elt
               * (T_as_UCT.t * 'elt) list * bool * 'elt coq_R_mem

            val coq_R_mem_rect :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
              T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __
              -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1)
              list -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2)
              -> 'a1 t -> bool -> 'a1 coq_R_mem -> 'a2

            val coq_R_mem_rec :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
              T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __
              -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1)
              list -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2)
              -> 'a1 t -> bool -> 'a1 coq_R_mem -> 'a2

            val mem_rect :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
              T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __
              -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1)
              list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

            val mem_rec :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
              T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __
              -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1)
              list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

            val coq_R_mem_correct : key -> 'a1 t -> bool -> 'a1 coq_R_mem

            val find : key -> 'a1 t -> 'a1 option

            type 'elt coq_R_find = 'elt R.Defs.SigFM.Raw.Proofs.L.coq_R_find =
            | R_find_0 of 'elt t
            | R_find_1 of 'elt t * T_as_UCT.t * 'elt
               * (T_as_UCT.t * 'elt) list
            | R_find_2 of 'elt t * T_as_UCT.t * 'elt
               * (T_as_UCT.t * 'elt) list
            | R_find_3 of 'elt t * T_as_UCT.t * 'elt
               * (T_as_UCT.t * 'elt) list * 'elt option * 'elt coq_R_find

            val coq_R_find_rect :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
              T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __
              -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1)
              list -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2
              -> 'a2) -> 'a1 t -> 'a1 option -> 'a1 coq_R_find -> 'a2

            val coq_R_find_rec :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
              T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __
              -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1)
              list -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2
              -> 'a2) -> 'a1 t -> 'a1 option -> 'a1 coq_R_find -> 'a2

            val find_rect :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
              T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __
              -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1)
              list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

            val find_rec :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
              T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __
              -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1)
              list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

            val coq_R_find_correct :
              key -> 'a1 t -> 'a1 option -> 'a1 coq_R_find

            val add : key -> 'a1 -> 'a1 t -> 'a1 t

            type 'elt coq_R_add = 'elt R.Defs.SigFM.Raw.Proofs.L.coq_R_add =
            | R_add_0 of 'elt t
            | R_add_1 of 'elt t * T_as_UCT.t * 'elt * (T_as_UCT.t * 'elt) list
            | R_add_2 of 'elt t * T_as_UCT.t * 'elt * (T_as_UCT.t * 'elt) list
            | R_add_3 of 'elt t * T_as_UCT.t * 'elt
               * (T_as_UCT.t * 'elt) list * 'elt t * 'elt coq_R_add

            val coq_R_add_rect :
              key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
              'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
              __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1 t -> 'a1
              coq_R_add -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_add ->
              'a2

            val coq_R_add_rec :
              key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
              'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
              __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1 t -> 'a1
              coq_R_add -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_add ->
              'a2

            val add_rect :
              key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
              'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
              __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1
              t -> 'a2

            val add_rec :
              key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
              'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
              __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1
              t -> 'a2

            val coq_R_add_correct :
              key -> 'a1 -> 'a1 t -> 'a1 t -> 'a1 coq_R_add

            val remove : key -> 'a1 t -> 'a1 t

            type 'elt coq_R_remove = 'elt R.Defs.SigFM.Raw.Proofs.L.coq_R_remove =
            | R_remove_0 of 'elt t
            | R_remove_1 of 'elt t * T_as_UCT.t * 'elt
               * (T_as_UCT.t * 'elt) list
            | R_remove_2 of 'elt t * T_as_UCT.t * 'elt
               * (T_as_UCT.t * 'elt) list
            | R_remove_3 of 'elt t * T_as_UCT.t * 'elt
               * (T_as_UCT.t * 'elt) list * 'elt t * 'elt coq_R_remove

            val coq_R_remove_rect :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
              T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __
              -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1)
              list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_remove -> 'a2 ->
              'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove -> 'a2

            val coq_R_remove_rec :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
              T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __
              -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1)
              list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_remove -> 'a2 ->
              'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove -> 'a2

            val remove_rect :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
              T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __
              -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1)
              list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

            val remove_rec :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
              T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __
              -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1)
              list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

            val coq_R_remove_correct :
              key -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove

            val elements : 'a1 t -> 'a1 t

            val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

            type ('elt, 'a) coq_R_fold = ('elt, 'a) R.Defs.SigFM.Raw.Proofs.L.coq_R_fold =
            | R_fold_0 of 'elt t * 'a
            | R_fold_1 of 'elt t * 'a * T_as_UCT.t * 'elt
               * (T_as_UCT.t * 'elt) list * 'a * ('elt, 'a) coq_R_fold

            val coq_R_fold_rect :
              (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) ->
              ('a1 t -> 'a2 -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
              -> __ -> 'a2 -> ('a1, 'a2) coq_R_fold -> 'a3 -> 'a3) -> 'a1 t
              -> 'a2 -> 'a2 -> ('a1, 'a2) coq_R_fold -> 'a3

            val coq_R_fold_rec :
              (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) ->
              ('a1 t -> 'a2 -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
              -> __ -> 'a2 -> ('a1, 'a2) coq_R_fold -> 'a3 -> 'a3) -> 'a1 t
              -> 'a2 -> 'a2 -> ('a1, 'a2) coq_R_fold -> 'a3

            val fold_rect :
              (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) ->
              ('a1 t -> 'a2 -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
              -> __ -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a3

            val fold_rec :
              (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) ->
              ('a1 t -> 'a2 -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
              -> __ -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a3

            val coq_R_fold_correct :
              (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2 -> ('a1, 'a2)
              coq_R_fold

            val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool

            type 'elt coq_R_equal = 'elt R.Defs.SigFM.Raw.Proofs.L.coq_R_equal =
            | R_equal_0 of 'elt t * 'elt t
            | R_equal_1 of 'elt t * 'elt t * T_as_UCT.t * 'elt
               * (T_as_UCT.t * 'elt) list * T_as_UCT.t * 'elt
               * (T_as_UCT.t * 'elt) list * bool * 'elt coq_R_equal
            | R_equal_2 of 'elt t * 'elt t * T_as_UCT.t * 'elt
               * (T_as_UCT.t * 'elt) list * T_as_UCT.t * 'elt
               * (T_as_UCT.t * 'elt) list * T_as_UCT.t compare0
            | R_equal_3 of 'elt t * 'elt t * 'elt t * 'elt t

            val coq_R_equal_rect :
              ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) ->
              ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
              -> __ -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
              __ -> __ -> bool -> 'a1 coq_R_equal -> 'a2 -> 'a2) -> ('a1 t ->
              'a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
              T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
              T_as_UCT.t compare0 -> __ -> __ -> 'a2) -> ('a1 t -> 'a1 t ->
              'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2) -> 'a1 t -> 'a1 t ->
              bool -> 'a1 coq_R_equal -> 'a2

            val coq_R_equal_rec :
              ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) ->
              ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
              -> __ -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
              __ -> __ -> bool -> 'a1 coq_R_equal -> 'a2 -> 'a2) -> ('a1 t ->
              'a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
              T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
              T_as_UCT.t compare0 -> __ -> __ -> 'a2) -> ('a1 t -> 'a1 t ->
              'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2) -> 'a1 t -> 'a1 t ->
              bool -> 'a1 coq_R_equal -> 'a2

            val equal_rect :
              ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) ->
              ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
              -> __ -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
              __ -> __ -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1
              -> (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t compare0 -> __ ->
              __ -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ ->
              __ -> 'a2) -> 'a1 t -> 'a1 t -> 'a2

            val equal_rec :
              ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) ->
              ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
              -> __ -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
              __ -> __ -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1
              -> (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t compare0 -> __ ->
              __ -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ ->
              __ -> 'a2) -> 'a1 t -> 'a1 t -> 'a2

            val coq_R_equal_correct :
              ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool -> 'a1
              coq_R_equal

            val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

            val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

            val option_cons :
              key -> 'a1 option -> (key * 'a1) list -> (key * 'a1) list

            val map2_l :
              ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a3 t

            val map2_r :
              ('a1 option -> 'a2 option -> 'a3 option) -> 'a2 t -> 'a3 t

            val map2 :
              ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t ->
              'a3 t

            val combine : 'a1 t -> 'a2 t -> ('a1 option * 'a2 option) t

            val fold_right_pair :
              ('a1 -> 'a2 -> 'a3 -> 'a3) -> ('a1 * 'a2) list -> 'a3 -> 'a3

            val map2_alt :
              ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t ->
              (key * 'a3) list

            val at_least_one :
              'a1 option -> 'a2 option -> ('a1 option * 'a2 option) option

            val at_least_one_then_f :
              ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 option -> 'a2
              option -> 'a3 option
           end

          type 'elt coq_R_mem = 'elt R.Defs.SigFM.Raw.Proofs.coq_R_mem =
          | R_mem_0 of 'elt tree
          | R_mem_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * bool * 'elt coq_R_mem
          | R_mem_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t
          | R_mem_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * bool * 'elt coq_R_mem

          val coq_R_mem_rect :
            T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> bool ->
            'a1 coq_R_mem -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree -> key ->
            'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1
            tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
            __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 tree ->
            bool -> 'a1 coq_R_mem -> 'a2

          val coq_R_mem_rec :
            T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> bool ->
            'a1 coq_R_mem -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree -> key ->
            'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1
            tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
            __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 tree ->
            bool -> 'a1 coq_R_mem -> 'a2

          type 'elt coq_R_find = 'elt R.Defs.SigFM.Raw.Proofs.coq_R_find =
          | R_find_0 of 'elt tree
          | R_find_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt option * 'elt coq_R_find
          | R_find_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t
          | R_find_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt option * 'elt coq_R_find

          val coq_R_find_rect :
            T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
            option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree
            -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2)
            -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
            -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2)
            -> 'a1 tree -> 'a1 option -> 'a1 coq_R_find -> 'a2

          val coq_R_find_rec :
            T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
            option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree
            -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2)
            -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
            -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2)
            -> 'a1 tree -> 'a1 option -> 'a1 coq_R_find -> 'a2

          type 'elt coq_R_bal = 'elt R.Defs.SigFM.Raw.Proofs.coq_R_bal =
          | R_bal_0 of 'elt tree * key * 'elt * 'elt tree
          | R_bal_1 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
             key * 'elt * 'elt tree * Z_as_Int.t
          | R_bal_2 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
             key * 'elt * 'elt tree * Z_as_Int.t
          | R_bal_3 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
             key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 
             'elt * 'elt tree * Z_as_Int.t
          | R_bal_4 of 'elt tree * key * 'elt * 'elt tree
          | R_bal_5 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
             key * 'elt * 'elt tree * Z_as_Int.t
          | R_bal_6 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
             key * 'elt * 'elt tree * Z_as_Int.t
          | R_bal_7 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
             key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 
             'elt * 'elt tree * Z_as_Int.t
          | R_bal_8 of 'elt tree * key * 'elt * 'elt tree

          val coq_R_bal_rect :
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> 'a2) ->
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) ->
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> __ ->
            'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2) ->
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> __
            -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __
            -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
            -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __
            -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key ->
            'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1
            -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> key ->
            'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2) -> ('a1 tree -> key
            -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a2) -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_bal -> 'a2

          val coq_R_bal_rec :
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> 'a2) ->
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) ->
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> __ ->
            'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2) ->
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> __
            -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __
            -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
            -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __
            -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key ->
            'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1
            -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> key ->
            'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2) -> ('a1 tree -> key
            -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a2) -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_bal -> 'a2

          type 'elt coq_R_add = 'elt R.Defs.SigFM.Raw.Proofs.coq_R_add =
          | R_add_0 of 'elt tree
          | R_add_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt tree * 'elt coq_R_add
          | R_add_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t
          | R_add_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt tree * 'elt coq_R_add

          val coq_R_add_rect :
            key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
            tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) ->
            ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
            __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1
            tree -> 'a1 tree -> 'a1 coq_R_add -> 'a2

          val coq_R_add_rec :
            key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
            tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) ->
            ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
            __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1
            tree -> 'a1 tree -> 'a1 coq_R_add -> 'a2

          type 'elt coq_R_remove_min = 'elt R.Defs.SigFM.Raw.Proofs.coq_R_remove_min =
          | R_remove_min_0 of 'elt tree * key * 'elt * 'elt tree
          | R_remove_min_1 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
             * key * 'elt * 'elt tree * Z_as_Int.t
             * ('elt tree * (key * 'elt)) * 'elt coq_R_remove_min * 'elt tree
             * (key * 'elt)

          val coq_R_remove_min_rect :
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1 tree ->
            key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> ('a1 tree * (key * 'a1)) -> 'a1
            coq_R_remove_min -> 'a2 -> 'a1 tree -> (key * 'a1) -> __ -> 'a2)
            -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> ('a1 tree * (key * 'a1))
            -> 'a1 coq_R_remove_min -> 'a2

          val coq_R_remove_min_rec :
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1 tree ->
            key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> ('a1 tree * (key * 'a1)) -> 'a1
            coq_R_remove_min -> 'a2 -> 'a1 tree -> (key * 'a1) -> __ -> 'a2)
            -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> ('a1 tree * (key * 'a1))
            -> 'a1 coq_R_remove_min -> 'a2

          type 'elt coq_R_merge = 'elt R.Defs.SigFM.Raw.Proofs.coq_R_merge =
          | R_merge_0 of 'elt tree * 'elt tree
          | R_merge_1 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
             * 'elt tree * Z_as_Int.t
          | R_merge_2 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
             * 'elt tree * Z_as_Int.t * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt tree * (key * 'elt) * key * 'elt

          val coq_R_merge_rect :
            ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
            'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
            tree -> Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> key -> 'a1
            -> __ -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 tree -> 'a1
            coq_R_merge -> 'a2

          val coq_R_merge_rec :
            ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
            'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
            tree -> Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> key -> 'a1
            -> __ -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 tree -> 'a1
            coq_R_merge -> 'a2

          type 'elt coq_R_remove = 'elt R.Defs.SigFM.Raw.Proofs.coq_R_remove =
          | R_remove_0 of 'elt tree
          | R_remove_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt tree * 'elt coq_R_remove
          | R_remove_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t
          | R_remove_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt tree * 'elt coq_R_remove

          val coq_R_remove_rect :
            T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
            tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree
            -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2)
            -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
            -> __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2)
            -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_remove -> 'a2

          val coq_R_remove_rec :
            T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
            tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree
            -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2)
            -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
            -> __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2)
            -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_remove -> 'a2

          type 'elt coq_R_concat = 'elt R.Defs.SigFM.Raw.Proofs.coq_R_concat =
          | R_concat_0 of 'elt tree * 'elt tree
          | R_concat_1 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
             * 'elt tree * Z_as_Int.t
          | R_concat_2 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
             * 'elt tree * Z_as_Int.t * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt tree * (key * 'elt)

          val coq_R_concat_rect :
            ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
            'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
            tree -> Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> 'a2) -> 'a1
            tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_concat -> 'a2

          val coq_R_concat_rec :
            ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
            'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
            tree -> Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> 'a2) -> 'a1
            tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_concat -> 'a2

          type 'elt coq_R_split = 'elt R.Defs.SigFM.Raw.Proofs.coq_R_split =
          | R_split_0 of 'elt tree
          | R_split_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt triple * 'elt coq_R_split * 'elt tree
             * 'elt option * 'elt tree
          | R_split_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t
          | R_split_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt triple * 'elt coq_R_split * 'elt tree
             * 'elt option * 'elt tree

          val coq_R_split_rect :
            T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
            triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option -> 'a1
            tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
            tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option ->
            'a1 tree -> __ -> 'a2) -> 'a1 tree -> 'a1 triple -> 'a1
            coq_R_split -> 'a2

          val coq_R_split_rec :
            T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
            triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option -> 'a1
            tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
            tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option ->
            'a1 tree -> __ -> 'a2) -> 'a1 tree -> 'a1 triple -> 'a1
            coq_R_split -> 'a2

          type ('elt, 'x) coq_R_map_option = ('elt, 'x) R.Defs.SigFM.Raw.Proofs.coq_R_map_option =
          | R_map_option_0 of 'elt tree
          | R_map_option_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'x * 'x tree * ('elt, 'x) coq_R_map_option
             * 'x tree * ('elt, 'x) coq_R_map_option
          | R_map_option_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'x tree * ('elt, 'x) coq_R_map_option * 'x tree
             * ('elt, 'x) coq_R_map_option

          val coq_R_map_option_rect :
            (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) -> ('a1
            tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
            'a2 -> __ -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 ->
            'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> ('a1
            tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
            __ -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2 tree
            -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> 'a1 tree -> 'a2
            tree -> ('a1, 'a2) coq_R_map_option -> 'a3

          val coq_R_map_option_rec :
            (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) -> ('a1
            tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
            'a2 -> __ -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 ->
            'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> ('a1
            tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
            __ -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2 tree
            -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> 'a1 tree -> 'a2
            tree -> ('a1, 'a2) coq_R_map_option -> 'a3

          type ('elt, 'x0, 'x) coq_R_map2_opt = ('elt, 'x0, 'x) R.Defs.SigFM.Raw.Proofs.coq_R_map2_opt =
          | R_map2_opt_0 of 'elt tree * 'x0 tree
          | R_map2_opt_1 of 'elt tree * 'x0 tree * 'elt tree * key * 
             'elt * 'elt tree * Z_as_Int.t
          | R_map2_opt_2 of 'elt tree * 'x0 tree * 'elt tree * key * 
             'elt * 'elt tree * Z_as_Int.t * 'x0 tree * key * 'x0 * 'x0 tree
             * Z_as_Int.t * 'x0 tree * 'x0 option * 'x0 tree * 'x * 'x tree
             * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
             * ('elt, 'x0, 'x) coq_R_map2_opt
          | R_map2_opt_3 of 'elt tree * 'x0 tree * 'elt tree * key * 
             'elt * 'elt tree * Z_as_Int.t * 'x0 tree * key * 'x0 * 'x0 tree
             * Z_as_Int.t * 'x0 tree * 'x0 option * 'x0 tree * 'x tree
             * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
             * ('elt, 'x0, 'x) coq_R_map2_opt

          val coq_R_map2_opt_rect :
            (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3
            tree) -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2 tree -> __ ->
            'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1
            tree -> Z_as_Int.t -> __ -> __ -> 'a4) -> ('a1 tree -> 'a2 tree
            -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2
            tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ -> 'a2 tree ->
            'a2 option -> 'a2 tree -> __ -> 'a3 -> __ -> 'a3 tree -> ('a1,
            'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
            coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 tree ->
            key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2
            option -> 'a2 tree -> __ -> __ -> 'a3 tree -> ('a1, 'a2, 'a3)
            coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
            coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1 tree -> 'a2 tree -> 'a3 tree
            -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4

          val coq_R_map2_opt_rec :
            (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3
            tree) -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2 tree -> __ ->
            'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1
            tree -> Z_as_Int.t -> __ -> __ -> 'a4) -> ('a1 tree -> 'a2 tree
            -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2
            tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ -> 'a2 tree ->
            'a2 option -> 'a2 tree -> __ -> 'a3 -> __ -> 'a3 tree -> ('a1,
            'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
            coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 tree ->
            key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2
            option -> 'a2 tree -> __ -> __ -> 'a3 tree -> ('a1, 'a2, 'a3)
            coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
            coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1 tree -> 'a2 tree -> 'a3 tree
            -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4

          val fold' : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

          val flatten_e : 'a1 enumeration -> (key * 'a1) list
         end
       end

      type 'elt bst =
        'elt Raw.tree
        (* singleton inductive, whose constructor was Bst *)

      val this : 'a1 bst -> 'a1 Raw.tree

      type 'elt t = 'elt bst

      type key = T_as_UCT.t

      val empty : 'a1 t

      val is_empty : 'a1 t -> bool

      val add : key -> 'a1 -> 'a1 t -> 'a1 t

      val remove : key -> 'a1 t -> 'a1 t

      val mem : key -> 'a1 t -> bool

      val find : key -> 'a1 t -> 'a1 option

      val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

      val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

      val map2 :
        ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t -> 'a3 t

      val elements : 'a1 t -> (key * 'a1) list

      val cardinal : 'a1 t -> nat

      val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

      val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool
     end

    module SigFMF :
     sig
      val eqb : T_as_UCT.t -> T_as_UCT.t -> bool

      val coq_In_dec : 'a1 SigFM.t -> SigFM.key -> bool
     end

    module Strings :
     sig
      type coq_String = R.Ty.coq_Sigma list

      val coq_String_dec : coq_String -> coq_String -> bool

      val rm_empty : coq_String list -> R.Ty.coq_Sigma list list
     end

    module Regexes :
     sig
      type regex = R.Defs.Regexes.regex =
      | EmptySet
      | EmptyStr
      | Char of R.Ty.coq_Sigma
      | App of regex * regex
      | Union of regex * regex
      | Star of regex

      val regex_rect :
        'a1 -> 'a1 -> (R.Ty.coq_Sigma -> 'a1) -> (regex -> 'a1 -> regex ->
        'a1 -> 'a1) -> (regex -> 'a1 -> regex -> 'a1 -> 'a1) -> (regex -> 'a1
        -> 'a1) -> regex -> 'a1

      val regex_rec :
        'a1 -> 'a1 -> (R.Ty.coq_Sigma -> 'a1) -> (regex -> 'a1 -> regex ->
        'a1 -> 'a1) -> (regex -> 'a1 -> regex -> 'a1 -> 'a1) -> (regex -> 'a1
        -> 'a1) -> regex -> 'a1

      val regex_dec : regex -> regex -> bool

      val regex_eq : regex -> regex -> bool

      val nullable' : regex -> bool

      val nullable : regex -> bool

      val derivative : R.Ty.coq_Sigma -> regex -> regex

      val derivative_list : R.Ty.coq_Sigma list -> regex -> regex

      val re_compare : regex -> regex -> comparison
     end

    module Coq_regex_as_UCT :
     sig
      type t = Regexes.regex

      val compare : Regexes.regex -> Regexes.regex -> comparison
     end

    module Coq_regex_as_UOT :
     sig
      type t = Coq_regex_as_UCT.t

      val compare : t -> t -> t compare0

      val eq_dec : t -> t -> bool
     end

    module Coq_reFS :
     sig
      module X' :
       sig
        type t = Coq_regex_as_UCT.t

        val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

        val compare : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> comparison
       end

      module MSet :
       sig
        module Raw :
         sig
          type elt = Coq_regex_as_UCT.t

          type tree = R.Defs.Coq_reFS.MSet.Raw.tree =
          | Leaf
          | Node of Z_as_Int.t * tree * Coq_regex_as_UCT.t * tree

          val empty : tree

          val is_empty : tree -> bool

          val mem : Coq_regex_as_UCT.t -> tree -> bool

          val min_elt : tree -> elt option

          val max_elt : tree -> elt option

          val choose : tree -> elt option

          val fold : (elt -> 'a1 -> 'a1) -> tree -> 'a1 -> 'a1

          val elements_aux :
            Coq_regex_as_UCT.t list -> tree -> Coq_regex_as_UCT.t list

          val elements : tree -> Coq_regex_as_UCT.t list

          val rev_elements_aux :
            Coq_regex_as_UCT.t list -> tree -> Coq_regex_as_UCT.t list

          val rev_elements : tree -> Coq_regex_as_UCT.t list

          val cardinal : tree -> nat

          val maxdepth : tree -> nat

          val mindepth : tree -> nat

          val for_all : (elt -> bool) -> tree -> bool

          val exists_ : (elt -> bool) -> tree -> bool

          type enumeration = R.Defs.Coq_reFS.MSet.Raw.enumeration =
          | End
          | More of elt * tree * enumeration

          val cons : tree -> enumeration -> enumeration

          val compare_more :
            Coq_regex_as_UCT.t -> (enumeration -> comparison) -> enumeration
            -> comparison

          val compare_cont :
            tree -> (enumeration -> comparison) -> enumeration -> comparison

          val compare_end : enumeration -> comparison

          val compare : tree -> tree -> comparison

          val equal : tree -> tree -> bool

          val subsetl : (tree -> bool) -> Coq_regex_as_UCT.t -> tree -> bool

          val subsetr : (tree -> bool) -> Coq_regex_as_UCT.t -> tree -> bool

          val subset : tree -> tree -> bool

          type t = tree

          val height : t -> Z_as_Int.t

          val singleton : Coq_regex_as_UCT.t -> tree

          val create : t -> Coq_regex_as_UCT.t -> t -> tree

          val assert_false : t -> Coq_regex_as_UCT.t -> t -> tree

          val bal : t -> Coq_regex_as_UCT.t -> t -> tree

          val add : Coq_regex_as_UCT.t -> tree -> tree

          val join : tree -> elt -> t -> t

          val remove_min : tree -> elt -> t -> t * elt

          val merge : tree -> tree -> tree

          val remove : Coq_regex_as_UCT.t -> tree -> tree

          val concat : tree -> tree -> tree

          type triple = R.Defs.Coq_reFS.MSet.Raw.triple = { t_left : 
                                                            t; t_in : 
                                                            bool; t_right : 
                                                            t }

          val t_left : triple -> t

          val t_in : triple -> bool

          val t_right : triple -> t

          val split : Coq_regex_as_UCT.t -> tree -> triple

          val inter : tree -> tree -> tree

          val diff : tree -> tree -> tree

          val union : tree -> tree -> tree

          val filter : (elt -> bool) -> tree -> tree

          val partition : (elt -> bool) -> t -> t * t

          val ltb_tree : Coq_regex_as_UCT.t -> tree -> bool

          val gtb_tree : Coq_regex_as_UCT.t -> tree -> bool

          val isok : tree -> bool

          module MX :
           sig
            module OrderTac :
             sig
              module OTF :
               sig
                type t = Coq_regex_as_UCT.t

                val compare :
                  Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> comparison

                val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
               end

              module TO :
               sig
                type t = Coq_regex_as_UCT.t

                val compare :
                  Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> comparison

                val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
               end
             end

            val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

            val lt_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

            val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
           end

          type coq_R_min_elt = R.Defs.Coq_reFS.MSet.Raw.coq_R_min_elt =
          | R_min_elt_0 of tree
          | R_min_elt_1 of tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
             * tree
          | R_min_elt_2 of tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
             * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t * tree
             * elt option * coq_R_min_elt

          type coq_R_max_elt = R.Defs.Coq_reFS.MSet.Raw.coq_R_max_elt =
          | R_max_elt_0 of tree
          | R_max_elt_1 of tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
             * tree
          | R_max_elt_2 of tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
             * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t * tree
             * elt option * coq_R_max_elt

          module L :
           sig
            module MO :
             sig
              module OrderTac :
               sig
                module OTF :
                 sig
                  type t = Coq_regex_as_UCT.t

                  val compare :
                    Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> comparison

                  val eq_dec :
                    Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                 end

                module TO :
                 sig
                  type t = Coq_regex_as_UCT.t

                  val compare :
                    Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> comparison

                  val eq_dec :
                    Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                 end
               end

              val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

              val lt_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

              val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
             end
           end

          val flatten_e : enumeration -> elt list

          type coq_R_bal = R.Defs.Coq_reFS.MSet.Raw.coq_R_bal =
          | R_bal_0 of t * Coq_regex_as_UCT.t * t
          | R_bal_1 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * tree
             * Coq_regex_as_UCT.t * tree
          | R_bal_2 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * tree
             * Coq_regex_as_UCT.t * tree
          | R_bal_3 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * tree
             * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
             * Coq_regex_as_UCT.t * tree
          | R_bal_4 of t * Coq_regex_as_UCT.t * t
          | R_bal_5 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * tree
             * Coq_regex_as_UCT.t * tree
          | R_bal_6 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * tree
             * Coq_regex_as_UCT.t * tree
          | R_bal_7 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * tree
             * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
             * Coq_regex_as_UCT.t * tree
          | R_bal_8 of t * Coq_regex_as_UCT.t * t

          type coq_R_remove_min = R.Defs.Coq_reFS.MSet.Raw.coq_R_remove_min =
          | R_remove_min_0 of tree * elt * t
          | R_remove_min_1 of tree * elt * t * Z_as_Int.t * tree
             * Coq_regex_as_UCT.t * tree * (t * elt) * coq_R_remove_min * 
             t * elt

          type coq_R_merge = R.Defs.Coq_reFS.MSet.Raw.coq_R_merge =
          | R_merge_0 of tree * tree
          | R_merge_1 of tree * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
             * tree
          | R_merge_2 of tree * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
             * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t * tree * 
             t * elt

          type coq_R_concat = R.Defs.Coq_reFS.MSet.Raw.coq_R_concat =
          | R_concat_0 of tree * tree
          | R_concat_1 of tree * tree * Z_as_Int.t * tree
             * Coq_regex_as_UCT.t * tree
          | R_concat_2 of tree * tree * Z_as_Int.t * tree
             * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
             * Coq_regex_as_UCT.t * tree * t * elt

          type coq_R_inter = R.Defs.Coq_reFS.MSet.Raw.coq_R_inter =
          | R_inter_0 of tree * tree
          | R_inter_1 of tree * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
             * tree
          | R_inter_2 of tree * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
             * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t * tree * 
             t * bool * t * tree * coq_R_inter * tree * coq_R_inter
          | R_inter_3 of tree * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
             * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t * tree * 
             t * bool * t * tree * coq_R_inter * tree * coq_R_inter

          type coq_R_diff = R.Defs.Coq_reFS.MSet.Raw.coq_R_diff =
          | R_diff_0 of tree * tree
          | R_diff_1 of tree * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
             * tree
          | R_diff_2 of tree * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
             * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t * tree * 
             t * bool * t * tree * coq_R_diff * tree * coq_R_diff
          | R_diff_3 of tree * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
             * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t * tree * 
             t * bool * t * tree * coq_R_diff * tree * coq_R_diff

          type coq_R_union = R.Defs.Coq_reFS.MSet.Raw.coq_R_union =
          | R_union_0 of tree * tree
          | R_union_1 of tree * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
             * tree
          | R_union_2 of tree * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
             * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t * tree * 
             t * bool * t * tree * coq_R_union * tree * coq_R_union
         end

        module E :
         sig
          type t = Coq_regex_as_UCT.t

          val compare : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> comparison

          val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
         end

        type elt = Coq_regex_as_UCT.t

        type t_ = Raw.t
          (* singleton inductive, whose constructor was Mkt *)

        val this : t_ -> Raw.t

        type t = t_

        val mem : elt -> t -> bool

        val add : elt -> t -> t

        val remove : elt -> t -> t

        val singleton : elt -> t

        val union : t -> t -> t

        val inter : t -> t -> t

        val diff : t -> t -> t

        val equal : t -> t -> bool

        val subset : t -> t -> bool

        val empty : t

        val is_empty : t -> bool

        val elements : t -> elt list

        val choose : t -> elt option

        val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

        val cardinal : t -> nat

        val filter : (elt -> bool) -> t -> t

        val for_all : (elt -> bool) -> t -> bool

        val exists_ : (elt -> bool) -> t -> bool

        val partition : (elt -> bool) -> t -> t * t

        val eq_dec : t -> t -> bool

        val compare : t -> t -> comparison

        val min_elt : t -> elt option

        val max_elt : t -> elt option
       end

      type elt = Coq_regex_as_UCT.t

      type t = MSet.t

      val empty : t

      val is_empty : t -> bool

      val mem : elt -> t -> bool

      val add : elt -> t -> t

      val singleton : elt -> t

      val remove : elt -> t -> t

      val union : t -> t -> t

      val inter : t -> t -> t

      val diff : t -> t -> t

      val eq_dec : t -> t -> bool

      val equal : t -> t -> bool

      val subset : t -> t -> bool

      val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

      val for_all : (elt -> bool) -> t -> bool

      val exists_ : (elt -> bool) -> t -> bool

      val filter : (elt -> bool) -> t -> t

      val partition : (elt -> bool) -> t -> t * t

      val cardinal : t -> nat

      val elements : t -> elt list

      val choose : t -> elt option

      module MF :
       sig
        val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
       end

      val min_elt : t -> elt option

      val max_elt : t -> elt option

      val compare : t -> t -> t compare0

      module E :
       sig
        type t = Coq_regex_as_UCT.t

        val compare :
          Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t
          compare0

        val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
       end
     end

    module Coq_reFSF :
     sig
      val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
     end

    module Coq_reFM :
     sig
      module E :
       sig
        type t = Coq_regex_as_UCT.t

        val compare :
          Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t
          compare0

        val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
       end

      module Raw :
       sig
        type key = Coq_regex_as_UCT.t

        type 'elt tree = 'elt R.Defs.Coq_reFM.Raw.tree =
        | Leaf
        | Node of 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t

        val tree_rect :
          'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
          Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

        val tree_rec :
          'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
          Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

        val height : 'a1 tree -> Z_as_Int.t

        val cardinal : 'a1 tree -> nat

        val empty : 'a1 tree

        val is_empty : 'a1 tree -> bool

        val mem : Coq_regex_as_UCT.t -> 'a1 tree -> bool

        val find : Coq_regex_as_UCT.t -> 'a1 tree -> 'a1 option

        val create : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

        val assert_false : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

        val bal : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

        val add : key -> 'a1 -> 'a1 tree -> 'a1 tree

        val remove_min :
          'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree * (key * 'a1)

        val merge : 'a1 tree -> 'a1 tree -> 'a1 tree

        val remove : Coq_regex_as_UCT.t -> 'a1 tree -> 'a1 tree

        val join : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

        type 'elt triple = 'elt R.Defs.Coq_reFM.Raw.triple = { t_left : 
                                                               'elt tree;
                                                               t_opt : 
                                                               'elt option;
                                                               t_right : 
                                                               'elt tree }

        val t_left : 'a1 triple -> 'a1 tree

        val t_opt : 'a1 triple -> 'a1 option

        val t_right : 'a1 triple -> 'a1 tree

        val split : Coq_regex_as_UCT.t -> 'a1 tree -> 'a1 triple

        val concat : 'a1 tree -> 'a1 tree -> 'a1 tree

        val elements_aux : (key * 'a1) list -> 'a1 tree -> (key * 'a1) list

        val elements : 'a1 tree -> (key * 'a1) list

        val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

        type 'elt enumeration = 'elt R.Defs.Coq_reFM.Raw.enumeration =
        | End
        | More of key * 'elt * 'elt tree * 'elt enumeration

        val enumeration_rect :
          'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 -> 'a2) ->
          'a1 enumeration -> 'a2

        val enumeration_rec :
          'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 -> 'a2) ->
          'a1 enumeration -> 'a2

        val cons : 'a1 tree -> 'a1 enumeration -> 'a1 enumeration

        val equal_more :
          ('a1 -> 'a1 -> bool) -> Coq_regex_as_UCT.t -> 'a1 -> ('a1
          enumeration -> bool) -> 'a1 enumeration -> bool

        val equal_cont :
          ('a1 -> 'a1 -> bool) -> 'a1 tree -> ('a1 enumeration -> bool) ->
          'a1 enumeration -> bool

        val equal_end : 'a1 enumeration -> bool

        val equal : ('a1 -> 'a1 -> bool) -> 'a1 tree -> 'a1 tree -> bool

        val map : ('a1 -> 'a2) -> 'a1 tree -> 'a2 tree

        val mapi : (key -> 'a1 -> 'a2) -> 'a1 tree -> 'a2 tree

        val map_option : (key -> 'a1 -> 'a2 option) -> 'a1 tree -> 'a2 tree

        val map2_opt :
          (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3 tree)
          -> ('a2 tree -> 'a3 tree) -> 'a1 tree -> 'a2 tree -> 'a3 tree

        val map2 :
          ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 tree -> 'a2 tree ->
          'a3 tree

        module Proofs :
         sig
          module MX :
           sig
            module TO :
             sig
              type t = Coq_regex_as_UCT.t
             end

            module IsTO :
             sig
             end

            module OrderTac :
             sig
             end

            val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

            val lt_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

            val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
           end

          module PX :
           sig
            module MO :
             sig
              module TO :
               sig
                type t = Coq_regex_as_UCT.t
               end

              module IsTO :
               sig
               end

              module OrderTac :
               sig
               end

              val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

              val lt_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

              val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
             end
           end

          module L :
           sig
            module MX :
             sig
              module TO :
               sig
                type t = Coq_regex_as_UCT.t
               end

              module IsTO :
               sig
               end

              module OrderTac :
               sig
               end

              val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

              val lt_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

              val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
             end

            module PX :
             sig
              module MO :
               sig
                module TO :
                 sig
                  type t = Coq_regex_as_UCT.t
                 end

                module IsTO :
                 sig
                 end

                module OrderTac :
                 sig
                 end

                val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                val lt_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
               end
             end

            type key = Coq_regex_as_UCT.t

            type 'elt t = (Coq_regex_as_UCT.t * 'elt) list

            val empty : 'a1 t

            val is_empty : 'a1 t -> bool

            val mem : key -> 'a1 t -> bool

            type 'elt coq_R_mem = 'elt R.Defs.Coq_reFM.Raw.Proofs.L.coq_R_mem =
            | R_mem_0 of 'elt t
            | R_mem_1 of 'elt t * Coq_regex_as_UCT.t * 'elt
               * (Coq_regex_as_UCT.t * 'elt) list
            | R_mem_2 of 'elt t * Coq_regex_as_UCT.t * 'elt
               * (Coq_regex_as_UCT.t * 'elt) list
            | R_mem_3 of 'elt t * Coq_regex_as_UCT.t * 'elt
               * (Coq_regex_as_UCT.t * 'elt) list * bool * 'elt coq_R_mem

            val coq_R_mem_rect :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
              'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> bool ->
              'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 t -> bool -> 'a1 coq_R_mem
              -> 'a2

            val coq_R_mem_rec :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
              'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> bool ->
              'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 t -> bool -> 'a1 coq_R_mem
              -> 'a2

            val mem_rect :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
              'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
              'a2) -> 'a1 t -> 'a2

            val mem_rec :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
              'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
              'a2) -> 'a1 t -> 'a2

            val coq_R_mem_correct : key -> 'a1 t -> bool -> 'a1 coq_R_mem

            val find : key -> 'a1 t -> 'a1 option

            type 'elt coq_R_find = 'elt R.Defs.Coq_reFM.Raw.Proofs.L.coq_R_find =
            | R_find_0 of 'elt t
            | R_find_1 of 'elt t * Coq_regex_as_UCT.t * 'elt
               * (Coq_regex_as_UCT.t * 'elt) list
            | R_find_2 of 'elt t * Coq_regex_as_UCT.t * 'elt
               * (Coq_regex_as_UCT.t * 'elt) list
            | R_find_3 of 'elt t * Coq_regex_as_UCT.t * 'elt
               * (Coq_regex_as_UCT.t * 'elt) list * 'elt option
               * 'elt coq_R_find

            val coq_R_find_rect :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
              'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1 option
              -> 'a1 coq_R_find -> 'a2 -> 'a2) -> 'a1 t -> 'a1 option -> 'a1
              coq_R_find -> 'a2

            val coq_R_find_rec :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
              'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1 option
              -> 'a1 coq_R_find -> 'a2 -> 'a2) -> 'a1 t -> 'a1 option -> 'a1
              coq_R_find -> 'a2

            val find_rect :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
              'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
              'a2) -> 'a1 t -> 'a2

            val find_rec :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
              'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
              'a2) -> 'a1 t -> 'a2

            val coq_R_find_correct :
              key -> 'a1 t -> 'a1 option -> 'a1 coq_R_find

            val add : key -> 'a1 -> 'a1 t -> 'a1 t

            type 'elt coq_R_add = 'elt R.Defs.Coq_reFM.Raw.Proofs.L.coq_R_add =
            | R_add_0 of 'elt t
            | R_add_1 of 'elt t * Coq_regex_as_UCT.t * 'elt
               * (Coq_regex_as_UCT.t * 'elt) list
            | R_add_2 of 'elt t * Coq_regex_as_UCT.t * 'elt
               * (Coq_regex_as_UCT.t * 'elt) list
            | R_add_3 of 'elt t * Coq_regex_as_UCT.t * 'elt
               * (Coq_regex_as_UCT.t * 'elt) list * 'elt t * 'elt coq_R_add

            val coq_R_add_rect :
              key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
              Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list ->
              __ -> __ -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1
              -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1 t ->
              'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_add
              -> 'a2

            val coq_R_add_rec :
              key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
              Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list ->
              __ -> __ -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1
              -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1 t ->
              'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_add
              -> 'a2

            val add_rect :
              key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
              Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list ->
              __ -> __ -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1
              -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
              'a2) -> 'a1 t -> 'a2

            val add_rec :
              key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
              Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list ->
              __ -> __ -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1
              -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
              'a2) -> 'a1 t -> 'a2

            val coq_R_add_correct :
              key -> 'a1 -> 'a1 t -> 'a1 t -> 'a1 coq_R_add

            val remove : key -> 'a1 t -> 'a1 t

            type 'elt coq_R_remove = 'elt R.Defs.Coq_reFM.Raw.Proofs.L.coq_R_remove =
            | R_remove_0 of 'elt t
            | R_remove_1 of 'elt t * Coq_regex_as_UCT.t * 'elt
               * (Coq_regex_as_UCT.t * 'elt) list
            | R_remove_2 of 'elt t * Coq_regex_as_UCT.t * 'elt
               * (Coq_regex_as_UCT.t * 'elt) list
            | R_remove_3 of 'elt t * Coq_regex_as_UCT.t * 'elt
               * (Coq_regex_as_UCT.t * 'elt) list * 'elt t * 'elt coq_R_remove

            val coq_R_remove_rect :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
              'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1 t ->
              'a1 coq_R_remove -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1
              coq_R_remove -> 'a2

            val coq_R_remove_rec :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
              'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1 t ->
              'a1 coq_R_remove -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1
              coq_R_remove -> 'a2

            val remove_rect :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
              'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
              'a2) -> 'a1 t -> 'a2

            val remove_rec :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
              'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
              'a2) -> 'a1 t -> 'a2

            val coq_R_remove_correct :
              key -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove

            val elements : 'a1 t -> 'a1 t

            val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

            type ('elt, 'a) coq_R_fold = ('elt, 'a) R.Defs.Coq_reFM.Raw.Proofs.L.coq_R_fold =
            | R_fold_0 of 'elt t * 'a
            | R_fold_1 of 'elt t * 'a * Coq_regex_as_UCT.t * 'elt
               * (Coq_regex_as_UCT.t * 'elt) list * 'a * ('elt, 'a) coq_R_fold

            val coq_R_fold_rect :
              (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) ->
              ('a1 t -> 'a2 -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> 'a2 -> ('a1, 'a2)
              coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a2 -> ('a1, 'a2)
              coq_R_fold -> 'a3

            val coq_R_fold_rec :
              (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) ->
              ('a1 t -> 'a2 -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> 'a2 -> ('a1, 'a2)
              coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a2 -> ('a1, 'a2)
              coq_R_fold -> 'a3

            val fold_rect :
              (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) ->
              ('a1 t -> 'a2 -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> 'a3 -> 'a3) -> 'a1 t
              -> 'a2 -> 'a3

            val fold_rec :
              (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) ->
              ('a1 t -> 'a2 -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> 'a3 -> 'a3) -> 'a1 t
              -> 'a2 -> 'a3

            val coq_R_fold_correct :
              (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2 -> ('a1, 'a2)
              coq_R_fold

            val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool

            type 'elt coq_R_equal = 'elt R.Defs.Coq_reFM.Raw.Proofs.L.coq_R_equal =
            | R_equal_0 of 'elt t * 'elt t
            | R_equal_1 of 'elt t * 'elt t * Coq_regex_as_UCT.t * 'elt
               * (Coq_regex_as_UCT.t * 'elt) list * Coq_regex_as_UCT.t * 
               'elt * (Coq_regex_as_UCT.t * 'elt) list * bool
               * 'elt coq_R_equal
            | R_equal_2 of 'elt t * 'elt t * Coq_regex_as_UCT.t * 'elt
               * (Coq_regex_as_UCT.t * 'elt) list * Coq_regex_as_UCT.t * 
               'elt * (Coq_regex_as_UCT.t * 'elt) list
               * Coq_regex_as_UCT.t compare0
            | R_equal_3 of 'elt t * 'elt t * 'elt t * 'elt t

            val coq_R_equal_rect :
              ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) ->
              ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
              bool -> 'a1 coq_R_equal -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t ->
              Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list ->
              __ -> Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
              list -> __ -> Coq_regex_as_UCT.t compare0 -> __ -> __ -> 'a2)
              -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2)
              -> 'a1 t -> 'a1 t -> bool -> 'a1 coq_R_equal -> 'a2

            val coq_R_equal_rec :
              ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) ->
              ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
              bool -> 'a1 coq_R_equal -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t ->
              Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list ->
              __ -> Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
              list -> __ -> Coq_regex_as_UCT.t compare0 -> __ -> __ -> 'a2)
              -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2)
              -> 'a1 t -> 'a1 t -> bool -> 'a1 coq_R_equal -> 'a2

            val equal_rect :
              ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) ->
              ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2
              -> 'a2) -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ ->
              Coq_regex_as_UCT.t compare0 -> __ -> __ -> 'a2) -> ('a1 t ->
              'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2) -> 'a1 t ->
              'a1 t -> 'a2

            val equal_rec :
              ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) ->
              ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2
              -> 'a2) -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ ->
              Coq_regex_as_UCT.t compare0 -> __ -> __ -> 'a2) -> ('a1 t ->
              'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2) -> 'a1 t ->
              'a1 t -> 'a2

            val coq_R_equal_correct :
              ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool -> 'a1
              coq_R_equal

            val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

            val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

            val option_cons :
              key -> 'a1 option -> (key * 'a1) list -> (key * 'a1) list

            val map2_l :
              ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a3 t

            val map2_r :
              ('a1 option -> 'a2 option -> 'a3 option) -> 'a2 t -> 'a3 t

            val map2 :
              ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t ->
              'a3 t

            val combine : 'a1 t -> 'a2 t -> ('a1 option * 'a2 option) t

            val fold_right_pair :
              ('a1 -> 'a2 -> 'a3 -> 'a3) -> ('a1 * 'a2) list -> 'a3 -> 'a3

            val map2_alt :
              ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t ->
              (key * 'a3) list

            val at_least_one :
              'a1 option -> 'a2 option -> ('a1 option * 'a2 option) option

            val at_least_one_then_f :
              ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 option -> 'a2
              option -> 'a3 option
           end

          type 'elt coq_R_mem = 'elt R.Defs.Coq_reFM.Raw.Proofs.coq_R_mem =
          | R_mem_0 of 'elt tree
          | R_mem_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * bool * 'elt coq_R_mem
          | R_mem_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t
          | R_mem_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * bool * 'elt coq_R_mem

          val coq_R_mem_rect :
            Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) ->
            ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
            __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1
            tree -> bool -> 'a1 coq_R_mem -> 'a2

          val coq_R_mem_rec :
            Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) ->
            ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
            __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1
            tree -> bool -> 'a1 coq_R_mem -> 'a2

          type 'elt coq_R_find = 'elt R.Defs.Coq_reFM.Raw.Proofs.coq_R_find =
          | R_find_0 of 'elt tree
          | R_find_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt option * 'elt coq_R_find
          | R_find_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t
          | R_find_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt option * 'elt coq_R_find

          val coq_R_find_rect :
            Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> ('a1 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find ->
            'a2 -> 'a2) -> 'a1 tree -> 'a1 option -> 'a1 coq_R_find -> 'a2

          val coq_R_find_rec :
            Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> ('a1 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find ->
            'a2 -> 'a2) -> 'a1 tree -> 'a1 option -> 'a1 coq_R_find -> 'a2

          type 'elt coq_R_bal = 'elt R.Defs.Coq_reFM.Raw.Proofs.coq_R_bal =
          | R_bal_0 of 'elt tree * key * 'elt * 'elt tree
          | R_bal_1 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
             key * 'elt * 'elt tree * Z_as_Int.t
          | R_bal_2 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
             key * 'elt * 'elt tree * Z_as_Int.t
          | R_bal_3 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
             key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 
             'elt * 'elt tree * Z_as_Int.t
          | R_bal_4 of 'elt tree * key * 'elt * 'elt tree
          | R_bal_5 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
             key * 'elt * 'elt tree * Z_as_Int.t
          | R_bal_6 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
             key * 'elt * 'elt tree * Z_as_Int.t
          | R_bal_7 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
             key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 
             'elt * 'elt tree * Z_as_Int.t
          | R_bal_8 of 'elt tree * key * 'elt * 'elt tree

          val coq_R_bal_rect :
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> 'a2) ->
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) ->
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> __ ->
            'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2) ->
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> __
            -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __
            -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
            -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __
            -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key ->
            'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1
            -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> key ->
            'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2) -> ('a1 tree -> key
            -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a2) -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_bal -> 'a2

          val coq_R_bal_rec :
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> 'a2) ->
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) ->
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> __ ->
            'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2) ->
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> __
            -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __
            -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
            -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __
            -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key ->
            'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1
            -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> key ->
            'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2) -> ('a1 tree -> key
            -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a2) -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_bal -> 'a2

          type 'elt coq_R_add = 'elt R.Defs.Coq_reFM.Raw.Proofs.coq_R_add =
          | R_add_0 of 'elt tree
          | R_add_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt tree * 'elt coq_R_add
          | R_add_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t
          | R_add_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt tree * 'elt coq_R_add

          val coq_R_add_rect :
            key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
            tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) ->
            ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
            __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1
            tree -> 'a1 tree -> 'a1 coq_R_add -> 'a2

          val coq_R_add_rec :
            key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
            tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) ->
            ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
            __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1
            tree -> 'a1 tree -> 'a1 coq_R_add -> 'a2

          type 'elt coq_R_remove_min = 'elt R.Defs.Coq_reFM.Raw.Proofs.coq_R_remove_min =
          | R_remove_min_0 of 'elt tree * key * 'elt * 'elt tree
          | R_remove_min_1 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
             * key * 'elt * 'elt tree * Z_as_Int.t
             * ('elt tree * (key * 'elt)) * 'elt coq_R_remove_min * 'elt tree
             * (key * 'elt)

          val coq_R_remove_min_rect :
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1 tree ->
            key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> ('a1 tree * (key * 'a1)) -> 'a1
            coq_R_remove_min -> 'a2 -> 'a1 tree -> (key * 'a1) -> __ -> 'a2)
            -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> ('a1 tree * (key * 'a1))
            -> 'a1 coq_R_remove_min -> 'a2

          val coq_R_remove_min_rec :
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1 tree ->
            key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> ('a1 tree * (key * 'a1)) -> 'a1
            coq_R_remove_min -> 'a2 -> 'a1 tree -> (key * 'a1) -> __ -> 'a2)
            -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> ('a1 tree * (key * 'a1))
            -> 'a1 coq_R_remove_min -> 'a2

          type 'elt coq_R_merge = 'elt R.Defs.Coq_reFM.Raw.Proofs.coq_R_merge =
          | R_merge_0 of 'elt tree * 'elt tree
          | R_merge_1 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
             * 'elt tree * Z_as_Int.t
          | R_merge_2 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
             * 'elt tree * Z_as_Int.t * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt tree * (key * 'elt) * key * 'elt

          val coq_R_merge_rect :
            ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
            'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
            tree -> Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> key -> 'a1
            -> __ -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 tree -> 'a1
            coq_R_merge -> 'a2

          val coq_R_merge_rec :
            ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
            'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
            tree -> Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> key -> 'a1
            -> __ -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 tree -> 'a1
            coq_R_merge -> 'a2

          type 'elt coq_R_remove = 'elt R.Defs.Coq_reFM.Raw.Proofs.coq_R_remove =
          | R_remove_0 of 'elt tree
          | R_remove_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt tree * 'elt coq_R_remove
          | R_remove_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t
          | R_remove_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt tree * 'elt coq_R_remove

          val coq_R_remove_rect :
            Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> ('a1 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove ->
            'a2 -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_remove -> 'a2

          val coq_R_remove_rec :
            Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> ('a1 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove ->
            'a2 -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_remove -> 'a2

          type 'elt coq_R_concat = 'elt R.Defs.Coq_reFM.Raw.Proofs.coq_R_concat =
          | R_concat_0 of 'elt tree * 'elt tree
          | R_concat_1 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
             * 'elt tree * Z_as_Int.t
          | R_concat_2 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
             * 'elt tree * Z_as_Int.t * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt tree * (key * 'elt)

          val coq_R_concat_rect :
            ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
            'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
            tree -> Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> 'a2) -> 'a1
            tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_concat -> 'a2

          val coq_R_concat_rec :
            ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
            'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
            tree -> Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> 'a2) -> 'a1
            tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_concat -> 'a2

          type 'elt coq_R_split = 'elt R.Defs.Coq_reFM.Raw.Proofs.coq_R_split =
          | R_split_0 of 'elt tree
          | R_split_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt triple * 'elt coq_R_split * 'elt tree
             * 'elt option * 'elt tree
          | R_split_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t
          | R_split_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt triple * 'elt coq_R_split * 'elt tree
             * 'elt option * 'elt tree

          val coq_R_split_rect :
            Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option ->
            'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 ->
            'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree ->
            'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
            __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1
            option -> 'a1 tree -> __ -> 'a2) -> 'a1 tree -> 'a1 triple -> 'a1
            coq_R_split -> 'a2

          val coq_R_split_rec :
            Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option ->
            'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 ->
            'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree ->
            'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
            __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1
            option -> 'a1 tree -> __ -> 'a2) -> 'a1 tree -> 'a1 triple -> 'a1
            coq_R_split -> 'a2

          type ('elt, 'x) coq_R_map_option = ('elt, 'x) R.Defs.Coq_reFM.Raw.Proofs.coq_R_map_option =
          | R_map_option_0 of 'elt tree
          | R_map_option_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'x * 'x tree * ('elt, 'x) coq_R_map_option
             * 'x tree * ('elt, 'x) coq_R_map_option
          | R_map_option_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'x tree * ('elt, 'x) coq_R_map_option * 'x tree
             * ('elt, 'x) coq_R_map_option

          val coq_R_map_option_rect :
            (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) -> ('a1
            tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
            'a2 -> __ -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 ->
            'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> ('a1
            tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
            __ -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2 tree
            -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> 'a1 tree -> 'a2
            tree -> ('a1, 'a2) coq_R_map_option -> 'a3

          val coq_R_map_option_rec :
            (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) -> ('a1
            tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
            'a2 -> __ -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 ->
            'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> ('a1
            tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
            __ -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2 tree
            -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> 'a1 tree -> 'a2
            tree -> ('a1, 'a2) coq_R_map_option -> 'a3

          type ('elt, 'x0, 'x) coq_R_map2_opt = ('elt, 'x0, 'x) R.Defs.Coq_reFM.Raw.Proofs.coq_R_map2_opt =
          | R_map2_opt_0 of 'elt tree * 'x0 tree
          | R_map2_opt_1 of 'elt tree * 'x0 tree * 'elt tree * key * 
             'elt * 'elt tree * Z_as_Int.t
          | R_map2_opt_2 of 'elt tree * 'x0 tree * 'elt tree * key * 
             'elt * 'elt tree * Z_as_Int.t * 'x0 tree * key * 'x0 * 'x0 tree
             * Z_as_Int.t * 'x0 tree * 'x0 option * 'x0 tree * 'x * 'x tree
             * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
             * ('elt, 'x0, 'x) coq_R_map2_opt
          | R_map2_opt_3 of 'elt tree * 'x0 tree * 'elt tree * key * 
             'elt * 'elt tree * Z_as_Int.t * 'x0 tree * key * 'x0 * 'x0 tree
             * Z_as_Int.t * 'x0 tree * 'x0 option * 'x0 tree * 'x tree
             * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
             * ('elt, 'x0, 'x) coq_R_map2_opt

          val coq_R_map2_opt_rect :
            (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3
            tree) -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2 tree -> __ ->
            'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1
            tree -> Z_as_Int.t -> __ -> __ -> 'a4) -> ('a1 tree -> 'a2 tree
            -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2
            tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ -> 'a2 tree ->
            'a2 option -> 'a2 tree -> __ -> 'a3 -> __ -> 'a3 tree -> ('a1,
            'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
            coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 tree ->
            key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2
            option -> 'a2 tree -> __ -> __ -> 'a3 tree -> ('a1, 'a2, 'a3)
            coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
            coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1 tree -> 'a2 tree -> 'a3 tree
            -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4

          val coq_R_map2_opt_rec :
            (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3
            tree) -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2 tree -> __ ->
            'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1
            tree -> Z_as_Int.t -> __ -> __ -> 'a4) -> ('a1 tree -> 'a2 tree
            -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2
            tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ -> 'a2 tree ->
            'a2 option -> 'a2 tree -> __ -> 'a3 -> __ -> 'a3 tree -> ('a1,
            'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
            coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 tree ->
            key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2
            option -> 'a2 tree -> __ -> __ -> 'a3 tree -> ('a1, 'a2, 'a3)
            coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
            coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1 tree -> 'a2 tree -> 'a3 tree
            -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4

          val fold' : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

          val flatten_e : 'a1 enumeration -> (key * 'a1) list
         end
       end

      type 'elt bst =
        'elt Raw.tree
        (* singleton inductive, whose constructor was Bst *)

      val this : 'a1 bst -> 'a1 Raw.tree

      type 'elt t = 'elt bst

      type key = Coq_regex_as_UCT.t

      val empty : 'a1 t

      val is_empty : 'a1 t -> bool

      val add : key -> 'a1 -> 'a1 t -> 'a1 t

      val remove : key -> 'a1 t -> 'a1 t

      val mem : key -> 'a1 t -> bool

      val find : key -> 'a1 t -> 'a1 option

      val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

      val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

      val map2 :
        ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t -> 'a3 t

      val elements : 'a1 t -> (key * 'a1) list

      val cardinal : 'a1 t -> nat

      val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

      val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool
     end

    module Coq_reFMF :
     sig
      val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

      val coq_In_dec : 'a1 Coq_reFM.t -> Coq_reFM.key -> bool
     end

    module MatchSpec :
     sig
     end

    module MatchSpecLemmas :
     sig
     end

    module Notations :
     sig
     end

    module Helpers :
     sig
      val coq_Plus : Regexes.regex -> Regexes.regex

      val coq_IterUnion : Regexes.regex list -> Regexes.regex

      val coq_IterApp : Regexes.regex list -> Regexes.regex

      val coq_Optional : Regexes.regex -> Regexes.regex

      val coq_REString : Strings.coq_String -> Regexes.regex
     end
   end

  module Coq_reFS :
   sig
    module X' :
     sig
      type t = DS.Coq_regex_as_UCT.t

      val eq_dec : DS.Coq_regex_as_UCT.t -> DS.Coq_regex_as_UCT.t -> bool

      val compare :
        DS.Coq_regex_as_UCT.t -> DS.Coq_regex_as_UCT.t -> comparison
     end

    module MSet :
     sig
      module Raw :
       sig
        type elt = DS.Coq_regex_as_UCT.t

        type tree = R.Defs.Coq_reFS.MSet.Raw.tree =
        | Leaf
        | Node of Z_as_Int.t * tree * DS.Coq_regex_as_UCT.t * tree

        val empty : tree

        val is_empty : tree -> bool

        val mem : DS.Coq_regex_as_UCT.t -> tree -> bool

        val min_elt : tree -> elt option

        val max_elt : tree -> elt option

        val choose : tree -> elt option

        val fold : (elt -> 'a1 -> 'a1) -> tree -> 'a1 -> 'a1

        val elements_aux :
          DS.Coq_regex_as_UCT.t list -> tree -> DS.Coq_regex_as_UCT.t list

        val elements : tree -> DS.Coq_regex_as_UCT.t list

        val rev_elements_aux :
          DS.Coq_regex_as_UCT.t list -> tree -> DS.Coq_regex_as_UCT.t list

        val rev_elements : tree -> DS.Coq_regex_as_UCT.t list

        val cardinal : tree -> nat

        val maxdepth : tree -> nat

        val mindepth : tree -> nat

        val for_all : (elt -> bool) -> tree -> bool

        val exists_ : (elt -> bool) -> tree -> bool

        type enumeration = R.Defs.Coq_reFS.MSet.Raw.enumeration =
        | End
        | More of elt * tree * enumeration

        val cons : tree -> enumeration -> enumeration

        val compare_more :
          DS.Coq_regex_as_UCT.t -> (enumeration -> comparison) -> enumeration
          -> comparison

        val compare_cont :
          tree -> (enumeration -> comparison) -> enumeration -> comparison

        val compare_end : enumeration -> comparison

        val compare : tree -> tree -> comparison

        val equal : tree -> tree -> bool

        val subsetl : (tree -> bool) -> DS.Coq_regex_as_UCT.t -> tree -> bool

        val subsetr : (tree -> bool) -> DS.Coq_regex_as_UCT.t -> tree -> bool

        val subset : tree -> tree -> bool

        type t = tree

        val height : t -> Z_as_Int.t

        val singleton : DS.Coq_regex_as_UCT.t -> tree

        val create : t -> DS.Coq_regex_as_UCT.t -> t -> tree

        val assert_false : t -> DS.Coq_regex_as_UCT.t -> t -> tree

        val bal : t -> DS.Coq_regex_as_UCT.t -> t -> tree

        val add : DS.Coq_regex_as_UCT.t -> tree -> tree

        val join : tree -> elt -> t -> t

        val remove_min : tree -> elt -> t -> t * elt

        val merge : tree -> tree -> tree

        val remove : DS.Coq_regex_as_UCT.t -> tree -> tree

        val concat : tree -> tree -> tree

        type triple = R.Defs.Coq_reFS.MSet.Raw.triple = { t_left : t;
                                                          t_in : bool;
                                                          t_right : t }

        val t_left : triple -> t

        val t_in : triple -> bool

        val t_right : triple -> t

        val split : DS.Coq_regex_as_UCT.t -> tree -> triple

        val inter : tree -> tree -> tree

        val diff : tree -> tree -> tree

        val union : tree -> tree -> tree

        val filter : (elt -> bool) -> tree -> tree

        val partition : (elt -> bool) -> t -> t * t

        val ltb_tree : DS.Coq_regex_as_UCT.t -> tree -> bool

        val gtb_tree : DS.Coq_regex_as_UCT.t -> tree -> bool

        val isok : tree -> bool

        module MX :
         sig
          module OrderTac :
           sig
            module OTF :
             sig
              type t = DS.Coq_regex_as_UCT.t

              val compare :
                DS.Coq_regex_as_UCT.t -> DS.Coq_regex_as_UCT.t -> comparison

              val eq_dec :
                DS.Coq_regex_as_UCT.t -> DS.Coq_regex_as_UCT.t -> bool
             end

            module TO :
             sig
              type t = DS.Coq_regex_as_UCT.t

              val compare :
                DS.Coq_regex_as_UCT.t -> DS.Coq_regex_as_UCT.t -> comparison

              val eq_dec :
                DS.Coq_regex_as_UCT.t -> DS.Coq_regex_as_UCT.t -> bool
             end
           end

          val eq_dec : DS.Coq_regex_as_UCT.t -> DS.Coq_regex_as_UCT.t -> bool

          val lt_dec : DS.Coq_regex_as_UCT.t -> DS.Coq_regex_as_UCT.t -> bool

          val eqb : DS.Coq_regex_as_UCT.t -> DS.Coq_regex_as_UCT.t -> bool
         end

        type coq_R_min_elt = R.Defs.Coq_reFS.MSet.Raw.coq_R_min_elt =
        | R_min_elt_0 of tree
        | R_min_elt_1 of tree * Z_as_Int.t * tree * DS.Coq_regex_as_UCT.t
           * tree
        | R_min_elt_2 of tree * Z_as_Int.t * tree * DS.Coq_regex_as_UCT.t
           * tree * Z_as_Int.t * tree * DS.Coq_regex_as_UCT.t * tree
           * elt option * coq_R_min_elt

        type coq_R_max_elt = R.Defs.Coq_reFS.MSet.Raw.coq_R_max_elt =
        | R_max_elt_0 of tree
        | R_max_elt_1 of tree * Z_as_Int.t * tree * DS.Coq_regex_as_UCT.t
           * tree
        | R_max_elt_2 of tree * Z_as_Int.t * tree * DS.Coq_regex_as_UCT.t
           * tree * Z_as_Int.t * tree * DS.Coq_regex_as_UCT.t * tree
           * elt option * coq_R_max_elt

        module L :
         sig
          module MO :
           sig
            module OrderTac :
             sig
              module OTF :
               sig
                type t = DS.Coq_regex_as_UCT.t

                val compare :
                  DS.Coq_regex_as_UCT.t -> DS.Coq_regex_as_UCT.t -> comparison

                val eq_dec :
                  DS.Coq_regex_as_UCT.t -> DS.Coq_regex_as_UCT.t -> bool
               end

              module TO :
               sig
                type t = DS.Coq_regex_as_UCT.t

                val compare :
                  DS.Coq_regex_as_UCT.t -> DS.Coq_regex_as_UCT.t -> comparison

                val eq_dec :
                  DS.Coq_regex_as_UCT.t -> DS.Coq_regex_as_UCT.t -> bool
               end
             end

            val eq_dec :
              DS.Coq_regex_as_UCT.t -> DS.Coq_regex_as_UCT.t -> bool

            val lt_dec :
              DS.Coq_regex_as_UCT.t -> DS.Coq_regex_as_UCT.t -> bool

            val eqb : DS.Coq_regex_as_UCT.t -> DS.Coq_regex_as_UCT.t -> bool
           end
         end

        val flatten_e : enumeration -> elt list

        type coq_R_bal = R.Defs.Coq_reFS.MSet.Raw.coq_R_bal =
        | R_bal_0 of t * DS.Coq_regex_as_UCT.t * t
        | R_bal_1 of t * DS.Coq_regex_as_UCT.t * t * Z_as_Int.t * tree
           * DS.Coq_regex_as_UCT.t * tree
        | R_bal_2 of t * DS.Coq_regex_as_UCT.t * t * Z_as_Int.t * tree
           * DS.Coq_regex_as_UCT.t * tree
        | R_bal_3 of t * DS.Coq_regex_as_UCT.t * t * Z_as_Int.t * tree
           * DS.Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
           * DS.Coq_regex_as_UCT.t * tree
        | R_bal_4 of t * DS.Coq_regex_as_UCT.t * t
        | R_bal_5 of t * DS.Coq_regex_as_UCT.t * t * Z_as_Int.t * tree
           * DS.Coq_regex_as_UCT.t * tree
        | R_bal_6 of t * DS.Coq_regex_as_UCT.t * t * Z_as_Int.t * tree
           * DS.Coq_regex_as_UCT.t * tree
        | R_bal_7 of t * DS.Coq_regex_as_UCT.t * t * Z_as_Int.t * tree
           * DS.Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
           * DS.Coq_regex_as_UCT.t * tree
        | R_bal_8 of t * DS.Coq_regex_as_UCT.t * t

        type coq_R_remove_min = R.Defs.Coq_reFS.MSet.Raw.coq_R_remove_min =
        | R_remove_min_0 of tree * elt * t
        | R_remove_min_1 of tree * elt * t * Z_as_Int.t * tree
           * DS.Coq_regex_as_UCT.t * tree * (t * elt) * coq_R_remove_min * 
           t * elt

        type coq_R_merge = R.Defs.Coq_reFS.MSet.Raw.coq_R_merge =
        | R_merge_0 of tree * tree
        | R_merge_1 of tree * tree * Z_as_Int.t * tree
           * DS.Coq_regex_as_UCT.t * tree
        | R_merge_2 of tree * tree * Z_as_Int.t * tree
           * DS.Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
           * DS.Coq_regex_as_UCT.t * tree * t * elt

        type coq_R_concat = R.Defs.Coq_reFS.MSet.Raw.coq_R_concat =
        | R_concat_0 of tree * tree
        | R_concat_1 of tree * tree * Z_as_Int.t * tree
           * DS.Coq_regex_as_UCT.t * tree
        | R_concat_2 of tree * tree * Z_as_Int.t * tree
           * DS.Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
           * DS.Coq_regex_as_UCT.t * tree * t * elt

        type coq_R_inter = R.Defs.Coq_reFS.MSet.Raw.coq_R_inter =
        | R_inter_0 of tree * tree
        | R_inter_1 of tree * tree * Z_as_Int.t * tree
           * DS.Coq_regex_as_UCT.t * tree
        | R_inter_2 of tree * tree * Z_as_Int.t * tree
           * DS.Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
           * DS.Coq_regex_as_UCT.t * tree * t * bool * t * tree * coq_R_inter
           * tree * coq_R_inter
        | R_inter_3 of tree * tree * Z_as_Int.t * tree
           * DS.Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
           * DS.Coq_regex_as_UCT.t * tree * t * bool * t * tree * coq_R_inter
           * tree * coq_R_inter

        type coq_R_diff = R.Defs.Coq_reFS.MSet.Raw.coq_R_diff =
        | R_diff_0 of tree * tree
        | R_diff_1 of tree * tree * Z_as_Int.t * tree * DS.Coq_regex_as_UCT.t
           * tree
        | R_diff_2 of tree * tree * Z_as_Int.t * tree * DS.Coq_regex_as_UCT.t
           * tree * Z_as_Int.t * tree * DS.Coq_regex_as_UCT.t * tree * 
           t * bool * t * tree * coq_R_diff * tree * coq_R_diff
        | R_diff_3 of tree * tree * Z_as_Int.t * tree * DS.Coq_regex_as_UCT.t
           * tree * Z_as_Int.t * tree * DS.Coq_regex_as_UCT.t * tree * 
           t * bool * t * tree * coq_R_diff * tree * coq_R_diff

        type coq_R_union = R.Defs.Coq_reFS.MSet.Raw.coq_R_union =
        | R_union_0 of tree * tree
        | R_union_1 of tree * tree * Z_as_Int.t * tree
           * DS.Coq_regex_as_UCT.t * tree
        | R_union_2 of tree * tree * Z_as_Int.t * tree
           * DS.Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
           * DS.Coq_regex_as_UCT.t * tree * t * bool * t * tree * coq_R_union
           * tree * coq_R_union
       end

      module E :
       sig
        type t = DS.Coq_regex_as_UCT.t

        val compare :
          DS.Coq_regex_as_UCT.t -> DS.Coq_regex_as_UCT.t -> comparison

        val eq_dec : DS.Coq_regex_as_UCT.t -> DS.Coq_regex_as_UCT.t -> bool
       end

      type elt = DS.Coq_regex_as_UCT.t

      type t_ = Raw.t
        (* singleton inductive, whose constructor was Mkt *)

      val this : t_ -> Raw.t

      type t = t_

      val mem : elt -> t -> bool

      val add : elt -> t -> t

      val remove : elt -> t -> t

      val singleton : elt -> t

      val union : t -> t -> t

      val inter : t -> t -> t

      val diff : t -> t -> t

      val equal : t -> t -> bool

      val subset : t -> t -> bool

      val empty : t

      val is_empty : t -> bool

      val elements : t -> elt list

      val choose : t -> elt option

      val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

      val cardinal : t -> nat

      val filter : (elt -> bool) -> t -> t

      val for_all : (elt -> bool) -> t -> bool

      val exists_ : (elt -> bool) -> t -> bool

      val partition : (elt -> bool) -> t -> t * t

      val eq_dec : t -> t -> bool

      val compare : t -> t -> comparison

      val min_elt : t -> elt option

      val max_elt : t -> elt option
     end

    type elt = DS.Coq_regex_as_UCT.t

    type t = MSet.t

    val empty : t

    val is_empty : t -> bool

    val mem : elt -> t -> bool

    val add : elt -> t -> t

    val singleton : elt -> t

    val remove : elt -> t -> t

    val union : t -> t -> t

    val inter : t -> t -> t

    val diff : t -> t -> t

    val eq_dec : t -> t -> bool

    val equal : t -> t -> bool

    val subset : t -> t -> bool

    val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

    val for_all : (elt -> bool) -> t -> bool

    val exists_ : (elt -> bool) -> t -> bool

    val filter : (elt -> bool) -> t -> t

    val partition : (elt -> bool) -> t -> t * t

    val cardinal : t -> nat

    val elements : t -> elt list

    val choose : t -> elt option

    module MF :
     sig
      val eqb : DS.Coq_regex_as_UCT.t -> DS.Coq_regex_as_UCT.t -> bool
     end

    val min_elt : t -> elt option

    val max_elt : t -> elt option

    val compare : t -> t -> t compare0

    module E :
     sig
      type t = DS.Coq_regex_as_UCT.t

      val compare :
        DS.Coq_regex_as_UCT.t -> DS.Coq_regex_as_UCT.t ->
        DS.Coq_regex_as_UCT.t compare0

      val eq_dec : DS.Coq_regex_as_UCT.t -> DS.Coq_regex_as_UCT.t -> bool
     end
   end

  type coq_Table

  val emptyTable : coq_Table

  val set_Table :
    coq_Table -> DS.Regexes.regex -> R.Ty.coq_Sigma -> DS.Regexes.regex ->
    coq_Table

  val get_Table :
    coq_Table -> DS.Regexes.regex -> R.Ty.coq_Sigma -> DS.Regexes.regex option

  val add_state : coq_Table -> DS.Regexes.regex -> coq_Table

  val get_states : coq_Table -> Coq_reFS.t

  val get_eq : coq_Table -> DS.Regexes.regex -> DS.Regexes.regex option
 end) ->
 sig
  module FillTable :
   sig
    val mkIterUnion' : R.Defs.Regexes.regex -> R.Defs.Regexes.regex list

    val merge' :
      R.Defs.Regexes.regex list -> R.Defs.Regexes.regex list ->
      R.Defs.Regexes.regex list

    val merge'' :
      R.Defs.Regexes.regex list -> R.Defs.Regexes.regex list ->
      R.Defs.Regexes.regex list

    val merge :
      R.Defs.Regexes.regex list -> R.Defs.Regexes.regex list ->
      R.Defs.Regexes.regex list

    val mkIterApp' : R.Defs.Regexes.regex -> R.Defs.Regexes.regex list

    val canon : R.Defs.Regexes.regex -> R.Defs.Regexes.regex

    val fill_Table_all'' :
      TabTy.coq_Table -> R.Defs.Regexes.regex -> R.Ty.coq_Sigma list -> nat
      -> TabTy.coq_Table

    val fill_Table_all' :
      TabTy.coq_Table -> R.Defs.Regexes.regex -> R.Ty.coq_Sigma list -> nat
      -> TabTy.coq_Table

    val fill_Table_all :
      TabTy.coq_Table -> R.Defs.Regexes.regex -> R.Ty.coq_Sigma list -> nat
      -> TabTy.coq_Table

    val traverse_pos' : positive -> positive

    val traverse_pos : positive -> positive

    val fill_Table_all'_bin :
      TabTy.coq_Table -> R.Defs.Regexes.regex -> R.Ty.coq_Sigma list ->
      positive -> TabTy.coq_Table

    val fill_Table_all_bin :
      TabTy.coq_Table -> R.Defs.Regexes.regex -> R.Ty.coq_Sigma list ->
      positive -> TabTy.coq_Table
   end

  module Spec :
   sig
   end

  module Correct :
   sig
   end

  module Coq_binary :
   sig
   end
 end

module type Coq0_T =
 sig
  module R :
   T

  module TabTy :
   sig
    module DS :
     sig
      module T_as_UCT :
       sig
        type t = R.Ty.coq_Sigma

        val compare : R.Ty.coq_Sigma -> R.Ty.coq_Sigma -> comparison
       end

      module T_as_UOT :
       sig
        type t = T_as_UCT.t

        val compare : t -> t -> t compare0

        val eq_dec : t -> t -> bool
       end

      module SigFS :
       sig
        module X' :
         sig
          type t = T_as_UCT.t

          val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

          val compare : T_as_UCT.t -> T_as_UCT.t -> comparison
         end

        module MSet :
         sig
          module Raw :
           sig
            type elt = T_as_UCT.t

            type tree = R.Defs.SigFS.MSet.Raw.tree =
            | Leaf
            | Node of Z_as_Int.t * tree * T_as_UCT.t * tree

            val empty : tree

            val is_empty : tree -> bool

            val mem : T_as_UCT.t -> tree -> bool

            val min_elt : tree -> elt option

            val max_elt : tree -> elt option

            val choose : tree -> elt option

            val fold : (elt -> 'a1 -> 'a1) -> tree -> 'a1 -> 'a1

            val elements_aux : T_as_UCT.t list -> tree -> T_as_UCT.t list

            val elements : tree -> T_as_UCT.t list

            val rev_elements_aux : T_as_UCT.t list -> tree -> T_as_UCT.t list

            val rev_elements : tree -> T_as_UCT.t list

            val cardinal : tree -> nat

            val maxdepth : tree -> nat

            val mindepth : tree -> nat

            val for_all : (elt -> bool) -> tree -> bool

            val exists_ : (elt -> bool) -> tree -> bool

            type enumeration = R.Defs.SigFS.MSet.Raw.enumeration =
            | End
            | More of elt * tree * enumeration

            val cons : tree -> enumeration -> enumeration

            val compare_more :
              T_as_UCT.t -> (enumeration -> comparison) -> enumeration ->
              comparison

            val compare_cont :
              tree -> (enumeration -> comparison) -> enumeration -> comparison

            val compare_end : enumeration -> comparison

            val compare : tree -> tree -> comparison

            val equal : tree -> tree -> bool

            val subsetl : (tree -> bool) -> T_as_UCT.t -> tree -> bool

            val subsetr : (tree -> bool) -> T_as_UCT.t -> tree -> bool

            val subset : tree -> tree -> bool

            type t = tree

            val height : t -> Z_as_Int.t

            val singleton : T_as_UCT.t -> tree

            val create : t -> T_as_UCT.t -> t -> tree

            val assert_false : t -> T_as_UCT.t -> t -> tree

            val bal : t -> T_as_UCT.t -> t -> tree

            val add : T_as_UCT.t -> tree -> tree

            val join : tree -> elt -> t -> t

            val remove_min : tree -> elt -> t -> t * elt

            val merge : tree -> tree -> tree

            val remove : T_as_UCT.t -> tree -> tree

            val concat : tree -> tree -> tree

            type triple = R.Defs.SigFS.MSet.Raw.triple = { t_left : t;
                                                           t_in : bool;
                                                           t_right : 
                                                           t }

            val t_left : triple -> t

            val t_in : triple -> bool

            val t_right : triple -> t

            val split : T_as_UCT.t -> tree -> triple

            val inter : tree -> tree -> tree

            val diff : tree -> tree -> tree

            val union : tree -> tree -> tree

            val filter : (elt -> bool) -> tree -> tree

            val partition : (elt -> bool) -> t -> t * t

            val ltb_tree : T_as_UCT.t -> tree -> bool

            val gtb_tree : T_as_UCT.t -> tree -> bool

            val isok : tree -> bool

            module MX :
             sig
              module OrderTac :
               sig
                module OTF :
                 sig
                  type t = T_as_UCT.t

                  val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

                  val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
                 end

                module TO :
                 sig
                  type t = T_as_UCT.t

                  val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

                  val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
                 end
               end

              val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

              val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

              val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
             end

            type coq_R_min_elt = R.Defs.SigFS.MSet.Raw.coq_R_min_elt =
            | R_min_elt_0 of tree
            | R_min_elt_1 of tree * Z_as_Int.t * tree * T_as_UCT.t * tree
            | R_min_elt_2 of tree * Z_as_Int.t * tree * T_as_UCT.t * 
               tree * Z_as_Int.t * tree * T_as_UCT.t * tree * elt option
               * coq_R_min_elt

            type coq_R_max_elt = R.Defs.SigFS.MSet.Raw.coq_R_max_elt =
            | R_max_elt_0 of tree
            | R_max_elt_1 of tree * Z_as_Int.t * tree * T_as_UCT.t * tree
            | R_max_elt_2 of tree * Z_as_Int.t * tree * T_as_UCT.t * 
               tree * Z_as_Int.t * tree * T_as_UCT.t * tree * elt option
               * coq_R_max_elt

            module L :
             sig
              module MO :
               sig
                module OrderTac :
                 sig
                  module OTF :
                   sig
                    type t = T_as_UCT.t

                    val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

                    val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
                   end

                  module TO :
                   sig
                    type t = T_as_UCT.t

                    val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

                    val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
                   end
                 end

                val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
               end
             end

            val flatten_e : enumeration -> elt list

            type coq_R_bal = R.Defs.SigFS.MSet.Raw.coq_R_bal =
            | R_bal_0 of t * T_as_UCT.t * t
            | R_bal_1 of t * T_as_UCT.t * t * Z_as_Int.t * tree * T_as_UCT.t
               * tree
            | R_bal_2 of t * T_as_UCT.t * t * Z_as_Int.t * tree * T_as_UCT.t
               * tree
            | R_bal_3 of t * T_as_UCT.t * t * Z_as_Int.t * tree * T_as_UCT.t
               * tree * Z_as_Int.t * tree * T_as_UCT.t * tree
            | R_bal_4 of t * T_as_UCT.t * t
            | R_bal_5 of t * T_as_UCT.t * t * Z_as_Int.t * tree * T_as_UCT.t
               * tree
            | R_bal_6 of t * T_as_UCT.t * t * Z_as_Int.t * tree * T_as_UCT.t
               * tree
            | R_bal_7 of t * T_as_UCT.t * t * Z_as_Int.t * tree * T_as_UCT.t
               * tree * Z_as_Int.t * tree * T_as_UCT.t * tree
            | R_bal_8 of t * T_as_UCT.t * t

            type coq_R_remove_min = R.Defs.SigFS.MSet.Raw.coq_R_remove_min =
            | R_remove_min_0 of tree * elt * t
            | R_remove_min_1 of tree * elt * t * Z_as_Int.t * tree
               * T_as_UCT.t * tree * (t * elt) * coq_R_remove_min * t * 
               elt

            type coq_R_merge = R.Defs.SigFS.MSet.Raw.coq_R_merge =
            | R_merge_0 of tree * tree
            | R_merge_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * tree
            | R_merge_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
               * tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * elt

            type coq_R_concat = R.Defs.SigFS.MSet.Raw.coq_R_concat =
            | R_concat_0 of tree * tree
            | R_concat_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
               * tree
            | R_concat_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
               * tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * elt

            type coq_R_inter = R.Defs.SigFS.MSet.Raw.coq_R_inter =
            | R_inter_0 of tree * tree
            | R_inter_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * tree
            | R_inter_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
               * tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * bool * 
               t * tree * coq_R_inter * tree * coq_R_inter
            | R_inter_3 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
               * tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * bool * 
               t * tree * coq_R_inter * tree * coq_R_inter

            type coq_R_diff = R.Defs.SigFS.MSet.Raw.coq_R_diff =
            | R_diff_0 of tree * tree
            | R_diff_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * tree
            | R_diff_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * 
               tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * bool * 
               t * tree * coq_R_diff * tree * coq_R_diff
            | R_diff_3 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * 
               tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * bool * 
               t * tree * coq_R_diff * tree * coq_R_diff

            type coq_R_union = R.Defs.SigFS.MSet.Raw.coq_R_union =
            | R_union_0 of tree * tree
            | R_union_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * tree
            | R_union_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
               * tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * bool * 
               t * tree * coq_R_union * tree * coq_R_union
           end

          module E :
           sig
            type t = T_as_UCT.t

            val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

            val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
           end

          type elt = T_as_UCT.t

          type t_ = Raw.t
            (* singleton inductive, whose constructor was Mkt *)

          val this : t_ -> Raw.t

          type t = t_

          val mem : elt -> t -> bool

          val add : elt -> t -> t

          val remove : elt -> t -> t

          val singleton : elt -> t

          val union : t -> t -> t

          val inter : t -> t -> t

          val diff : t -> t -> t

          val equal : t -> t -> bool

          val subset : t -> t -> bool

          val empty : t

          val is_empty : t -> bool

          val elements : t -> elt list

          val choose : t -> elt option

          val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

          val cardinal : t -> nat

          val filter : (elt -> bool) -> t -> t

          val for_all : (elt -> bool) -> t -> bool

          val exists_ : (elt -> bool) -> t -> bool

          val partition : (elt -> bool) -> t -> t * t

          val eq_dec : t -> t -> bool

          val compare : t -> t -> comparison

          val min_elt : t -> elt option

          val max_elt : t -> elt option
         end

        type elt = T_as_UCT.t

        type t = MSet.t

        val empty : t

        val is_empty : t -> bool

        val mem : elt -> t -> bool

        val add : elt -> t -> t

        val singleton : elt -> t

        val remove : elt -> t -> t

        val union : t -> t -> t

        val inter : t -> t -> t

        val diff : t -> t -> t

        val eq_dec : t -> t -> bool

        val equal : t -> t -> bool

        val subset : t -> t -> bool

        val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

        val for_all : (elt -> bool) -> t -> bool

        val exists_ : (elt -> bool) -> t -> bool

        val filter : (elt -> bool) -> t -> t

        val partition : (elt -> bool) -> t -> t * t

        val cardinal : t -> nat

        val elements : t -> elt list

        val choose : t -> elt option

        module MF :
         sig
          val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
         end

        val min_elt : t -> elt option

        val max_elt : t -> elt option

        val compare : t -> t -> t compare0

        module E :
         sig
          type t = T_as_UCT.t

          val compare : T_as_UCT.t -> T_as_UCT.t -> T_as_UCT.t compare0

          val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
         end
       end

      module SigFSF :
       sig
        val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
       end

      module SigFM :
       sig
        module E :
         sig
          type t = T_as_UCT.t

          val compare : T_as_UCT.t -> T_as_UCT.t -> T_as_UCT.t compare0

          val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
         end

        module Raw :
         sig
          type key = T_as_UCT.t

          type 'elt tree = 'elt R.Defs.SigFM.Raw.tree =
          | Leaf
          | Node of 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t

          val tree_rect :
            'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
            Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

          val tree_rec :
            'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
            Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

          val height : 'a1 tree -> Z_as_Int.t

          val cardinal : 'a1 tree -> nat

          val empty : 'a1 tree

          val is_empty : 'a1 tree -> bool

          val mem : T_as_UCT.t -> 'a1 tree -> bool

          val find : T_as_UCT.t -> 'a1 tree -> 'a1 option

          val create : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

          val assert_false : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

          val bal : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

          val add : key -> 'a1 -> 'a1 tree -> 'a1 tree

          val remove_min :
            'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree * (key * 'a1)

          val merge : 'a1 tree -> 'a1 tree -> 'a1 tree

          val remove : T_as_UCT.t -> 'a1 tree -> 'a1 tree

          val join : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

          type 'elt triple = 'elt R.Defs.SigFM.Raw.triple = { t_left : 
                                                              'elt tree;
                                                              t_opt : 
                                                              'elt option;
                                                              t_right : 
                                                              'elt tree }

          val t_left : 'a1 triple -> 'a1 tree

          val t_opt : 'a1 triple -> 'a1 option

          val t_right : 'a1 triple -> 'a1 tree

          val split : T_as_UCT.t -> 'a1 tree -> 'a1 triple

          val concat : 'a1 tree -> 'a1 tree -> 'a1 tree

          val elements_aux : (key * 'a1) list -> 'a1 tree -> (key * 'a1) list

          val elements : 'a1 tree -> (key * 'a1) list

          val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

          type 'elt enumeration = 'elt R.Defs.SigFM.Raw.enumeration =
          | End
          | More of key * 'elt * 'elt tree * 'elt enumeration

          val enumeration_rect :
            'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 -> 'a2)
            -> 'a1 enumeration -> 'a2

          val enumeration_rec :
            'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 -> 'a2)
            -> 'a1 enumeration -> 'a2

          val cons : 'a1 tree -> 'a1 enumeration -> 'a1 enumeration

          val equal_more :
            ('a1 -> 'a1 -> bool) -> T_as_UCT.t -> 'a1 -> ('a1 enumeration ->
            bool) -> 'a1 enumeration -> bool

          val equal_cont :
            ('a1 -> 'a1 -> bool) -> 'a1 tree -> ('a1 enumeration -> bool) ->
            'a1 enumeration -> bool

          val equal_end : 'a1 enumeration -> bool

          val equal : ('a1 -> 'a1 -> bool) -> 'a1 tree -> 'a1 tree -> bool

          val map : ('a1 -> 'a2) -> 'a1 tree -> 'a2 tree

          val mapi : (key -> 'a1 -> 'a2) -> 'a1 tree -> 'a2 tree

          val map_option : (key -> 'a1 -> 'a2 option) -> 'a1 tree -> 'a2 tree

          val map2_opt :
            (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3
            tree) -> ('a2 tree -> 'a3 tree) -> 'a1 tree -> 'a2 tree -> 'a3
            tree

          val map2 :
            ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 tree -> 'a2 tree
            -> 'a3 tree

          module Proofs :
           sig
            module MX :
             sig
              module TO :
               sig
                type t = T_as_UCT.t
               end

              module IsTO :
               sig
               end

              module OrderTac :
               sig
               end

              val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

              val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

              val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
             end

            module PX :
             sig
              module MO :
               sig
                module TO :
                 sig
                  type t = T_as_UCT.t
                 end

                module IsTO :
                 sig
                 end

                module OrderTac :
                 sig
                 end

                val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
               end
             end

            module L :
             sig
              module MX :
               sig
                module TO :
                 sig
                  type t = T_as_UCT.t
                 end

                module IsTO :
                 sig
                 end

                module OrderTac :
                 sig
                 end

                val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
               end

              module PX :
               sig
                module MO :
                 sig
                  module TO :
                   sig
                    type t = T_as_UCT.t
                   end

                  module IsTO :
                   sig
                   end

                  module OrderTac :
                   sig
                   end

                  val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                  val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                  val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
                 end
               end

              type key = T_as_UCT.t

              type 'elt t = (T_as_UCT.t * 'elt) list

              val empty : 'a1 t

              val is_empty : 'a1 t -> bool

              val mem : key -> 'a1 t -> bool

              type 'elt coq_R_mem = 'elt R.Defs.SigFM.Raw.Proofs.L.coq_R_mem =
              | R_mem_0 of 'elt t
              | R_mem_1 of 'elt t * T_as_UCT.t * 'elt
                 * (T_as_UCT.t * 'elt) list
              | R_mem_2 of 'elt t * T_as_UCT.t * 'elt
                 * (T_as_UCT.t * 'elt) list
              | R_mem_3 of 'elt t * T_as_UCT.t * 'elt
                 * (T_as_UCT.t * 'elt) list * bool * 'elt coq_R_mem

              val coq_R_mem_rect :
                key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t
                -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __
                -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> bool -> 'a1
                coq_R_mem -> 'a2 -> 'a2) -> 'a1 t -> bool -> 'a1 coq_R_mem ->
                'a2

              val coq_R_mem_rec :
                key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t
                -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __
                -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> bool -> 'a1
                coq_R_mem -> 'a2 -> 'a2) -> 'a1 t -> bool -> 'a1 coq_R_mem ->
                'a2

              val mem_rect :
                key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t
                -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __
                -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 -> 'a2) ->
                'a1 t -> 'a2

              val mem_rec :
                key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t
                -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __
                -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 -> 'a2) ->
                'a1 t -> 'a2

              val coq_R_mem_correct : key -> 'a1 t -> bool -> 'a1 coq_R_mem

              val find : key -> 'a1 t -> 'a1 option

              type 'elt coq_R_find = 'elt R.Defs.SigFM.Raw.Proofs.L.coq_R_find =
              | R_find_0 of 'elt t
              | R_find_1 of 'elt t * T_as_UCT.t * 'elt
                 * (T_as_UCT.t * 'elt) list
              | R_find_2 of 'elt t * T_as_UCT.t * 'elt
                 * (T_as_UCT.t * 'elt) list
              | R_find_3 of 'elt t * T_as_UCT.t * 'elt
                 * (T_as_UCT.t * 'elt) list * 'elt option * 'elt coq_R_find

              val coq_R_find_rect :
                key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t
                -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __
                -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1 option ->
                'a1 coq_R_find -> 'a2 -> 'a2) -> 'a1 t -> 'a1 option -> 'a1
                coq_R_find -> 'a2

              val coq_R_find_rec :
                key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t
                -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __
                -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1 option ->
                'a1 coq_R_find -> 'a2 -> 'a2) -> 'a1 t -> 'a1 option -> 'a1
                coq_R_find -> 'a2

              val find_rect :
                key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t
                -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __
                -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 -> 'a2) ->
                'a1 t -> 'a2

              val find_rec :
                key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t
                -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __
                -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 -> 'a2) ->
                'a1 t -> 'a2

              val coq_R_find_correct :
                key -> 'a1 t -> 'a1 option -> 'a1 coq_R_find

              val add : key -> 'a1 -> 'a1 t -> 'a1 t

              type 'elt coq_R_add = 'elt R.Defs.SigFM.Raw.Proofs.L.coq_R_add =
              | R_add_0 of 'elt t
              | R_add_1 of 'elt t * T_as_UCT.t * 'elt
                 * (T_as_UCT.t * 'elt) list
              | R_add_2 of 'elt t * T_as_UCT.t * 'elt
                 * (T_as_UCT.t * 'elt) list
              | R_add_3 of 'elt t * T_as_UCT.t * 'elt
                 * (T_as_UCT.t * 'elt) list * 'elt t * 'elt coq_R_add

              val coq_R_add_rect :
                key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __
                -> __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1 t -> 'a1
                coq_R_add -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_add
                -> 'a2

              val coq_R_add_rec :
                key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __
                -> __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1 t -> 'a1
                coq_R_add -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_add
                -> 'a2

              val add_rect :
                key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __
                -> __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 -> 'a2) ->
                'a1 t -> 'a2

              val add_rec :
                key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __
                -> __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 -> 'a2) ->
                'a1 t -> 'a2

              val coq_R_add_correct :
                key -> 'a1 -> 'a1 t -> 'a1 t -> 'a1 coq_R_add

              val remove : key -> 'a1 t -> 'a1 t

              type 'elt coq_R_remove = 'elt R.Defs.SigFM.Raw.Proofs.L.coq_R_remove =
              | R_remove_0 of 'elt t
              | R_remove_1 of 'elt t * T_as_UCT.t * 'elt
                 * (T_as_UCT.t * 'elt) list
              | R_remove_2 of 'elt t * T_as_UCT.t * 'elt
                 * (T_as_UCT.t * 'elt) list
              | R_remove_3 of 'elt t * T_as_UCT.t * 'elt
                 * (T_as_UCT.t * 'elt) list * 'elt t * 'elt coq_R_remove

              val coq_R_remove_rect :
                key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t
                -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __
                -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1 t -> 'a1
                coq_R_remove -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1
                coq_R_remove -> 'a2

              val coq_R_remove_rec :
                key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t
                -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __
                -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1 t -> 'a1
                coq_R_remove -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1
                coq_R_remove -> 'a2

              val remove_rect :
                key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t
                -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __
                -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 -> 'a2) ->
                'a1 t -> 'a2

              val remove_rec :
                key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t
                -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __
                -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 -> 'a2) ->
                'a1 t -> 'a2

              val coq_R_remove_correct :
                key -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove

              val elements : 'a1 t -> 'a1 t

              val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

              type ('elt, 'a) coq_R_fold = ('elt, 'a) R.Defs.SigFM.Raw.Proofs.L.coq_R_fold =
              | R_fold_0 of 'elt t * 'a
              | R_fold_1 of 'elt t * 'a * T_as_UCT.t * 'elt
                 * (T_as_UCT.t * 'elt) list * 'a * ('elt, 'a) coq_R_fold

              val coq_R_fold_rect :
                (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) ->
                ('a1 t -> 'a2 -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                -> __ -> 'a2 -> ('a1, 'a2) coq_R_fold -> 'a3 -> 'a3) -> 'a1 t
                -> 'a2 -> 'a2 -> ('a1, 'a2) coq_R_fold -> 'a3

              val coq_R_fold_rec :
                (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) ->
                ('a1 t -> 'a2 -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                -> __ -> 'a2 -> ('a1, 'a2) coq_R_fold -> 'a3 -> 'a3) -> 'a1 t
                -> 'a2 -> 'a2 -> ('a1, 'a2) coq_R_fold -> 'a3

              val fold_rect :
                (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) ->
                ('a1 t -> 'a2 -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                -> __ -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a3

              val fold_rec :
                (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) ->
                ('a1 t -> 'a2 -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                -> __ -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a3

              val coq_R_fold_correct :
                (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2 -> ('a1,
                'a2) coq_R_fold

              val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool

              type 'elt coq_R_equal = 'elt R.Defs.SigFM.Raw.Proofs.L.coq_R_equal =
              | R_equal_0 of 'elt t * 'elt t
              | R_equal_1 of 'elt t * 'elt t * T_as_UCT.t * 'elt
                 * (T_as_UCT.t * 'elt) list * T_as_UCT.t * 'elt
                 * (T_as_UCT.t * 'elt) list * bool * 'elt coq_R_equal
              | R_equal_2 of 'elt t * 'elt t * T_as_UCT.t * 'elt
                 * (T_as_UCT.t * 'elt) list * T_as_UCT.t * 'elt
                 * (T_as_UCT.t * 'elt) list * T_as_UCT.t compare0
              | R_equal_3 of 'elt t * 'elt t * 'elt t * 'elt t

              val coq_R_equal_rect :
                ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2)
                -> ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1)
                list -> __ -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list ->
                __ -> __ -> __ -> bool -> 'a1 coq_R_equal -> 'a2 -> 'a2) ->
                ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1)
                list -> __ -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list ->
                __ -> T_as_UCT.t compare0 -> __ -> __ -> 'a2) -> ('a1 t ->
                'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2) -> 'a1 t ->
                'a1 t -> bool -> 'a1 coq_R_equal -> 'a2

              val coq_R_equal_rec :
                ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2)
                -> ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1)
                list -> __ -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list ->
                __ -> __ -> __ -> bool -> 'a1 coq_R_equal -> 'a2 -> 'a2) ->
                ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1)
                list -> __ -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list ->
                __ -> T_as_UCT.t compare0 -> __ -> __ -> 'a2) -> ('a1 t ->
                'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2) -> 'a1 t ->
                'a1 t -> bool -> 'a1 coq_R_equal -> 'a2

              val equal_rect :
                ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2)
                -> ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1)
                list -> __ -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list ->
                __ -> __ -> __ -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t ->
                T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
                T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
                T_as_UCT.t compare0 -> __ -> __ -> 'a2) -> ('a1 t -> 'a1 t ->
                'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2) -> 'a1 t -> 'a1 t ->
                'a2

              val equal_rec :
                ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2)
                -> ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1)
                list -> __ -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list ->
                __ -> __ -> __ -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t ->
                T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
                T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
                T_as_UCT.t compare0 -> __ -> __ -> 'a2) -> ('a1 t -> 'a1 t ->
                'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2) -> 'a1 t -> 'a1 t ->
                'a2

              val coq_R_equal_correct :
                ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool -> 'a1
                coq_R_equal

              val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

              val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

              val option_cons :
                key -> 'a1 option -> (key * 'a1) list -> (key * 'a1) list

              val map2_l :
                ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a3 t

              val map2_r :
                ('a1 option -> 'a2 option -> 'a3 option) -> 'a2 t -> 'a3 t

              val map2 :
                ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t ->
                'a3 t

              val combine : 'a1 t -> 'a2 t -> ('a1 option * 'a2 option) t

              val fold_right_pair :
                ('a1 -> 'a2 -> 'a3 -> 'a3) -> ('a1 * 'a2) list -> 'a3 -> 'a3

              val map2_alt :
                ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t ->
                (key * 'a3) list

              val at_least_one :
                'a1 option -> 'a2 option -> ('a1 option * 'a2 option) option

              val at_least_one_then_f :
                ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 option -> 'a2
                option -> 'a3 option
             end

            type 'elt coq_R_mem = 'elt R.Defs.SigFM.Raw.Proofs.coq_R_mem =
            | R_mem_0 of 'elt tree
            | R_mem_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t * bool * 'elt coq_R_mem
            | R_mem_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t
            | R_mem_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t * bool * 'elt coq_R_mem

            val coq_R_mem_rect :
              T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree
              -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
              bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree
              -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
              'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
              Z_as_Int.t -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 ->
              'a2) -> 'a1 tree -> bool -> 'a1 coq_R_mem -> 'a2

            val coq_R_mem_rec :
              T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree
              -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
              bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree
              -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
              'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
              Z_as_Int.t -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 ->
              'a2) -> 'a1 tree -> bool -> 'a1 coq_R_mem -> 'a2

            type 'elt coq_R_find = 'elt R.Defs.SigFM.Raw.Proofs.coq_R_find =
            | R_find_0 of 'elt tree
            | R_find_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t * 'elt option * 'elt coq_R_find
            | R_find_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t
            | R_find_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t * 'elt option * 'elt coq_R_find

            val coq_R_find_rect :
              T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree
              -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
              'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> ('a1 tree -> 'a1
              tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __
              -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
              Z_as_Int.t -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find ->
              'a2 -> 'a2) -> 'a1 tree -> 'a1 option -> 'a1 coq_R_find -> 'a2

            val coq_R_find_rec :
              T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree
              -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
              'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> ('a1 tree -> 'a1
              tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __
              -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
              Z_as_Int.t -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find ->
              'a2 -> 'a2) -> 'a1 tree -> 'a1 option -> 'a1 coq_R_find -> 'a2

            type 'elt coq_R_bal = 'elt R.Defs.SigFM.Raw.Proofs.coq_R_bal =
            | R_bal_0 of 'elt tree * key * 'elt * 'elt tree
            | R_bal_1 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
               key * 'elt * 'elt tree * Z_as_Int.t
            | R_bal_2 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
               key * 'elt * 'elt tree * Z_as_Int.t
            | R_bal_3 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
               key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 
               'elt * 'elt tree * Z_as_Int.t
            | R_bal_4 of 'elt tree * key * 'elt * 'elt tree
            | R_bal_5 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
               key * 'elt * 'elt tree * Z_as_Int.t
            | R_bal_6 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
               key * 'elt * 'elt tree * Z_as_Int.t
            | R_bal_7 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
               key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 
               'elt * 'elt tree * Z_as_Int.t
            | R_bal_8 of 'elt tree * key * 'elt * 'elt tree

            val coq_R_bal_rect :
              ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> 'a2)
              -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree
              -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
              'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1
              tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __
              -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ ->
              __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
              __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
              __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
              -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1
              tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1
              tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree ->
              key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree ->
              key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> __ ->
              'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __
              -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
              -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
              -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ ->
              __ -> __ -> __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
              'a1 tree -> 'a1 coq_R_bal -> 'a2

            val coq_R_bal_rec :
              ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> 'a2)
              -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree
              -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
              'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1
              tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __
              -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ ->
              __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
              __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
              __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
              -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1
              tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1
              tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree ->
              key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree ->
              key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> __ ->
              'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __
              -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
              -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
              -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ ->
              __ -> __ -> __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
              'a1 tree -> 'a1 coq_R_bal -> 'a2

            type 'elt coq_R_add = 'elt R.Defs.SigFM.Raw.Proofs.coq_R_add =
            | R_add_0 of 'elt tree
            | R_add_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t * 'elt tree * 'elt coq_R_add
            | R_add_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t
            | R_add_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t * 'elt tree * 'elt coq_R_add

            val coq_R_add_rect :
              key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree
              -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
              'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1 tree -> 'a1
              tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __
              -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
              Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_add ->
              'a2 -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_add -> 'a2

            val coq_R_add_rec :
              key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree
              -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
              'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1 tree -> 'a1
              tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __
              -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
              Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_add ->
              'a2 -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_add -> 'a2

            type 'elt coq_R_remove_min = 'elt R.Defs.SigFM.Raw.Proofs.coq_R_remove_min =
            | R_remove_min_0 of 'elt tree * key * 'elt * 'elt tree
            | R_remove_min_1 of 'elt tree * key * 'elt * 'elt tree
               * 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t
               * ('elt tree * (key * 'elt)) * 'elt coq_R_remove_min
               * 'elt tree * (key * 'elt)

            val coq_R_remove_min_rect :
              ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1 tree
              -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree
              -> Z_as_Int.t -> __ -> ('a1 tree * (key * 'a1)) -> 'a1
              coq_R_remove_min -> 'a2 -> 'a1 tree -> (key * 'a1) -> __ ->
              'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> ('a1
              tree * (key * 'a1)) -> 'a1 coq_R_remove_min -> 'a2

            val coq_R_remove_min_rec :
              ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1 tree
              -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree
              -> Z_as_Int.t -> __ -> ('a1 tree * (key * 'a1)) -> 'a1
              coq_R_remove_min -> 'a2 -> 'a1 tree -> (key * 'a1) -> __ ->
              'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> ('a1
              tree * (key * 'a1)) -> 'a1 coq_R_remove_min -> 'a2

            type 'elt coq_R_merge = 'elt R.Defs.SigFM.Raw.Proofs.coq_R_merge =
            | R_merge_0 of 'elt tree * 'elt tree
            | R_merge_1 of 'elt tree * 'elt tree * 'elt tree * key * 
               'elt * 'elt tree * Z_as_Int.t
            | R_merge_2 of 'elt tree * 'elt tree * 'elt tree * key * 
               'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 'elt
               * 'elt tree * Z_as_Int.t * 'elt tree * (key * 'elt) * 
               key * 'elt

            val coq_R_merge_rect :
              ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
              'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
              'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
              tree -> Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree
              -> Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> key ->
              'a1 -> __ -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 tree -> 'a1
              coq_R_merge -> 'a2

            val coq_R_merge_rec :
              ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
              'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
              'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
              tree -> Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree
              -> Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> key ->
              'a1 -> __ -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 tree -> 'a1
              coq_R_merge -> 'a2

            type 'elt coq_R_remove = 'elt R.Defs.SigFM.Raw.Proofs.coq_R_remove =
            | R_remove_0 of 'elt tree
            | R_remove_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t * 'elt tree * 'elt coq_R_remove
            | R_remove_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t
            | R_remove_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t * 'elt tree * 'elt coq_R_remove

            val coq_R_remove_rect :
              T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree
              -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
              'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> ('a1 tree -> 'a1
              tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __
              -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
              Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove ->
              'a2 -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_remove -> 'a2

            val coq_R_remove_rec :
              T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree
              -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
              'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> ('a1 tree -> 'a1
              tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __
              -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
              Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove ->
              'a2 -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_remove -> 'a2

            type 'elt coq_R_concat = 'elt R.Defs.SigFM.Raw.Proofs.coq_R_concat =
            | R_concat_0 of 'elt tree * 'elt tree
            | R_concat_1 of 'elt tree * 'elt tree * 'elt tree * key * 
               'elt * 'elt tree * Z_as_Int.t
            | R_concat_2 of 'elt tree * 'elt tree * 'elt tree * key * 
               'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 'elt
               * 'elt tree * Z_as_Int.t * 'elt tree * (key * 'elt)

            val coq_R_concat_rect :
              ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
              'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
              'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
              tree -> Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree
              -> Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> 'a2) ->
              'a1 tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_concat -> 'a2

            val coq_R_concat_rec :
              ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
              'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
              'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
              tree -> Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree
              -> Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> 'a2) ->
              'a1 tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_concat -> 'a2

            type 'elt coq_R_split = 'elt R.Defs.SigFM.Raw.Proofs.coq_R_split =
            | R_split_0 of 'elt tree
            | R_split_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t * 'elt triple * 'elt coq_R_split * 'elt tree
               * 'elt option * 'elt tree
            | R_split_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t
            | R_split_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t * 'elt triple * 'elt coq_R_split * 'elt tree
               * 'elt option * 'elt tree

            val coq_R_split_rect :
              T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree
              -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
              'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option
              -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key ->
              'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1
              tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
              -> __ -> __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree
              -> 'a1 option -> 'a1 tree -> __ -> 'a2) -> 'a1 tree -> 'a1
              triple -> 'a1 coq_R_split -> 'a2

            val coq_R_split_rec :
              T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree
              -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
              'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option
              -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key ->
              'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1
              tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
              -> __ -> __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree
              -> 'a1 option -> 'a1 tree -> __ -> 'a2) -> 'a1 tree -> 'a1
              triple -> 'a1 coq_R_split -> 'a2

            type ('elt, 'x) coq_R_map_option = ('elt, 'x) R.Defs.SigFM.Raw.Proofs.coq_R_map_option =
            | R_map_option_0 of 'elt tree
            | R_map_option_1 of 'elt tree * 'elt tree * key * 'elt
               * 'elt tree * Z_as_Int.t * 'x * 'x tree
               * ('elt, 'x) coq_R_map_option * 'x tree
               * ('elt, 'x) coq_R_map_option
            | R_map_option_2 of 'elt tree * 'elt tree * key * 'elt
               * 'elt tree * Z_as_Int.t * 'x tree
               * ('elt, 'x) coq_R_map_option * 'x tree
               * ('elt, 'x) coq_R_map_option

            val coq_R_map_option_rect :
              (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) -> ('a1
              tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
              -> 'a2 -> __ -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3
              -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) ->
              ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
              -> __ -> __ -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3
              -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) ->
              'a1 tree -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3

            val coq_R_map_option_rec :
              (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) -> ('a1
              tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
              -> 'a2 -> __ -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3
              -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) ->
              ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
              -> __ -> __ -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3
              -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) ->
              'a1 tree -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3

            type ('elt, 'x0, 'x) coq_R_map2_opt = ('elt, 'x0, 'x) R.Defs.SigFM.Raw.Proofs.coq_R_map2_opt =
            | R_map2_opt_0 of 'elt tree * 'x0 tree
            | R_map2_opt_1 of 'elt tree * 'x0 tree * 'elt tree * key * 
               'elt * 'elt tree * Z_as_Int.t
            | R_map2_opt_2 of 'elt tree * 'x0 tree * 'elt tree * key * 
               'elt * 'elt tree * Z_as_Int.t * 'x0 tree * key * 'x0
               * 'x0 tree * Z_as_Int.t * 'x0 tree * 'x0 option * 'x0 tree
               * 'x * 'x tree * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
               * ('elt, 'x0, 'x) coq_R_map2_opt
            | R_map2_opt_3 of 'elt tree * 'x0 tree * 'elt tree * key * 
               'elt * 'elt tree * Z_as_Int.t * 'x0 tree * key * 'x0
               * 'x0 tree * Z_as_Int.t * 'x0 tree * 'x0 option * 'x0 tree
               * 'x tree * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
               * ('elt, 'x0, 'x) coq_R_map2_opt

            val coq_R_map2_opt_rect :
              (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3
              tree) -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2 tree -> __
              -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 ->
              'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a4) -> ('a1 tree -> 'a2
              tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
              -> 'a2 tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ ->
              'a2 tree -> 'a2 option -> 'a2 tree -> __ -> 'a3 -> __ -> 'a3
              tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree ->
              ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree ->
              'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
              __ -> 'a2 tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ ->
              'a2 tree -> 'a2 option -> 'a2 tree -> __ -> __ -> 'a3 tree ->
              ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2,
              'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1 tree -> 'a2 tree ->
              'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4

            val coq_R_map2_opt_rec :
              (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3
              tree) -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2 tree -> __
              -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 ->
              'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a4) -> ('a1 tree -> 'a2
              tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
              -> 'a2 tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ ->
              'a2 tree -> 'a2 option -> 'a2 tree -> __ -> 'a3 -> __ -> 'a3
              tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree ->
              ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree ->
              'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
              __ -> 'a2 tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ ->
              'a2 tree -> 'a2 option -> 'a2 tree -> __ -> __ -> 'a3 tree ->
              ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2,
              'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1 tree -> 'a2 tree ->
              'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4

            val fold' : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

            val flatten_e : 'a1 enumeration -> (key * 'a1) list
           end
         end

        type 'elt bst =
          'elt Raw.tree
          (* singleton inductive, whose constructor was Bst *)

        val this : 'a1 bst -> 'a1 Raw.tree

        type 'elt t = 'elt bst

        type key = T_as_UCT.t

        val empty : 'a1 t

        val is_empty : 'a1 t -> bool

        val add : key -> 'a1 -> 'a1 t -> 'a1 t

        val remove : key -> 'a1 t -> 'a1 t

        val mem : key -> 'a1 t -> bool

        val find : key -> 'a1 t -> 'a1 option

        val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

        val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

        val map2 :
          ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t -> 'a3 t

        val elements : 'a1 t -> (key * 'a1) list

        val cardinal : 'a1 t -> nat

        val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

        val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool
       end

      module SigFMF :
       sig
        val eqb : T_as_UCT.t -> T_as_UCT.t -> bool

        val coq_In_dec : 'a1 SigFM.t -> SigFM.key -> bool
       end

      module Strings :
       sig
        type coq_String = R.Ty.coq_Sigma list

        val coq_String_dec : coq_String -> coq_String -> bool

        val rm_empty : coq_String list -> R.Ty.coq_Sigma list list
       end

      module Regexes :
       sig
        type regex = R.Defs.Regexes.regex =
        | EmptySet
        | EmptyStr
        | Char of R.Ty.coq_Sigma
        | App of regex * regex
        | Union of regex * regex
        | Star of regex

        val regex_rect :
          'a1 -> 'a1 -> (R.Ty.coq_Sigma -> 'a1) -> (regex -> 'a1 -> regex ->
          'a1 -> 'a1) -> (regex -> 'a1 -> regex -> 'a1 -> 'a1) -> (regex ->
          'a1 -> 'a1) -> regex -> 'a1

        val regex_rec :
          'a1 -> 'a1 -> (R.Ty.coq_Sigma -> 'a1) -> (regex -> 'a1 -> regex ->
          'a1 -> 'a1) -> (regex -> 'a1 -> regex -> 'a1 -> 'a1) -> (regex ->
          'a1 -> 'a1) -> regex -> 'a1

        val regex_dec : regex -> regex -> bool

        val regex_eq : regex -> regex -> bool

        val nullable' : regex -> bool

        val nullable : regex -> bool

        val derivative : R.Ty.coq_Sigma -> regex -> regex

        val derivative_list : R.Ty.coq_Sigma list -> regex -> regex

        val re_compare : regex -> regex -> comparison
       end

      module Coq_regex_as_UCT :
       sig
        type t = Regexes.regex

        val compare : Regexes.regex -> Regexes.regex -> comparison
       end

      module Coq_regex_as_UOT :
       sig
        type t = Coq_regex_as_UCT.t

        val compare : t -> t -> t compare0

        val eq_dec : t -> t -> bool
       end

      module Coq_reFS :
       sig
        module X' :
         sig
          type t = Coq_regex_as_UCT.t

          val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

          val compare : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> comparison
         end

        module MSet :
         sig
          module Raw :
           sig
            type elt = Coq_regex_as_UCT.t

            type tree = R.Defs.Coq_reFS.MSet.Raw.tree =
            | Leaf
            | Node of Z_as_Int.t * tree * Coq_regex_as_UCT.t * tree

            val empty : tree

            val is_empty : tree -> bool

            val mem : Coq_regex_as_UCT.t -> tree -> bool

            val min_elt : tree -> elt option

            val max_elt : tree -> elt option

            val choose : tree -> elt option

            val fold : (elt -> 'a1 -> 'a1) -> tree -> 'a1 -> 'a1

            val elements_aux :
              Coq_regex_as_UCT.t list -> tree -> Coq_regex_as_UCT.t list

            val elements : tree -> Coq_regex_as_UCT.t list

            val rev_elements_aux :
              Coq_regex_as_UCT.t list -> tree -> Coq_regex_as_UCT.t list

            val rev_elements : tree -> Coq_regex_as_UCT.t list

            val cardinal : tree -> nat

            val maxdepth : tree -> nat

            val mindepth : tree -> nat

            val for_all : (elt -> bool) -> tree -> bool

            val exists_ : (elt -> bool) -> tree -> bool

            type enumeration = R.Defs.Coq_reFS.MSet.Raw.enumeration =
            | End
            | More of elt * tree * enumeration

            val cons : tree -> enumeration -> enumeration

            val compare_more :
              Coq_regex_as_UCT.t -> (enumeration -> comparison) ->
              enumeration -> comparison

            val compare_cont :
              tree -> (enumeration -> comparison) -> enumeration -> comparison

            val compare_end : enumeration -> comparison

            val compare : tree -> tree -> comparison

            val equal : tree -> tree -> bool

            val subsetl : (tree -> bool) -> Coq_regex_as_UCT.t -> tree -> bool

            val subsetr : (tree -> bool) -> Coq_regex_as_UCT.t -> tree -> bool

            val subset : tree -> tree -> bool

            type t = tree

            val height : t -> Z_as_Int.t

            val singleton : Coq_regex_as_UCT.t -> tree

            val create : t -> Coq_regex_as_UCT.t -> t -> tree

            val assert_false : t -> Coq_regex_as_UCT.t -> t -> tree

            val bal : t -> Coq_regex_as_UCT.t -> t -> tree

            val add : Coq_regex_as_UCT.t -> tree -> tree

            val join : tree -> elt -> t -> t

            val remove_min : tree -> elt -> t -> t * elt

            val merge : tree -> tree -> tree

            val remove : Coq_regex_as_UCT.t -> tree -> tree

            val concat : tree -> tree -> tree

            type triple = R.Defs.Coq_reFS.MSet.Raw.triple = { t_left : 
                                                              t; t_in : 
                                                              bool;
                                                              t_right : 
                                                              t }

            val t_left : triple -> t

            val t_in : triple -> bool

            val t_right : triple -> t

            val split : Coq_regex_as_UCT.t -> tree -> triple

            val inter : tree -> tree -> tree

            val diff : tree -> tree -> tree

            val union : tree -> tree -> tree

            val filter : (elt -> bool) -> tree -> tree

            val partition : (elt -> bool) -> t -> t * t

            val ltb_tree : Coq_regex_as_UCT.t -> tree -> bool

            val gtb_tree : Coq_regex_as_UCT.t -> tree -> bool

            val isok : tree -> bool

            module MX :
             sig
              module OrderTac :
               sig
                module OTF :
                 sig
                  type t = Coq_regex_as_UCT.t

                  val compare :
                    Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> comparison

                  val eq_dec :
                    Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                 end

                module TO :
                 sig
                  type t = Coq_regex_as_UCT.t

                  val compare :
                    Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> comparison

                  val eq_dec :
                    Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                 end
               end

              val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

              val lt_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

              val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
             end

            type coq_R_min_elt = R.Defs.Coq_reFS.MSet.Raw.coq_R_min_elt =
            | R_min_elt_0 of tree
            | R_min_elt_1 of tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
               * tree
            | R_min_elt_2 of tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
               * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t * tree
               * elt option * coq_R_min_elt

            type coq_R_max_elt = R.Defs.Coq_reFS.MSet.Raw.coq_R_max_elt =
            | R_max_elt_0 of tree
            | R_max_elt_1 of tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
               * tree
            | R_max_elt_2 of tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
               * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t * tree
               * elt option * coq_R_max_elt

            module L :
             sig
              module MO :
               sig
                module OrderTac :
                 sig
                  module OTF :
                   sig
                    type t = Coq_regex_as_UCT.t

                    val compare :
                      Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> comparison

                    val eq_dec :
                      Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                   end

                  module TO :
                   sig
                    type t = Coq_regex_as_UCT.t

                    val compare :
                      Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> comparison

                    val eq_dec :
                      Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                   end
                 end

                val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                val lt_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
               end
             end

            val flatten_e : enumeration -> elt list

            type coq_R_bal = R.Defs.Coq_reFS.MSet.Raw.coq_R_bal =
            | R_bal_0 of t * Coq_regex_as_UCT.t * t
            | R_bal_1 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * tree
               * Coq_regex_as_UCT.t * tree
            | R_bal_2 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * tree
               * Coq_regex_as_UCT.t * tree
            | R_bal_3 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * tree
               * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
               * Coq_regex_as_UCT.t * tree
            | R_bal_4 of t * Coq_regex_as_UCT.t * t
            | R_bal_5 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * tree
               * Coq_regex_as_UCT.t * tree
            | R_bal_6 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * tree
               * Coq_regex_as_UCT.t * tree
            | R_bal_7 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * tree
               * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
               * Coq_regex_as_UCT.t * tree
            | R_bal_8 of t * Coq_regex_as_UCT.t * t

            type coq_R_remove_min = R.Defs.Coq_reFS.MSet.Raw.coq_R_remove_min =
            | R_remove_min_0 of tree * elt * t
            | R_remove_min_1 of tree * elt * t * Z_as_Int.t * tree
               * Coq_regex_as_UCT.t * tree * (t * elt) * coq_R_remove_min * 
               t * elt

            type coq_R_merge = R.Defs.Coq_reFS.MSet.Raw.coq_R_merge =
            | R_merge_0 of tree * tree
            | R_merge_1 of tree * tree * Z_as_Int.t * tree
               * Coq_regex_as_UCT.t * tree
            | R_merge_2 of tree * tree * Z_as_Int.t * tree
               * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
               * Coq_regex_as_UCT.t * tree * t * elt

            type coq_R_concat = R.Defs.Coq_reFS.MSet.Raw.coq_R_concat =
            | R_concat_0 of tree * tree
            | R_concat_1 of tree * tree * Z_as_Int.t * tree
               * Coq_regex_as_UCT.t * tree
            | R_concat_2 of tree * tree * Z_as_Int.t * tree
               * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
               * Coq_regex_as_UCT.t * tree * t * elt

            type coq_R_inter = R.Defs.Coq_reFS.MSet.Raw.coq_R_inter =
            | R_inter_0 of tree * tree
            | R_inter_1 of tree * tree * Z_as_Int.t * tree
               * Coq_regex_as_UCT.t * tree
            | R_inter_2 of tree * tree * Z_as_Int.t * tree
               * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
               * Coq_regex_as_UCT.t * tree * t * bool * t * tree
               * coq_R_inter * tree * coq_R_inter
            | R_inter_3 of tree * tree * Z_as_Int.t * tree
               * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
               * Coq_regex_as_UCT.t * tree * t * bool * t * tree
               * coq_R_inter * tree * coq_R_inter

            type coq_R_diff = R.Defs.Coq_reFS.MSet.Raw.coq_R_diff =
            | R_diff_0 of tree * tree
            | R_diff_1 of tree * tree * Z_as_Int.t * tree
               * Coq_regex_as_UCT.t * tree
            | R_diff_2 of tree * tree * Z_as_Int.t * tree
               * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
               * Coq_regex_as_UCT.t * tree * t * bool * t * tree * coq_R_diff
               * tree * coq_R_diff
            | R_diff_3 of tree * tree * Z_as_Int.t * tree
               * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
               * Coq_regex_as_UCT.t * tree * t * bool * t * tree * coq_R_diff
               * tree * coq_R_diff

            type coq_R_union = R.Defs.Coq_reFS.MSet.Raw.coq_R_union =
            | R_union_0 of tree * tree
            | R_union_1 of tree * tree * Z_as_Int.t * tree
               * Coq_regex_as_UCT.t * tree
            | R_union_2 of tree * tree * Z_as_Int.t * tree
               * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
               * Coq_regex_as_UCT.t * tree * t * bool * t * tree
               * coq_R_union * tree * coq_R_union
           end

          module E :
           sig
            type t = Coq_regex_as_UCT.t

            val compare :
              Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> comparison

            val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
           end

          type elt = Coq_regex_as_UCT.t

          type t_ = Raw.t
            (* singleton inductive, whose constructor was Mkt *)

          val this : t_ -> Raw.t

          type t = t_

          val mem : elt -> t -> bool

          val add : elt -> t -> t

          val remove : elt -> t -> t

          val singleton : elt -> t

          val union : t -> t -> t

          val inter : t -> t -> t

          val diff : t -> t -> t

          val equal : t -> t -> bool

          val subset : t -> t -> bool

          val empty : t

          val is_empty : t -> bool

          val elements : t -> elt list

          val choose : t -> elt option

          val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

          val cardinal : t -> nat

          val filter : (elt -> bool) -> t -> t

          val for_all : (elt -> bool) -> t -> bool

          val exists_ : (elt -> bool) -> t -> bool

          val partition : (elt -> bool) -> t -> t * t

          val eq_dec : t -> t -> bool

          val compare : t -> t -> comparison

          val min_elt : t -> elt option

          val max_elt : t -> elt option
         end

        type elt = Coq_regex_as_UCT.t

        type t = MSet.t

        val empty : t

        val is_empty : t -> bool

        val mem : elt -> t -> bool

        val add : elt -> t -> t

        val singleton : elt -> t

        val remove : elt -> t -> t

        val union : t -> t -> t

        val inter : t -> t -> t

        val diff : t -> t -> t

        val eq_dec : t -> t -> bool

        val equal : t -> t -> bool

        val subset : t -> t -> bool

        val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

        val for_all : (elt -> bool) -> t -> bool

        val exists_ : (elt -> bool) -> t -> bool

        val filter : (elt -> bool) -> t -> t

        val partition : (elt -> bool) -> t -> t * t

        val cardinal : t -> nat

        val elements : t -> elt list

        val choose : t -> elt option

        module MF :
         sig
          val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
         end

        val min_elt : t -> elt option

        val max_elt : t -> elt option

        val compare : t -> t -> t compare0

        module E :
         sig
          type t = Coq_regex_as_UCT.t

          val compare :
            Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t
            compare0

          val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
         end
       end

      module Coq_reFSF :
       sig
        val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
       end

      module Coq_reFM :
       sig
        module E :
         sig
          type t = Coq_regex_as_UCT.t

          val compare :
            Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t
            compare0

          val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
         end

        module Raw :
         sig
          type key = Coq_regex_as_UCT.t

          type 'elt tree = 'elt R.Defs.Coq_reFM.Raw.tree =
          | Leaf
          | Node of 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t

          val tree_rect :
            'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
            Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

          val tree_rec :
            'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
            Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

          val height : 'a1 tree -> Z_as_Int.t

          val cardinal : 'a1 tree -> nat

          val empty : 'a1 tree

          val is_empty : 'a1 tree -> bool

          val mem : Coq_regex_as_UCT.t -> 'a1 tree -> bool

          val find : Coq_regex_as_UCT.t -> 'a1 tree -> 'a1 option

          val create : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

          val assert_false : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

          val bal : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

          val add : key -> 'a1 -> 'a1 tree -> 'a1 tree

          val remove_min :
            'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree * (key * 'a1)

          val merge : 'a1 tree -> 'a1 tree -> 'a1 tree

          val remove : Coq_regex_as_UCT.t -> 'a1 tree -> 'a1 tree

          val join : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

          type 'elt triple = 'elt R.Defs.Coq_reFM.Raw.triple = { t_left : 
                                                                 'elt tree;
                                                                 t_opt : 
                                                                 'elt option;
                                                                 t_right : 
                                                                 'elt tree }

          val t_left : 'a1 triple -> 'a1 tree

          val t_opt : 'a1 triple -> 'a1 option

          val t_right : 'a1 triple -> 'a1 tree

          val split : Coq_regex_as_UCT.t -> 'a1 tree -> 'a1 triple

          val concat : 'a1 tree -> 'a1 tree -> 'a1 tree

          val elements_aux : (key * 'a1) list -> 'a1 tree -> (key * 'a1) list

          val elements : 'a1 tree -> (key * 'a1) list

          val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

          type 'elt enumeration = 'elt R.Defs.Coq_reFM.Raw.enumeration =
          | End
          | More of key * 'elt * 'elt tree * 'elt enumeration

          val enumeration_rect :
            'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 -> 'a2)
            -> 'a1 enumeration -> 'a2

          val enumeration_rec :
            'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 -> 'a2)
            -> 'a1 enumeration -> 'a2

          val cons : 'a1 tree -> 'a1 enumeration -> 'a1 enumeration

          val equal_more :
            ('a1 -> 'a1 -> bool) -> Coq_regex_as_UCT.t -> 'a1 -> ('a1
            enumeration -> bool) -> 'a1 enumeration -> bool

          val equal_cont :
            ('a1 -> 'a1 -> bool) -> 'a1 tree -> ('a1 enumeration -> bool) ->
            'a1 enumeration -> bool

          val equal_end : 'a1 enumeration -> bool

          val equal : ('a1 -> 'a1 -> bool) -> 'a1 tree -> 'a1 tree -> bool

          val map : ('a1 -> 'a2) -> 'a1 tree -> 'a2 tree

          val mapi : (key -> 'a1 -> 'a2) -> 'a1 tree -> 'a2 tree

          val map_option : (key -> 'a1 -> 'a2 option) -> 'a1 tree -> 'a2 tree

          val map2_opt :
            (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3
            tree) -> ('a2 tree -> 'a3 tree) -> 'a1 tree -> 'a2 tree -> 'a3
            tree

          val map2 :
            ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 tree -> 'a2 tree
            -> 'a3 tree

          module Proofs :
           sig
            module MX :
             sig
              module TO :
               sig
                type t = Coq_regex_as_UCT.t
               end

              module IsTO :
               sig
               end

              module OrderTac :
               sig
               end

              val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

              val lt_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

              val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
             end

            module PX :
             sig
              module MO :
               sig
                module TO :
                 sig
                  type t = Coq_regex_as_UCT.t
                 end

                module IsTO :
                 sig
                 end

                module OrderTac :
                 sig
                 end

                val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                val lt_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
               end
             end

            module L :
             sig
              module MX :
               sig
                module TO :
                 sig
                  type t = Coq_regex_as_UCT.t
                 end

                module IsTO :
                 sig
                 end

                module OrderTac :
                 sig
                 end

                val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                val lt_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
               end

              module PX :
               sig
                module MO :
                 sig
                  module TO :
                   sig
                    type t = Coq_regex_as_UCT.t
                   end

                  module IsTO :
                   sig
                   end

                  module OrderTac :
                   sig
                   end

                  val eq_dec :
                    Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                  val lt_dec :
                    Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                  val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                 end
               end

              type key = Coq_regex_as_UCT.t

              type 'elt t = (Coq_regex_as_UCT.t * 'elt) list

              val empty : 'a1 t

              val is_empty : 'a1 t -> bool

              val mem : key -> 'a1 t -> bool

              type 'elt coq_R_mem = 'elt R.Defs.Coq_reFM.Raw.Proofs.L.coq_R_mem =
              | R_mem_0 of 'elt t
              | R_mem_1 of 'elt t * Coq_regex_as_UCT.t * 'elt
                 * (Coq_regex_as_UCT.t * 'elt) list
              | R_mem_2 of 'elt t * Coq_regex_as_UCT.t * 'elt
                 * (Coq_regex_as_UCT.t * 'elt) list
              | R_mem_3 of 'elt t * Coq_regex_as_UCT.t * 'elt
                 * (Coq_regex_as_UCT.t * 'elt) list * bool * 'elt coq_R_mem

              val coq_R_mem_rect :
                key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t
                -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __
                -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> bool ->
                'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 t -> bool -> 'a1
                coq_R_mem -> 'a2

              val coq_R_mem_rec :
                key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t
                -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __
                -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> bool ->
                'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 t -> bool -> 'a1
                coq_R_mem -> 'a2

              val mem_rect :
                key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t
                -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __
                -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
                'a2) -> 'a1 t -> 'a2

              val mem_rec :
                key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t
                -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __
                -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
                'a2) -> 'a1 t -> 'a2

              val coq_R_mem_correct : key -> 'a1 t -> bool -> 'a1 coq_R_mem

              val find : key -> 'a1 t -> 'a1 option

              type 'elt coq_R_find = 'elt R.Defs.Coq_reFM.Raw.Proofs.L.coq_R_find =
              | R_find_0 of 'elt t
              | R_find_1 of 'elt t * Coq_regex_as_UCT.t * 'elt
                 * (Coq_regex_as_UCT.t * 'elt) list
              | R_find_2 of 'elt t * Coq_regex_as_UCT.t * 'elt
                 * (Coq_regex_as_UCT.t * 'elt) list
              | R_find_3 of 'elt t * Coq_regex_as_UCT.t * 'elt
                 * (Coq_regex_as_UCT.t * 'elt) list * 'elt option
                 * 'elt coq_R_find

              val coq_R_find_rect :
                key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t
                -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __
                -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1
                option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> 'a1 t -> 'a1
                option -> 'a1 coq_R_find -> 'a2

              val coq_R_find_rec :
                key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t
                -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __
                -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1
                option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> 'a1 t -> 'a1
                option -> 'a1 coq_R_find -> 'a2

              val find_rect :
                key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t
                -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __
                -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
                'a2) -> 'a1 t -> 'a2

              val find_rec :
                key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t
                -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __
                -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
                'a2) -> 'a1 t -> 'a2

              val coq_R_find_correct :
                key -> 'a1 t -> 'a1 option -> 'a1 coq_R_find

              val add : key -> 'a1 -> 'a1 t -> 'a1 t

              type 'elt coq_R_add = 'elt R.Defs.Coq_reFM.Raw.Proofs.L.coq_R_add =
              | R_add_0 of 'elt t
              | R_add_1 of 'elt t * Coq_regex_as_UCT.t * 'elt
                 * (Coq_regex_as_UCT.t * 'elt) list
              | R_add_2 of 'elt t * Coq_regex_as_UCT.t * 'elt
                 * (Coq_regex_as_UCT.t * 'elt) list
              | R_add_3 of 'elt t * Coq_regex_as_UCT.t * 'elt
                 * (Coq_regex_as_UCT.t * 'elt) list * 'elt t * 'elt coq_R_add

              val coq_R_add_rect :
                key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list
                -> __ -> __ -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
                'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1 t ->
                'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1
                coq_R_add -> 'a2

              val coq_R_add_rec :
                key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list
                -> __ -> __ -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
                'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1 t ->
                'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1
                coq_R_add -> 'a2

              val add_rect :
                key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list
                -> __ -> __ -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
                'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
                'a2) -> 'a1 t -> 'a2

              val add_rec :
                key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list
                -> __ -> __ -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
                'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
                'a2) -> 'a1 t -> 'a2

              val coq_R_add_correct :
                key -> 'a1 -> 'a1 t -> 'a1 t -> 'a1 coq_R_add

              val remove : key -> 'a1 t -> 'a1 t

              type 'elt coq_R_remove = 'elt R.Defs.Coq_reFM.Raw.Proofs.L.coq_R_remove =
              | R_remove_0 of 'elt t
              | R_remove_1 of 'elt t * Coq_regex_as_UCT.t * 'elt
                 * (Coq_regex_as_UCT.t * 'elt) list
              | R_remove_2 of 'elt t * Coq_regex_as_UCT.t * 'elt
                 * (Coq_regex_as_UCT.t * 'elt) list
              | R_remove_3 of 'elt t * Coq_regex_as_UCT.t * 'elt
                 * (Coq_regex_as_UCT.t * 'elt) list * 'elt t
                 * 'elt coq_R_remove

              val coq_R_remove_rect :
                key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t
                -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __
                -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1 t ->
                'a1 coq_R_remove -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1
                coq_R_remove -> 'a2

              val coq_R_remove_rec :
                key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t
                -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __
                -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1 t ->
                'a1 coq_R_remove -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1
                coq_R_remove -> 'a2

              val remove_rect :
                key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t
                -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __
                -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
                'a2) -> 'a1 t -> 'a2

              val remove_rec :
                key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t
                -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __
                -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
                'a2) -> 'a1 t -> 'a2

              val coq_R_remove_correct :
                key -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove

              val elements : 'a1 t -> 'a1 t

              val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

              type ('elt, 'a) coq_R_fold = ('elt, 'a) R.Defs.Coq_reFM.Raw.Proofs.L.coq_R_fold =
              | R_fold_0 of 'elt t * 'a
              | R_fold_1 of 'elt t * 'a * Coq_regex_as_UCT.t * 'elt
                 * (Coq_regex_as_UCT.t * 'elt) list * 'a
                 * ('elt, 'a) coq_R_fold

              val coq_R_fold_rect :
                (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) ->
                ('a1 t -> 'a2 -> Coq_regex_as_UCT.t -> 'a1 ->
                (Coq_regex_as_UCT.t * 'a1) list -> __ -> 'a2 -> ('a1, 'a2)
                coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a2 -> ('a1,
                'a2) coq_R_fold -> 'a3

              val coq_R_fold_rec :
                (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) ->
                ('a1 t -> 'a2 -> Coq_regex_as_UCT.t -> 'a1 ->
                (Coq_regex_as_UCT.t * 'a1) list -> __ -> 'a2 -> ('a1, 'a2)
                coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a2 -> ('a1,
                'a2) coq_R_fold -> 'a3

              val fold_rect :
                (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) ->
                ('a1 t -> 'a2 -> Coq_regex_as_UCT.t -> 'a1 ->
                (Coq_regex_as_UCT.t * 'a1) list -> __ -> 'a3 -> 'a3) -> 'a1 t
                -> 'a2 -> 'a3

              val fold_rec :
                (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) ->
                ('a1 t -> 'a2 -> Coq_regex_as_UCT.t -> 'a1 ->
                (Coq_regex_as_UCT.t * 'a1) list -> __ -> 'a3 -> 'a3) -> 'a1 t
                -> 'a2 -> 'a3

              val coq_R_fold_correct :
                (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2 -> ('a1,
                'a2) coq_R_fold

              val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool

              type 'elt coq_R_equal = 'elt R.Defs.Coq_reFM.Raw.Proofs.L.coq_R_equal =
              | R_equal_0 of 'elt t * 'elt t
              | R_equal_1 of 'elt t * 'elt t * Coq_regex_as_UCT.t * 'elt
                 * (Coq_regex_as_UCT.t * 'elt) list * Coq_regex_as_UCT.t
                 * 'elt * (Coq_regex_as_UCT.t * 'elt) list * bool
                 * 'elt coq_R_equal
              | R_equal_2 of 'elt t * 'elt t * Coq_regex_as_UCT.t * 'elt
                 * (Coq_regex_as_UCT.t * 'elt) list * Coq_regex_as_UCT.t
                 * 'elt * (Coq_regex_as_UCT.t * 'elt) list
                 * Coq_regex_as_UCT.t compare0
              | R_equal_3 of 'elt t * 'elt t * 'elt t * 'elt t

              val coq_R_equal_rect :
                ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2)
                -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                (Coq_regex_as_UCT.t * 'a1) list -> __ -> Coq_regex_as_UCT.t
                -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __
                -> bool -> 'a1 coq_R_equal -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t
                -> Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                list -> __ -> Coq_regex_as_UCT.t -> 'a1 ->
                (Coq_regex_as_UCT.t * 'a1) list -> __ -> Coq_regex_as_UCT.t
                compare0 -> __ -> __ -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t ->
                __ -> 'a1 t -> __ -> __ -> 'a2) -> 'a1 t -> 'a1 t -> bool ->
                'a1 coq_R_equal -> 'a2

              val coq_R_equal_rec :
                ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2)
                -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                (Coq_regex_as_UCT.t * 'a1) list -> __ -> Coq_regex_as_UCT.t
                -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __
                -> bool -> 'a1 coq_R_equal -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t
                -> Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                list -> __ -> Coq_regex_as_UCT.t -> 'a1 ->
                (Coq_regex_as_UCT.t * 'a1) list -> __ -> Coq_regex_as_UCT.t
                compare0 -> __ -> __ -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t ->
                __ -> 'a1 t -> __ -> __ -> 'a2) -> 'a1 t -> 'a1 t -> bool ->
                'a1 coq_R_equal -> 'a2

              val equal_rect :
                ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2)
                -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                (Coq_regex_as_UCT.t * 'a1) list -> __ -> Coq_regex_as_UCT.t
                -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __
                -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t ->
                'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list
                -> __ -> Coq_regex_as_UCT.t compare0 -> __ -> __ -> 'a2) ->
                ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2)
                -> 'a1 t -> 'a1 t -> 'a2

              val equal_rec :
                ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2)
                -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                (Coq_regex_as_UCT.t * 'a1) list -> __ -> Coq_regex_as_UCT.t
                -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __
                -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t ->
                'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list
                -> __ -> Coq_regex_as_UCT.t compare0 -> __ -> __ -> 'a2) ->
                ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2)
                -> 'a1 t -> 'a1 t -> 'a2

              val coq_R_equal_correct :
                ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool -> 'a1
                coq_R_equal

              val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

              val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

              val option_cons :
                key -> 'a1 option -> (key * 'a1) list -> (key * 'a1) list

              val map2_l :
                ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a3 t

              val map2_r :
                ('a1 option -> 'a2 option -> 'a3 option) -> 'a2 t -> 'a3 t

              val map2 :
                ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t ->
                'a3 t

              val combine : 'a1 t -> 'a2 t -> ('a1 option * 'a2 option) t

              val fold_right_pair :
                ('a1 -> 'a2 -> 'a3 -> 'a3) -> ('a1 * 'a2) list -> 'a3 -> 'a3

              val map2_alt :
                ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t ->
                (key * 'a3) list

              val at_least_one :
                'a1 option -> 'a2 option -> ('a1 option * 'a2 option) option

              val at_least_one_then_f :
                ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 option -> 'a2
                option -> 'a3 option
             end

            type 'elt coq_R_mem = 'elt R.Defs.Coq_reFM.Raw.Proofs.coq_R_mem =
            | R_mem_0 of 'elt tree
            | R_mem_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t * bool * 'elt coq_R_mem
            | R_mem_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t
            | R_mem_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t * bool * 'elt coq_R_mem

            val coq_R_mem_rect :
              Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree ->
              'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
              __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> ('a1 tree -> 'a1
              tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __
              -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
              Z_as_Int.t -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 ->
              'a2) -> 'a1 tree -> bool -> 'a1 coq_R_mem -> 'a2

            val coq_R_mem_rec :
              Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree ->
              'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
              __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> ('a1 tree -> 'a1
              tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __
              -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
              Z_as_Int.t -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 ->
              'a2) -> 'a1 tree -> bool -> 'a1 coq_R_mem -> 'a2

            type 'elt coq_R_find = 'elt R.Defs.Coq_reFM.Raw.Proofs.coq_R_find =
            | R_find_0 of 'elt tree
            | R_find_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t * 'elt option * 'elt coq_R_find
            | R_find_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t
            | R_find_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t * 'elt option * 'elt coq_R_find

            val coq_R_find_rect :
              Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree ->
              'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
              __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> ('a1 tree
              -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
              -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
              tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 option -> 'a1
              coq_R_find -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 option -> 'a1
              coq_R_find -> 'a2

            val coq_R_find_rec :
              Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree ->
              'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
              __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> ('a1 tree
              -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
              -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
              tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 option -> 'a1
              coq_R_find -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 option -> 'a1
              coq_R_find -> 'a2

            type 'elt coq_R_bal = 'elt R.Defs.Coq_reFM.Raw.Proofs.coq_R_bal =
            | R_bal_0 of 'elt tree * key * 'elt * 'elt tree
            | R_bal_1 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
               key * 'elt * 'elt tree * Z_as_Int.t
            | R_bal_2 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
               key * 'elt * 'elt tree * Z_as_Int.t
            | R_bal_3 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
               key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 
               'elt * 'elt tree * Z_as_Int.t
            | R_bal_4 of 'elt tree * key * 'elt * 'elt tree
            | R_bal_5 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
               key * 'elt * 'elt tree * Z_as_Int.t
            | R_bal_6 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
               key * 'elt * 'elt tree * Z_as_Int.t
            | R_bal_7 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
               key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 
               'elt * 'elt tree * Z_as_Int.t
            | R_bal_8 of 'elt tree * key * 'elt * 'elt tree

            val coq_R_bal_rect :
              ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> 'a2)
              -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree
              -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
              'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1
              tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __
              -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ ->
              __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
              __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
              __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
              -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1
              tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1
              tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree ->
              key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree ->
              key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> __ ->
              'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __
              -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
              -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
              -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ ->
              __ -> __ -> __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
              'a1 tree -> 'a1 coq_R_bal -> 'a2

            val coq_R_bal_rec :
              ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> 'a2)
              -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree
              -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
              'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1
              tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __
              -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ ->
              __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
              __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
              __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
              -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1
              tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1
              tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree ->
              key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree ->
              key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> __ ->
              'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __
              -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
              -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
              -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ ->
              __ -> __ -> __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
              'a1 tree -> 'a1 coq_R_bal -> 'a2

            type 'elt coq_R_add = 'elt R.Defs.Coq_reFM.Raw.Proofs.coq_R_add =
            | R_add_0 of 'elt tree
            | R_add_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t * 'elt tree * 'elt coq_R_add
            | R_add_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t
            | R_add_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t * 'elt tree * 'elt coq_R_add

            val coq_R_add_rect :
              key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree
              -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
              'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1 tree -> 'a1
              tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __
              -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
              Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_add ->
              'a2 -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_add -> 'a2

            val coq_R_add_rec :
              key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree
              -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
              'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1 tree -> 'a1
              tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __
              -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
              Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_add ->
              'a2 -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_add -> 'a2

            type 'elt coq_R_remove_min = 'elt R.Defs.Coq_reFM.Raw.Proofs.coq_R_remove_min =
            | R_remove_min_0 of 'elt tree * key * 'elt * 'elt tree
            | R_remove_min_1 of 'elt tree * key * 'elt * 'elt tree
               * 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t
               * ('elt tree * (key * 'elt)) * 'elt coq_R_remove_min
               * 'elt tree * (key * 'elt)

            val coq_R_remove_min_rect :
              ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1 tree
              -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree
              -> Z_as_Int.t -> __ -> ('a1 tree * (key * 'a1)) -> 'a1
              coq_R_remove_min -> 'a2 -> 'a1 tree -> (key * 'a1) -> __ ->
              'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> ('a1
              tree * (key * 'a1)) -> 'a1 coq_R_remove_min -> 'a2

            val coq_R_remove_min_rec :
              ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1 tree
              -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree
              -> Z_as_Int.t -> __ -> ('a1 tree * (key * 'a1)) -> 'a1
              coq_R_remove_min -> 'a2 -> 'a1 tree -> (key * 'a1) -> __ ->
              'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> ('a1
              tree * (key * 'a1)) -> 'a1 coq_R_remove_min -> 'a2

            type 'elt coq_R_merge = 'elt R.Defs.Coq_reFM.Raw.Proofs.coq_R_merge =
            | R_merge_0 of 'elt tree * 'elt tree
            | R_merge_1 of 'elt tree * 'elt tree * 'elt tree * key * 
               'elt * 'elt tree * Z_as_Int.t
            | R_merge_2 of 'elt tree * 'elt tree * 'elt tree * key * 
               'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 'elt
               * 'elt tree * Z_as_Int.t * 'elt tree * (key * 'elt) * 
               key * 'elt

            val coq_R_merge_rect :
              ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
              'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
              'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
              tree -> Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree
              -> Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> key ->
              'a1 -> __ -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 tree -> 'a1
              coq_R_merge -> 'a2

            val coq_R_merge_rec :
              ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
              'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
              'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
              tree -> Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree
              -> Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> key ->
              'a1 -> __ -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 tree -> 'a1
              coq_R_merge -> 'a2

            type 'elt coq_R_remove = 'elt R.Defs.Coq_reFM.Raw.Proofs.coq_R_remove =
            | R_remove_0 of 'elt tree
            | R_remove_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t * 'elt tree * 'elt coq_R_remove
            | R_remove_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t
            | R_remove_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t * 'elt tree * 'elt coq_R_remove

            val coq_R_remove_rect :
              Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree ->
              'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
              __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> ('a1 tree
              -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
              -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
              tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> 'a1
              coq_R_remove -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1
              coq_R_remove -> 'a2

            val coq_R_remove_rec :
              Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree ->
              'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
              __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> ('a1 tree
              -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
              -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
              tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> 'a1
              coq_R_remove -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1
              coq_R_remove -> 'a2

            type 'elt coq_R_concat = 'elt R.Defs.Coq_reFM.Raw.Proofs.coq_R_concat =
            | R_concat_0 of 'elt tree * 'elt tree
            | R_concat_1 of 'elt tree * 'elt tree * 'elt tree * key * 
               'elt * 'elt tree * Z_as_Int.t
            | R_concat_2 of 'elt tree * 'elt tree * 'elt tree * key * 
               'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 'elt
               * 'elt tree * Z_as_Int.t * 'elt tree * (key * 'elt)

            val coq_R_concat_rect :
              ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
              'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
              'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
              tree -> Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree
              -> Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> 'a2) ->
              'a1 tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_concat -> 'a2

            val coq_R_concat_rec :
              ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
              'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
              'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
              tree -> Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree
              -> Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> 'a2) ->
              'a1 tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_concat -> 'a2

            type 'elt coq_R_split = 'elt R.Defs.Coq_reFM.Raw.Proofs.coq_R_split =
            | R_split_0 of 'elt tree
            | R_split_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t * 'elt triple * 'elt coq_R_split * 'elt tree
               * 'elt option * 'elt tree
            | R_split_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t
            | R_split_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t * 'elt triple * 'elt coq_R_split * 'elt tree
               * 'elt option * 'elt tree

            val coq_R_split_rect :
              Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree ->
              'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
              __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1
              option -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
              key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2)
              -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
              Z_as_Int.t -> __ -> __ -> __ -> 'a1 triple -> 'a1 coq_R_split
              -> 'a2 -> 'a1 tree -> 'a1 option -> 'a1 tree -> __ -> 'a2) ->
              'a1 tree -> 'a1 triple -> 'a1 coq_R_split -> 'a2

            val coq_R_split_rec :
              Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree ->
              'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
              __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1
              option -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
              key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2)
              -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
              Z_as_Int.t -> __ -> __ -> __ -> 'a1 triple -> 'a1 coq_R_split
              -> 'a2 -> 'a1 tree -> 'a1 option -> 'a1 tree -> __ -> 'a2) ->
              'a1 tree -> 'a1 triple -> 'a1 coq_R_split -> 'a2

            type ('elt, 'x) coq_R_map_option = ('elt, 'x) R.Defs.Coq_reFM.Raw.Proofs.coq_R_map_option =
            | R_map_option_0 of 'elt tree
            | R_map_option_1 of 'elt tree * 'elt tree * key * 'elt
               * 'elt tree * Z_as_Int.t * 'x * 'x tree
               * ('elt, 'x) coq_R_map_option * 'x tree
               * ('elt, 'x) coq_R_map_option
            | R_map_option_2 of 'elt tree * 'elt tree * key * 'elt
               * 'elt tree * Z_as_Int.t * 'x tree
               * ('elt, 'x) coq_R_map_option * 'x tree
               * ('elt, 'x) coq_R_map_option

            val coq_R_map_option_rect :
              (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) -> ('a1
              tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
              -> 'a2 -> __ -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3
              -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) ->
              ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
              -> __ -> __ -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3
              -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) ->
              'a1 tree -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3

            val coq_R_map_option_rec :
              (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) -> ('a1
              tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
              -> 'a2 -> __ -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3
              -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) ->
              ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
              -> __ -> __ -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3
              -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) ->
              'a1 tree -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3

            type ('elt, 'x0, 'x) coq_R_map2_opt = ('elt, 'x0, 'x) R.Defs.Coq_reFM.Raw.Proofs.coq_R_map2_opt =
            | R_map2_opt_0 of 'elt tree * 'x0 tree
            | R_map2_opt_1 of 'elt tree * 'x0 tree * 'elt tree * key * 
               'elt * 'elt tree * Z_as_Int.t
            | R_map2_opt_2 of 'elt tree * 'x0 tree * 'elt tree * key * 
               'elt * 'elt tree * Z_as_Int.t * 'x0 tree * key * 'x0
               * 'x0 tree * Z_as_Int.t * 'x0 tree * 'x0 option * 'x0 tree
               * 'x * 'x tree * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
               * ('elt, 'x0, 'x) coq_R_map2_opt
            | R_map2_opt_3 of 'elt tree * 'x0 tree * 'elt tree * key * 
               'elt * 'elt tree * Z_as_Int.t * 'x0 tree * key * 'x0
               * 'x0 tree * Z_as_Int.t * 'x0 tree * 'x0 option * 'x0 tree
               * 'x tree * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
               * ('elt, 'x0, 'x) coq_R_map2_opt

            val coq_R_map2_opt_rect :
              (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3
              tree) -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2 tree -> __
              -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 ->
              'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a4) -> ('a1 tree -> 'a2
              tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
              -> 'a2 tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ ->
              'a2 tree -> 'a2 option -> 'a2 tree -> __ -> 'a3 -> __ -> 'a3
              tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree ->
              ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree ->
              'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
              __ -> 'a2 tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ ->
              'a2 tree -> 'a2 option -> 'a2 tree -> __ -> __ -> 'a3 tree ->
              ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2,
              'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1 tree -> 'a2 tree ->
              'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4

            val coq_R_map2_opt_rec :
              (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3
              tree) -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2 tree -> __
              -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 ->
              'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a4) -> ('a1 tree -> 'a2
              tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
              -> 'a2 tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ ->
              'a2 tree -> 'a2 option -> 'a2 tree -> __ -> 'a3 -> __ -> 'a3
              tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree ->
              ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree ->
              'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
              __ -> 'a2 tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ ->
              'a2 tree -> 'a2 option -> 'a2 tree -> __ -> __ -> 'a3 tree ->
              ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2,
              'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1 tree -> 'a2 tree ->
              'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4

            val fold' : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

            val flatten_e : 'a1 enumeration -> (key * 'a1) list
           end
         end

        type 'elt bst =
          'elt Raw.tree
          (* singleton inductive, whose constructor was Bst *)

        val this : 'a1 bst -> 'a1 Raw.tree

        type 'elt t = 'elt bst

        type key = Coq_regex_as_UCT.t

        val empty : 'a1 t

        val is_empty : 'a1 t -> bool

        val add : key -> 'a1 -> 'a1 t -> 'a1 t

        val remove : key -> 'a1 t -> 'a1 t

        val mem : key -> 'a1 t -> bool

        val find : key -> 'a1 t -> 'a1 option

        val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

        val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

        val map2 :
          ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t -> 'a3 t

        val elements : 'a1 t -> (key * 'a1) list

        val cardinal : 'a1 t -> nat

        val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

        val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool
       end

      module Coq_reFMF :
       sig
        val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

        val coq_In_dec : 'a1 Coq_reFM.t -> Coq_reFM.key -> bool
       end

      module MatchSpec :
       sig
       end

      module MatchSpecLemmas :
       sig
       end

      module Notations :
       sig
       end

      module Helpers :
       sig
        val coq_Plus : Regexes.regex -> Regexes.regex

        val coq_IterUnion : Regexes.regex list -> Regexes.regex

        val coq_IterApp : Regexes.regex list -> Regexes.regex

        val coq_Optional : Regexes.regex -> Regexes.regex

        val coq_REString : Strings.coq_String -> Regexes.regex
       end
     end

    module Coq_reFS :
     sig
      module X' :
       sig
        type t = DS.Coq_regex_as_UCT.t

        val eq_dec : DS.Coq_regex_as_UCT.t -> DS.Coq_regex_as_UCT.t -> bool

        val compare :
          DS.Coq_regex_as_UCT.t -> DS.Coq_regex_as_UCT.t -> comparison
       end

      module MSet :
       sig
        module Raw :
         sig
          type elt = DS.Coq_regex_as_UCT.t

          type tree = R.Defs.Coq_reFS.MSet.Raw.tree =
          | Leaf
          | Node of Z_as_Int.t * tree * DS.Coq_regex_as_UCT.t * tree

          val empty : tree

          val is_empty : tree -> bool

          val mem : DS.Coq_regex_as_UCT.t -> tree -> bool

          val min_elt : tree -> elt option

          val max_elt : tree -> elt option

          val choose : tree -> elt option

          val fold : (elt -> 'a1 -> 'a1) -> tree -> 'a1 -> 'a1

          val elements_aux :
            DS.Coq_regex_as_UCT.t list -> tree -> DS.Coq_regex_as_UCT.t list

          val elements : tree -> DS.Coq_regex_as_UCT.t list

          val rev_elements_aux :
            DS.Coq_regex_as_UCT.t list -> tree -> DS.Coq_regex_as_UCT.t list

          val rev_elements : tree -> DS.Coq_regex_as_UCT.t list

          val cardinal : tree -> nat

          val maxdepth : tree -> nat

          val mindepth : tree -> nat

          val for_all : (elt -> bool) -> tree -> bool

          val exists_ : (elt -> bool) -> tree -> bool

          type enumeration = R.Defs.Coq_reFS.MSet.Raw.enumeration =
          | End
          | More of elt * tree * enumeration

          val cons : tree -> enumeration -> enumeration

          val compare_more :
            DS.Coq_regex_as_UCT.t -> (enumeration -> comparison) ->
            enumeration -> comparison

          val compare_cont :
            tree -> (enumeration -> comparison) -> enumeration -> comparison

          val compare_end : enumeration -> comparison

          val compare : tree -> tree -> comparison

          val equal : tree -> tree -> bool

          val subsetl :
            (tree -> bool) -> DS.Coq_regex_as_UCT.t -> tree -> bool

          val subsetr :
            (tree -> bool) -> DS.Coq_regex_as_UCT.t -> tree -> bool

          val subset : tree -> tree -> bool

          type t = tree

          val height : t -> Z_as_Int.t

          val singleton : DS.Coq_regex_as_UCT.t -> tree

          val create : t -> DS.Coq_regex_as_UCT.t -> t -> tree

          val assert_false : t -> DS.Coq_regex_as_UCT.t -> t -> tree

          val bal : t -> DS.Coq_regex_as_UCT.t -> t -> tree

          val add : DS.Coq_regex_as_UCT.t -> tree -> tree

          val join : tree -> elt -> t -> t

          val remove_min : tree -> elt -> t -> t * elt

          val merge : tree -> tree -> tree

          val remove : DS.Coq_regex_as_UCT.t -> tree -> tree

          val concat : tree -> tree -> tree

          type triple = R.Defs.Coq_reFS.MSet.Raw.triple = { t_left : 
                                                            t; t_in : 
                                                            bool; t_right : 
                                                            t }

          val t_left : triple -> t

          val t_in : triple -> bool

          val t_right : triple -> t

          val split : DS.Coq_regex_as_UCT.t -> tree -> triple

          val inter : tree -> tree -> tree

          val diff : tree -> tree -> tree

          val union : tree -> tree -> tree

          val filter : (elt -> bool) -> tree -> tree

          val partition : (elt -> bool) -> t -> t * t

          val ltb_tree : DS.Coq_regex_as_UCT.t -> tree -> bool

          val gtb_tree : DS.Coq_regex_as_UCT.t -> tree -> bool

          val isok : tree -> bool

          module MX :
           sig
            module OrderTac :
             sig
              module OTF :
               sig
                type t = DS.Coq_regex_as_UCT.t

                val compare :
                  DS.Coq_regex_as_UCT.t -> DS.Coq_regex_as_UCT.t -> comparison

                val eq_dec :
                  DS.Coq_regex_as_UCT.t -> DS.Coq_regex_as_UCT.t -> bool
               end

              module TO :
               sig
                type t = DS.Coq_regex_as_UCT.t

                val compare :
                  DS.Coq_regex_as_UCT.t -> DS.Coq_regex_as_UCT.t -> comparison

                val eq_dec :
                  DS.Coq_regex_as_UCT.t -> DS.Coq_regex_as_UCT.t -> bool
               end
             end

            val eq_dec :
              DS.Coq_regex_as_UCT.t -> DS.Coq_regex_as_UCT.t -> bool

            val lt_dec :
              DS.Coq_regex_as_UCT.t -> DS.Coq_regex_as_UCT.t -> bool

            val eqb : DS.Coq_regex_as_UCT.t -> DS.Coq_regex_as_UCT.t -> bool
           end

          type coq_R_min_elt = R.Defs.Coq_reFS.MSet.Raw.coq_R_min_elt =
          | R_min_elt_0 of tree
          | R_min_elt_1 of tree * Z_as_Int.t * tree * DS.Coq_regex_as_UCT.t
             * tree
          | R_min_elt_2 of tree * Z_as_Int.t * tree * DS.Coq_regex_as_UCT.t
             * tree * Z_as_Int.t * tree * DS.Coq_regex_as_UCT.t * tree
             * elt option * coq_R_min_elt

          type coq_R_max_elt = R.Defs.Coq_reFS.MSet.Raw.coq_R_max_elt =
          | R_max_elt_0 of tree
          | R_max_elt_1 of tree * Z_as_Int.t * tree * DS.Coq_regex_as_UCT.t
             * tree
          | R_max_elt_2 of tree * Z_as_Int.t * tree * DS.Coq_regex_as_UCT.t
             * tree * Z_as_Int.t * tree * DS.Coq_regex_as_UCT.t * tree
             * elt option * coq_R_max_elt

          module L :
           sig
            module MO :
             sig
              module OrderTac :
               sig
                module OTF :
                 sig
                  type t = DS.Coq_regex_as_UCT.t

                  val compare :
                    DS.Coq_regex_as_UCT.t -> DS.Coq_regex_as_UCT.t ->
                    comparison

                  val eq_dec :
                    DS.Coq_regex_as_UCT.t -> DS.Coq_regex_as_UCT.t -> bool
                 end

                module TO :
                 sig
                  type t = DS.Coq_regex_as_UCT.t

                  val compare :
                    DS.Coq_regex_as_UCT.t -> DS.Coq_regex_as_UCT.t ->
                    comparison

                  val eq_dec :
                    DS.Coq_regex_as_UCT.t -> DS.Coq_regex_as_UCT.t -> bool
                 end
               end

              val eq_dec :
                DS.Coq_regex_as_UCT.t -> DS.Coq_regex_as_UCT.t -> bool

              val lt_dec :
                DS.Coq_regex_as_UCT.t -> DS.Coq_regex_as_UCT.t -> bool

              val eqb : DS.Coq_regex_as_UCT.t -> DS.Coq_regex_as_UCT.t -> bool
             end
           end

          val flatten_e : enumeration -> elt list

          type coq_R_bal = R.Defs.Coq_reFS.MSet.Raw.coq_R_bal =
          | R_bal_0 of t * DS.Coq_regex_as_UCT.t * t
          | R_bal_1 of t * DS.Coq_regex_as_UCT.t * t * Z_as_Int.t * tree
             * DS.Coq_regex_as_UCT.t * tree
          | R_bal_2 of t * DS.Coq_regex_as_UCT.t * t * Z_as_Int.t * tree
             * DS.Coq_regex_as_UCT.t * tree
          | R_bal_3 of t * DS.Coq_regex_as_UCT.t * t * Z_as_Int.t * tree
             * DS.Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
             * DS.Coq_regex_as_UCT.t * tree
          | R_bal_4 of t * DS.Coq_regex_as_UCT.t * t
          | R_bal_5 of t * DS.Coq_regex_as_UCT.t * t * Z_as_Int.t * tree
             * DS.Coq_regex_as_UCT.t * tree
          | R_bal_6 of t * DS.Coq_regex_as_UCT.t * t * Z_as_Int.t * tree
             * DS.Coq_regex_as_UCT.t * tree
          | R_bal_7 of t * DS.Coq_regex_as_UCT.t * t * Z_as_Int.t * tree
             * DS.Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
             * DS.Coq_regex_as_UCT.t * tree
          | R_bal_8 of t * DS.Coq_regex_as_UCT.t * t

          type coq_R_remove_min = R.Defs.Coq_reFS.MSet.Raw.coq_R_remove_min =
          | R_remove_min_0 of tree * elt * t
          | R_remove_min_1 of tree * elt * t * Z_as_Int.t * tree
             * DS.Coq_regex_as_UCT.t * tree * (t * elt) * coq_R_remove_min
             * t * elt

          type coq_R_merge = R.Defs.Coq_reFS.MSet.Raw.coq_R_merge =
          | R_merge_0 of tree * tree
          | R_merge_1 of tree * tree * Z_as_Int.t * tree
             * DS.Coq_regex_as_UCT.t * tree
          | R_merge_2 of tree * tree * Z_as_Int.t * tree
             * DS.Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
             * DS.Coq_regex_as_UCT.t * tree * t * elt

          type coq_R_concat = R.Defs.Coq_reFS.MSet.Raw.coq_R_concat =
          | R_concat_0 of tree * tree
          | R_concat_1 of tree * tree * Z_as_Int.t * tree
             * DS.Coq_regex_as_UCT.t * tree
          | R_concat_2 of tree * tree * Z_as_Int.t * tree
             * DS.Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
             * DS.Coq_regex_as_UCT.t * tree * t * elt

          type coq_R_inter = R.Defs.Coq_reFS.MSet.Raw.coq_R_inter =
          | R_inter_0 of tree * tree
          | R_inter_1 of tree * tree * Z_as_Int.t * tree
             * DS.Coq_regex_as_UCT.t * tree
          | R_inter_2 of tree * tree * Z_as_Int.t * tree
             * DS.Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
             * DS.Coq_regex_as_UCT.t * tree * t * bool * t * tree
             * coq_R_inter * tree * coq_R_inter
          | R_inter_3 of tree * tree * Z_as_Int.t * tree
             * DS.Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
             * DS.Coq_regex_as_UCT.t * tree * t * bool * t * tree
             * coq_R_inter * tree * coq_R_inter

          type coq_R_diff = R.Defs.Coq_reFS.MSet.Raw.coq_R_diff =
          | R_diff_0 of tree * tree
          | R_diff_1 of tree * tree * Z_as_Int.t * tree
             * DS.Coq_regex_as_UCT.t * tree
          | R_diff_2 of tree * tree * Z_as_Int.t * tree
             * DS.Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
             * DS.Coq_regex_as_UCT.t * tree * t * bool * t * tree
             * coq_R_diff * tree * coq_R_diff
          | R_diff_3 of tree * tree * Z_as_Int.t * tree
             * DS.Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
             * DS.Coq_regex_as_UCT.t * tree * t * bool * t * tree
             * coq_R_diff * tree * coq_R_diff

          type coq_R_union = R.Defs.Coq_reFS.MSet.Raw.coq_R_union =
          | R_union_0 of tree * tree
          | R_union_1 of tree * tree * Z_as_Int.t * tree
             * DS.Coq_regex_as_UCT.t * tree
          | R_union_2 of tree * tree * Z_as_Int.t * tree
             * DS.Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
             * DS.Coq_regex_as_UCT.t * tree * t * bool * t * tree
             * coq_R_union * tree * coq_R_union
         end

        module E :
         sig
          type t = DS.Coq_regex_as_UCT.t

          val compare :
            DS.Coq_regex_as_UCT.t -> DS.Coq_regex_as_UCT.t -> comparison

          val eq_dec : DS.Coq_regex_as_UCT.t -> DS.Coq_regex_as_UCT.t -> bool
         end

        type elt = DS.Coq_regex_as_UCT.t

        type t_ = Raw.t
          (* singleton inductive, whose constructor was Mkt *)

        val this : t_ -> Raw.t

        type t = t_

        val mem : elt -> t -> bool

        val add : elt -> t -> t

        val remove : elt -> t -> t

        val singleton : elt -> t

        val union : t -> t -> t

        val inter : t -> t -> t

        val diff : t -> t -> t

        val equal : t -> t -> bool

        val subset : t -> t -> bool

        val empty : t

        val is_empty : t -> bool

        val elements : t -> elt list

        val choose : t -> elt option

        val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

        val cardinal : t -> nat

        val filter : (elt -> bool) -> t -> t

        val for_all : (elt -> bool) -> t -> bool

        val exists_ : (elt -> bool) -> t -> bool

        val partition : (elt -> bool) -> t -> t * t

        val eq_dec : t -> t -> bool

        val compare : t -> t -> comparison

        val min_elt : t -> elt option

        val max_elt : t -> elt option
       end

      type elt = DS.Coq_regex_as_UCT.t

      type t = MSet.t

      val empty : t

      val is_empty : t -> bool

      val mem : elt -> t -> bool

      val add : elt -> t -> t

      val singleton : elt -> t

      val remove : elt -> t -> t

      val union : t -> t -> t

      val inter : t -> t -> t

      val diff : t -> t -> t

      val eq_dec : t -> t -> bool

      val equal : t -> t -> bool

      val subset : t -> t -> bool

      val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

      val for_all : (elt -> bool) -> t -> bool

      val exists_ : (elt -> bool) -> t -> bool

      val filter : (elt -> bool) -> t -> t

      val partition : (elt -> bool) -> t -> t * t

      val cardinal : t -> nat

      val elements : t -> elt list

      val choose : t -> elt option

      module MF :
       sig
        val eqb : DS.Coq_regex_as_UCT.t -> DS.Coq_regex_as_UCT.t -> bool
       end

      val min_elt : t -> elt option

      val max_elt : t -> elt option

      val compare : t -> t -> t compare0

      module E :
       sig
        type t = DS.Coq_regex_as_UCT.t

        val compare :
          DS.Coq_regex_as_UCT.t -> DS.Coq_regex_as_UCT.t ->
          DS.Coq_regex_as_UCT.t compare0

        val eq_dec : DS.Coq_regex_as_UCT.t -> DS.Coq_regex_as_UCT.t -> bool
       end
     end

    type coq_Table

    val emptyTable : coq_Table

    val set_Table :
      coq_Table -> DS.Regexes.regex -> R.Ty.coq_Sigma -> DS.Regexes.regex ->
      coq_Table

    val get_Table :
      coq_Table -> DS.Regexes.regex -> R.Ty.coq_Sigma -> DS.Regexes.regex
      option

    val add_state : coq_Table -> DS.Regexes.regex -> coq_Table

    val get_states : coq_Table -> Coq_reFS.t

    val get_eq : coq_Table -> DS.Regexes.regex -> DS.Regexes.regex option
   end

  module Defs :
   sig
    module FillTable :
     sig
      val mkIterUnion' : R.Defs.Regexes.regex -> R.Defs.Regexes.regex list

      val merge' :
        R.Defs.Regexes.regex list -> R.Defs.Regexes.regex list ->
        R.Defs.Regexes.regex list

      val merge'' :
        R.Defs.Regexes.regex list -> R.Defs.Regexes.regex list ->
        R.Defs.Regexes.regex list

      val merge :
        R.Defs.Regexes.regex list -> R.Defs.Regexes.regex list ->
        R.Defs.Regexes.regex list

      val mkIterApp' : R.Defs.Regexes.regex -> R.Defs.Regexes.regex list

      val canon : R.Defs.Regexes.regex -> R.Defs.Regexes.regex

      val fill_Table_all'' :
        TabTy.coq_Table -> R.Defs.Regexes.regex -> R.Ty.coq_Sigma list -> nat
        -> TabTy.coq_Table

      val fill_Table_all' :
        TabTy.coq_Table -> R.Defs.Regexes.regex -> R.Ty.coq_Sigma list -> nat
        -> TabTy.coq_Table

      val fill_Table_all :
        TabTy.coq_Table -> R.Defs.Regexes.regex -> R.Ty.coq_Sigma list -> nat
        -> TabTy.coq_Table

      val traverse_pos' : positive -> positive

      val traverse_pos : positive -> positive

      val fill_Table_all'_bin :
        TabTy.coq_Table -> R.Defs.Regexes.regex -> R.Ty.coq_Sigma list ->
        positive -> TabTy.coq_Table

      val fill_Table_all_bin :
        TabTy.coq_Table -> R.Defs.Regexes.regex -> R.Ty.coq_Sigma list ->
        positive -> TabTy.coq_Table
     end

    module Spec :
     sig
     end

    module Correct :
     sig
     end

    module Coq_binary :
     sig
     end
   end
 end

module MatcherFn :
 functor (R:T) ->
 sig
  val exp_matchb : R.Defs.Strings.coq_String -> R.Defs.Regexes.regex -> bool
 end

module DFAFn :
 functor (TabT:Coq0_T) ->
 sig
  module CoreDefs :
   sig
    val char_set : TabT.R.Defs.Regexes.regex -> TabT.R.Ty.coq_Sigma list

    val regex_depth : TabT.R.Defs.Regexes.regex -> nat

    val regex_length : TabT.R.Defs.Regexes.regex -> nat

    val coq_Brzozowski_bound' : nat -> positive

    val coq_Brzozowski_bound : TabT.R.Defs.Regexes.regex -> positive

    val fin_states : TabT.R.Defs.Coq_reFS.t -> TabT.R.Defs.Coq_reFS.t

    type coq_DFA =
      (TabT.R.Defs.Regexes.regex * TabT.TabTy.coq_Table) * TabT.R.Defs.Coq_reFS.t

    val defDFA : coq_DFA

    val coq_DFAtransition : TabT.R.Ty.coq_Sigma -> coq_DFA -> coq_DFA

    val coq_DFAtransition_list :
      TabT.R.Ty.coq_Sigma list -> coq_DFA -> coq_DFA

    val coq_DFAaccepting : coq_DFA -> bool

    val coq_DFAaccepts : TabT.R.Defs.Strings.coq_String -> coq_DFA -> bool

    val regex2dfa : TabT.R.Defs.Regexes.regex -> coq_DFA

    val dfa2regex : coq_DFA -> TabT.R.Defs.Regexes.regex
   end

  module Correct :
   sig
    module Mat :
     sig
      val exp_matchb :
        TabT.R.Defs.Strings.coq_String -> TabT.R.Defs.Regexes.regex -> bool
     end
   end
 end

module ImplFn :
 functor (ST:Coq_T) ->
 sig
  val max_pref_fn :
    ST.R.Defs.Strings.coq_String -> ST.Ty.index -> ST.Ty.coq_State ->
    ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
    option

  val extract_fsm_for_max :
    ST.R.Defs.Strings.coq_String -> ST.Ty.index ->
    (ST.Ty.coq_Label * ST.Ty.coq_State) ->
    ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
    option

  val max_prefs :
    ST.R.Defs.Strings.coq_String -> ST.Ty.index ->
    (ST.Ty.coq_Label * ST.Ty.coq_State) list ->
    (ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
    option) list

  val longer_pref :
    (ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
    option) ->
    (ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
    option) ->
    ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
    option

  val max_of_prefs :
    (ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
    option) list ->
    ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
    option

  val init_srule : ST.Defs.Coredefs.coq_Rule -> ST.Defs.Coredefs.sRule
 end

module LemmasFn :
 functor (ST:Coq_T) ->
 sig
  module IMPL :
   sig
    val max_pref_fn :
      ST.R.Defs.Strings.coq_String -> ST.Ty.index -> ST.Ty.coq_State ->
      ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
      option

    val extract_fsm_for_max :
      ST.R.Defs.Strings.coq_String -> ST.Ty.index ->
      (ST.Ty.coq_Label * ST.Ty.coq_State) ->
      ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
      option

    val max_prefs :
      ST.R.Defs.Strings.coq_String -> ST.Ty.index ->
      (ST.Ty.coq_Label * ST.Ty.coq_State) list ->
      (ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
      option) list

    val longer_pref :
      (ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
      option) ->
      (ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
      option) ->
      ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
      option

    val max_of_prefs :
      (ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
      option) list ->
      ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
      option

    val init_srule : ST.Defs.Coredefs.coq_Rule -> ST.Defs.Coredefs.sRule
   end
 end

module Coq_ImplFn :
 functor (ST:Coq_T) ->
 sig
  module LEM :
   sig
    module IMPL :
     sig
      val max_pref_fn :
        ST.R.Defs.Strings.coq_String -> ST.Ty.index -> ST.Ty.coq_State ->
        ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
        option

      val extract_fsm_for_max :
        ST.R.Defs.Strings.coq_String -> ST.Ty.index ->
        (ST.Ty.coq_Label * ST.Ty.coq_State) ->
        ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
        option

      val max_prefs :
        ST.R.Defs.Strings.coq_String -> ST.Ty.index ->
        (ST.Ty.coq_Label * ST.Ty.coq_State) list ->
        (ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
        option) list

      val longer_pref :
        (ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
        option) ->
        (ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
        option) ->
        ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
        option

      val max_of_prefs :
        (ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
        option) list ->
        ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
        option

      val init_srule : ST.Defs.Coredefs.coq_Rule -> ST.Defs.Coredefs.sRule
     end
   end

  module Lex :
   sig
    val lex' :
      ST.Defs.Coredefs.sRule list -> ST.R.Defs.Strings.coq_String ->
      ST.Ty.index -> ST.Defs.Coredefs.coq_Token
      list * ST.R.Defs.Strings.coq_String

    val lex :
      ST.Defs.Coredefs.coq_Rule list -> ST.R.Defs.Strings.coq_String ->
      ST.Defs.Coredefs.coq_Token list * ST.R.Defs.Strings.coq_String
   end
 end

module FTable :
 functor (R:T) ->
 sig
  module DS :
   sig
    module T_as_UCT :
     sig
      type t = R.Ty.coq_Sigma

      val compare : R.Ty.coq_Sigma -> R.Ty.coq_Sigma -> comparison
     end

    module T_as_UOT :
     sig
      type t = T_as_UCT.t

      val compare : t -> t -> t compare0

      val eq_dec : t -> t -> bool
     end

    module SigFS :
     sig
      module X' :
       sig
        type t = T_as_UCT.t

        val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

        val compare : T_as_UCT.t -> T_as_UCT.t -> comparison
       end

      module MSet :
       sig
        module Raw :
         sig
          type elt = T_as_UCT.t

          type tree = R.Defs.SigFS.MSet.Raw.tree =
          | Leaf
          | Node of Z_as_Int.t * tree * T_as_UCT.t * tree

          val empty : tree

          val is_empty : tree -> bool

          val mem : T_as_UCT.t -> tree -> bool

          val min_elt : tree -> elt option

          val max_elt : tree -> elt option

          val choose : tree -> elt option

          val fold : (elt -> 'a1 -> 'a1) -> tree -> 'a1 -> 'a1

          val elements_aux : T_as_UCT.t list -> tree -> T_as_UCT.t list

          val elements : tree -> T_as_UCT.t list

          val rev_elements_aux : T_as_UCT.t list -> tree -> T_as_UCT.t list

          val rev_elements : tree -> T_as_UCT.t list

          val cardinal : tree -> nat

          val maxdepth : tree -> nat

          val mindepth : tree -> nat

          val for_all : (elt -> bool) -> tree -> bool

          val exists_ : (elt -> bool) -> tree -> bool

          type enumeration = R.Defs.SigFS.MSet.Raw.enumeration =
          | End
          | More of elt * tree * enumeration

          val cons : tree -> enumeration -> enumeration

          val compare_more :
            T_as_UCT.t -> (enumeration -> comparison) -> enumeration ->
            comparison

          val compare_cont :
            tree -> (enumeration -> comparison) -> enumeration -> comparison

          val compare_end : enumeration -> comparison

          val compare : tree -> tree -> comparison

          val equal : tree -> tree -> bool

          val subsetl : (tree -> bool) -> T_as_UCT.t -> tree -> bool

          val subsetr : (tree -> bool) -> T_as_UCT.t -> tree -> bool

          val subset : tree -> tree -> bool

          type t = tree

          val height : t -> Z_as_Int.t

          val singleton : T_as_UCT.t -> tree

          val create : t -> T_as_UCT.t -> t -> tree

          val assert_false : t -> T_as_UCT.t -> t -> tree

          val bal : t -> T_as_UCT.t -> t -> tree

          val add : T_as_UCT.t -> tree -> tree

          val join : tree -> elt -> t -> t

          val remove_min : tree -> elt -> t -> t * elt

          val merge : tree -> tree -> tree

          val remove : T_as_UCT.t -> tree -> tree

          val concat : tree -> tree -> tree

          type triple = R.Defs.SigFS.MSet.Raw.triple = { t_left : t;
                                                         t_in : bool;
                                                         t_right : t }

          val t_left : triple -> t

          val t_in : triple -> bool

          val t_right : triple -> t

          val split : T_as_UCT.t -> tree -> triple

          val inter : tree -> tree -> tree

          val diff : tree -> tree -> tree

          val union : tree -> tree -> tree

          val filter : (elt -> bool) -> tree -> tree

          val partition : (elt -> bool) -> t -> t * t

          val ltb_tree : T_as_UCT.t -> tree -> bool

          val gtb_tree : T_as_UCT.t -> tree -> bool

          val isok : tree -> bool

          module MX :
           sig
            module OrderTac :
             sig
              module OTF :
               sig
                type t = T_as_UCT.t

                val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

                val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
               end

              module TO :
               sig
                type t = T_as_UCT.t

                val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

                val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
               end
             end

            val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

            val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

            val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
           end

          type coq_R_min_elt = R.Defs.SigFS.MSet.Raw.coq_R_min_elt =
          | R_min_elt_0 of tree
          | R_min_elt_1 of tree * Z_as_Int.t * tree * T_as_UCT.t * tree
          | R_min_elt_2 of tree * Z_as_Int.t * tree * T_as_UCT.t * tree
             * Z_as_Int.t * tree * T_as_UCT.t * tree * elt option
             * coq_R_min_elt

          type coq_R_max_elt = R.Defs.SigFS.MSet.Raw.coq_R_max_elt =
          | R_max_elt_0 of tree
          | R_max_elt_1 of tree * Z_as_Int.t * tree * T_as_UCT.t * tree
          | R_max_elt_2 of tree * Z_as_Int.t * tree * T_as_UCT.t * tree
             * Z_as_Int.t * tree * T_as_UCT.t * tree * elt option
             * coq_R_max_elt

          module L :
           sig
            module MO :
             sig
              module OrderTac :
               sig
                module OTF :
                 sig
                  type t = T_as_UCT.t

                  val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

                  val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
                 end

                module TO :
                 sig
                  type t = T_as_UCT.t

                  val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

                  val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
                 end
               end

              val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

              val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

              val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
             end
           end

          val flatten_e : enumeration -> elt list

          type coq_R_bal = R.Defs.SigFS.MSet.Raw.coq_R_bal =
          | R_bal_0 of t * T_as_UCT.t * t
          | R_bal_1 of t * T_as_UCT.t * t * Z_as_Int.t * tree * T_as_UCT.t
             * tree
          | R_bal_2 of t * T_as_UCT.t * t * Z_as_Int.t * tree * T_as_UCT.t
             * tree
          | R_bal_3 of t * T_as_UCT.t * t * Z_as_Int.t * tree * T_as_UCT.t
             * tree * Z_as_Int.t * tree * T_as_UCT.t * tree
          | R_bal_4 of t * T_as_UCT.t * t
          | R_bal_5 of t * T_as_UCT.t * t * Z_as_Int.t * tree * T_as_UCT.t
             * tree
          | R_bal_6 of t * T_as_UCT.t * t * Z_as_Int.t * tree * T_as_UCT.t
             * tree
          | R_bal_7 of t * T_as_UCT.t * t * Z_as_Int.t * tree * T_as_UCT.t
             * tree * Z_as_Int.t * tree * T_as_UCT.t * tree
          | R_bal_8 of t * T_as_UCT.t * t

          type coq_R_remove_min = R.Defs.SigFS.MSet.Raw.coq_R_remove_min =
          | R_remove_min_0 of tree * elt * t
          | R_remove_min_1 of tree * elt * t * Z_as_Int.t * tree * T_as_UCT.t
             * tree * (t * elt) * coq_R_remove_min * t * elt

          type coq_R_merge = R.Defs.SigFS.MSet.Raw.coq_R_merge =
          | R_merge_0 of tree * tree
          | R_merge_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * tree
          | R_merge_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * 
             tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * elt

          type coq_R_concat = R.Defs.SigFS.MSet.Raw.coq_R_concat =
          | R_concat_0 of tree * tree
          | R_concat_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * tree
          | R_concat_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * 
             tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * elt

          type coq_R_inter = R.Defs.SigFS.MSet.Raw.coq_R_inter =
          | R_inter_0 of tree * tree
          | R_inter_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * tree
          | R_inter_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * 
             tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * bool * 
             t * tree * coq_R_inter * tree * coq_R_inter
          | R_inter_3 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * 
             tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * bool * 
             t * tree * coq_R_inter * tree * coq_R_inter

          type coq_R_diff = R.Defs.SigFS.MSet.Raw.coq_R_diff =
          | R_diff_0 of tree * tree
          | R_diff_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * tree
          | R_diff_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * 
             tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * bool * 
             t * tree * coq_R_diff * tree * coq_R_diff
          | R_diff_3 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * 
             tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * bool * 
             t * tree * coq_R_diff * tree * coq_R_diff

          type coq_R_union = R.Defs.SigFS.MSet.Raw.coq_R_union =
          | R_union_0 of tree * tree
          | R_union_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * tree
          | R_union_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t * 
             tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * bool * 
             t * tree * coq_R_union * tree * coq_R_union
         end

        module E :
         sig
          type t = T_as_UCT.t

          val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

          val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
         end

        type elt = T_as_UCT.t

        type t_ = Raw.t
          (* singleton inductive, whose constructor was Mkt *)

        val this : t_ -> Raw.t

        type t = t_

        val mem : elt -> t -> bool

        val add : elt -> t -> t

        val remove : elt -> t -> t

        val singleton : elt -> t

        val union : t -> t -> t

        val inter : t -> t -> t

        val diff : t -> t -> t

        val equal : t -> t -> bool

        val subset : t -> t -> bool

        val empty : t

        val is_empty : t -> bool

        val elements : t -> elt list

        val choose : t -> elt option

        val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

        val cardinal : t -> nat

        val filter : (elt -> bool) -> t -> t

        val for_all : (elt -> bool) -> t -> bool

        val exists_ : (elt -> bool) -> t -> bool

        val partition : (elt -> bool) -> t -> t * t

        val eq_dec : t -> t -> bool

        val compare : t -> t -> comparison

        val min_elt : t -> elt option

        val max_elt : t -> elt option
       end

      type elt = T_as_UCT.t

      type t = MSet.t

      val empty : t

      val is_empty : t -> bool

      val mem : elt -> t -> bool

      val add : elt -> t -> t

      val singleton : elt -> t

      val remove : elt -> t -> t

      val union : t -> t -> t

      val inter : t -> t -> t

      val diff : t -> t -> t

      val eq_dec : t -> t -> bool

      val equal : t -> t -> bool

      val subset : t -> t -> bool

      val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

      val for_all : (elt -> bool) -> t -> bool

      val exists_ : (elt -> bool) -> t -> bool

      val filter : (elt -> bool) -> t -> t

      val partition : (elt -> bool) -> t -> t * t

      val cardinal : t -> nat

      val elements : t -> elt list

      val choose : t -> elt option

      module MF :
       sig
        val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
       end

      val min_elt : t -> elt option

      val max_elt : t -> elt option

      val compare : t -> t -> t compare0

      module E :
       sig
        type t = T_as_UCT.t

        val compare : T_as_UCT.t -> T_as_UCT.t -> T_as_UCT.t compare0

        val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
       end
     end

    module SigFSF :
     sig
      val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
     end

    module SigFM :
     sig
      module E :
       sig
        type t = T_as_UCT.t

        val compare : T_as_UCT.t -> T_as_UCT.t -> T_as_UCT.t compare0

        val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
       end

      module Raw :
       sig
        type key = T_as_UCT.t

        type 'elt tree = 'elt R.Defs.SigFM.Raw.tree =
        | Leaf
        | Node of 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t

        val tree_rect :
          'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
          Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

        val tree_rec :
          'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
          Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

        val height : 'a1 tree -> Z_as_Int.t

        val cardinal : 'a1 tree -> nat

        val empty : 'a1 tree

        val is_empty : 'a1 tree -> bool

        val mem : T_as_UCT.t -> 'a1 tree -> bool

        val find : T_as_UCT.t -> 'a1 tree -> 'a1 option

        val create : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

        val assert_false : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

        val bal : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

        val add : key -> 'a1 -> 'a1 tree -> 'a1 tree

        val remove_min :
          'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree * (key * 'a1)

        val merge : 'a1 tree -> 'a1 tree -> 'a1 tree

        val remove : T_as_UCT.t -> 'a1 tree -> 'a1 tree

        val join : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

        type 'elt triple = 'elt R.Defs.SigFM.Raw.triple = { t_left : 
                                                            'elt tree;
                                                            t_opt : 'elt
                                                                    option;
                                                            t_right : 
                                                            'elt tree }

        val t_left : 'a1 triple -> 'a1 tree

        val t_opt : 'a1 triple -> 'a1 option

        val t_right : 'a1 triple -> 'a1 tree

        val split : T_as_UCT.t -> 'a1 tree -> 'a1 triple

        val concat : 'a1 tree -> 'a1 tree -> 'a1 tree

        val elements_aux : (key * 'a1) list -> 'a1 tree -> (key * 'a1) list

        val elements : 'a1 tree -> (key * 'a1) list

        val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

        type 'elt enumeration = 'elt R.Defs.SigFM.Raw.enumeration =
        | End
        | More of key * 'elt * 'elt tree * 'elt enumeration

        val enumeration_rect :
          'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 -> 'a2) ->
          'a1 enumeration -> 'a2

        val enumeration_rec :
          'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 -> 'a2) ->
          'a1 enumeration -> 'a2

        val cons : 'a1 tree -> 'a1 enumeration -> 'a1 enumeration

        val equal_more :
          ('a1 -> 'a1 -> bool) -> T_as_UCT.t -> 'a1 -> ('a1 enumeration ->
          bool) -> 'a1 enumeration -> bool

        val equal_cont :
          ('a1 -> 'a1 -> bool) -> 'a1 tree -> ('a1 enumeration -> bool) ->
          'a1 enumeration -> bool

        val equal_end : 'a1 enumeration -> bool

        val equal : ('a1 -> 'a1 -> bool) -> 'a1 tree -> 'a1 tree -> bool

        val map : ('a1 -> 'a2) -> 'a1 tree -> 'a2 tree

        val mapi : (key -> 'a1 -> 'a2) -> 'a1 tree -> 'a2 tree

        val map_option : (key -> 'a1 -> 'a2 option) -> 'a1 tree -> 'a2 tree

        val map2_opt :
          (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3 tree)
          -> ('a2 tree -> 'a3 tree) -> 'a1 tree -> 'a2 tree -> 'a3 tree

        val map2 :
          ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 tree -> 'a2 tree ->
          'a3 tree

        module Proofs :
         sig
          module MX :
           sig
            module TO :
             sig
              type t = T_as_UCT.t
             end

            module IsTO :
             sig
             end

            module OrderTac :
             sig
             end

            val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

            val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

            val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
           end

          module PX :
           sig
            module MO :
             sig
              module TO :
               sig
                type t = T_as_UCT.t
               end

              module IsTO :
               sig
               end

              module OrderTac :
               sig
               end

              val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

              val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

              val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
             end
           end

          module L :
           sig
            module MX :
             sig
              module TO :
               sig
                type t = T_as_UCT.t
               end

              module IsTO :
               sig
               end

              module OrderTac :
               sig
               end

              val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

              val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

              val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
             end

            module PX :
             sig
              module MO :
               sig
                module TO :
                 sig
                  type t = T_as_UCT.t
                 end

                module IsTO :
                 sig
                 end

                module OrderTac :
                 sig
                 end

                val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
               end
             end

            type key = T_as_UCT.t

            type 'elt t = (T_as_UCT.t * 'elt) list

            val empty : 'a1 t

            val is_empty : 'a1 t -> bool

            val mem : key -> 'a1 t -> bool

            type 'elt coq_R_mem = 'elt R.Defs.SigFM.Raw.Proofs.L.coq_R_mem =
            | R_mem_0 of 'elt t
            | R_mem_1 of 'elt t * T_as_UCT.t * 'elt * (T_as_UCT.t * 'elt) list
            | R_mem_2 of 'elt t * T_as_UCT.t * 'elt * (T_as_UCT.t * 'elt) list
            | R_mem_3 of 'elt t * T_as_UCT.t * 'elt
               * (T_as_UCT.t * 'elt) list * bool * 'elt coq_R_mem

            val coq_R_mem_rect :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
              T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __
              -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1)
              list -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2)
              -> 'a1 t -> bool -> 'a1 coq_R_mem -> 'a2

            val coq_R_mem_rec :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
              T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __
              -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1)
              list -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2)
              -> 'a1 t -> bool -> 'a1 coq_R_mem -> 'a2

            val mem_rect :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
              T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __
              -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1)
              list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

            val mem_rec :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
              T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __
              -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1)
              list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

            val coq_R_mem_correct : key -> 'a1 t -> bool -> 'a1 coq_R_mem

            val find : key -> 'a1 t -> 'a1 option

            type 'elt coq_R_find = 'elt R.Defs.SigFM.Raw.Proofs.L.coq_R_find =
            | R_find_0 of 'elt t
            | R_find_1 of 'elt t * T_as_UCT.t * 'elt
               * (T_as_UCT.t * 'elt) list
            | R_find_2 of 'elt t * T_as_UCT.t * 'elt
               * (T_as_UCT.t * 'elt) list
            | R_find_3 of 'elt t * T_as_UCT.t * 'elt
               * (T_as_UCT.t * 'elt) list * 'elt option * 'elt coq_R_find

            val coq_R_find_rect :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
              T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __
              -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1)
              list -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2
              -> 'a2) -> 'a1 t -> 'a1 option -> 'a1 coq_R_find -> 'a2

            val coq_R_find_rec :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
              T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __
              -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1)
              list -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2
              -> 'a2) -> 'a1 t -> 'a1 option -> 'a1 coq_R_find -> 'a2

            val find_rect :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
              T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __
              -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1)
              list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

            val find_rec :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
              T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __
              -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1)
              list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

            val coq_R_find_correct :
              key -> 'a1 t -> 'a1 option -> 'a1 coq_R_find

            val add : key -> 'a1 -> 'a1 t -> 'a1 t

            type 'elt coq_R_add = 'elt R.Defs.SigFM.Raw.Proofs.L.coq_R_add =
            | R_add_0 of 'elt t
            | R_add_1 of 'elt t * T_as_UCT.t * 'elt * (T_as_UCT.t * 'elt) list
            | R_add_2 of 'elt t * T_as_UCT.t * 'elt * (T_as_UCT.t * 'elt) list
            | R_add_3 of 'elt t * T_as_UCT.t * 'elt
               * (T_as_UCT.t * 'elt) list * 'elt t * 'elt coq_R_add

            val coq_R_add_rect :
              key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
              'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
              __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1 t -> 'a1
              coq_R_add -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_add ->
              'a2

            val coq_R_add_rec :
              key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
              'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
              __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1 t -> 'a1
              coq_R_add -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_add ->
              'a2

            val add_rect :
              key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
              'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
              __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1
              t -> 'a2

            val add_rec :
              key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
              'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
              __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1
              t -> 'a2

            val coq_R_add_correct :
              key -> 'a1 -> 'a1 t -> 'a1 t -> 'a1 coq_R_add

            val remove : key -> 'a1 t -> 'a1 t

            type 'elt coq_R_remove = 'elt R.Defs.SigFM.Raw.Proofs.L.coq_R_remove =
            | R_remove_0 of 'elt t
            | R_remove_1 of 'elt t * T_as_UCT.t * 'elt
               * (T_as_UCT.t * 'elt) list
            | R_remove_2 of 'elt t * T_as_UCT.t * 'elt
               * (T_as_UCT.t * 'elt) list
            | R_remove_3 of 'elt t * T_as_UCT.t * 'elt
               * (T_as_UCT.t * 'elt) list * 'elt t * 'elt coq_R_remove

            val coq_R_remove_rect :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
              T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __
              -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1)
              list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_remove -> 'a2 ->
              'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove -> 'a2

            val coq_R_remove_rec :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
              T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __
              -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1)
              list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_remove -> 'a2 ->
              'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove -> 'a2

            val remove_rect :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
              T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __
              -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1)
              list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

            val remove_rec :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
              T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __
              -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1)
              list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

            val coq_R_remove_correct :
              key -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove

            val elements : 'a1 t -> 'a1 t

            val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

            type ('elt, 'a) coq_R_fold = ('elt, 'a) R.Defs.SigFM.Raw.Proofs.L.coq_R_fold =
            | R_fold_0 of 'elt t * 'a
            | R_fold_1 of 'elt t * 'a * T_as_UCT.t * 'elt
               * (T_as_UCT.t * 'elt) list * 'a * ('elt, 'a) coq_R_fold

            val coq_R_fold_rect :
              (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) ->
              ('a1 t -> 'a2 -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
              -> __ -> 'a2 -> ('a1, 'a2) coq_R_fold -> 'a3 -> 'a3) -> 'a1 t
              -> 'a2 -> 'a2 -> ('a1, 'a2) coq_R_fold -> 'a3

            val coq_R_fold_rec :
              (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) ->
              ('a1 t -> 'a2 -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
              -> __ -> 'a2 -> ('a1, 'a2) coq_R_fold -> 'a3 -> 'a3) -> 'a1 t
              -> 'a2 -> 'a2 -> ('a1, 'a2) coq_R_fold -> 'a3

            val fold_rect :
              (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) ->
              ('a1 t -> 'a2 -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
              -> __ -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a3

            val fold_rec :
              (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) ->
              ('a1 t -> 'a2 -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
              -> __ -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a3

            val coq_R_fold_correct :
              (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2 -> ('a1, 'a2)
              coq_R_fold

            val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool

            type 'elt coq_R_equal = 'elt R.Defs.SigFM.Raw.Proofs.L.coq_R_equal =
            | R_equal_0 of 'elt t * 'elt t
            | R_equal_1 of 'elt t * 'elt t * T_as_UCT.t * 'elt
               * (T_as_UCT.t * 'elt) list * T_as_UCT.t * 'elt
               * (T_as_UCT.t * 'elt) list * bool * 'elt coq_R_equal
            | R_equal_2 of 'elt t * 'elt t * T_as_UCT.t * 'elt
               * (T_as_UCT.t * 'elt) list * T_as_UCT.t * 'elt
               * (T_as_UCT.t * 'elt) list * T_as_UCT.t compare0
            | R_equal_3 of 'elt t * 'elt t * 'elt t * 'elt t

            val coq_R_equal_rect :
              ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) ->
              ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
              -> __ -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
              __ -> __ -> bool -> 'a1 coq_R_equal -> 'a2 -> 'a2) -> ('a1 t ->
              'a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
              T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
              T_as_UCT.t compare0 -> __ -> __ -> 'a2) -> ('a1 t -> 'a1 t ->
              'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2) -> 'a1 t -> 'a1 t ->
              bool -> 'a1 coq_R_equal -> 'a2

            val coq_R_equal_rec :
              ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) ->
              ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
              -> __ -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
              __ -> __ -> bool -> 'a1 coq_R_equal -> 'a2 -> 'a2) -> ('a1 t ->
              'a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
              T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
              T_as_UCT.t compare0 -> __ -> __ -> 'a2) -> ('a1 t -> 'a1 t ->
              'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2) -> 'a1 t -> 'a1 t ->
              bool -> 'a1 coq_R_equal -> 'a2

            val equal_rect :
              ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) ->
              ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
              -> __ -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
              __ -> __ -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1
              -> (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t compare0 -> __ ->
              __ -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ ->
              __ -> 'a2) -> 'a1 t -> 'a1 t -> 'a2

            val equal_rec :
              ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) ->
              ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
              -> __ -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
              __ -> __ -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1
              -> (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t -> 'a1 ->
              (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t compare0 -> __ ->
              __ -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ ->
              __ -> 'a2) -> 'a1 t -> 'a1 t -> 'a2

            val coq_R_equal_correct :
              ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool -> 'a1
              coq_R_equal

            val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

            val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

            val option_cons :
              key -> 'a1 option -> (key * 'a1) list -> (key * 'a1) list

            val map2_l :
              ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a3 t

            val map2_r :
              ('a1 option -> 'a2 option -> 'a3 option) -> 'a2 t -> 'a3 t

            val map2 :
              ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t ->
              'a3 t

            val combine : 'a1 t -> 'a2 t -> ('a1 option * 'a2 option) t

            val fold_right_pair :
              ('a1 -> 'a2 -> 'a3 -> 'a3) -> ('a1 * 'a2) list -> 'a3 -> 'a3

            val map2_alt :
              ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t ->
              (key * 'a3) list

            val at_least_one :
              'a1 option -> 'a2 option -> ('a1 option * 'a2 option) option

            val at_least_one_then_f :
              ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 option -> 'a2
              option -> 'a3 option
           end

          type 'elt coq_R_mem = 'elt R.Defs.SigFM.Raw.Proofs.coq_R_mem =
          | R_mem_0 of 'elt tree
          | R_mem_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * bool * 'elt coq_R_mem
          | R_mem_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t
          | R_mem_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * bool * 'elt coq_R_mem

          val coq_R_mem_rect :
            T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> bool ->
            'a1 coq_R_mem -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree -> key ->
            'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1
            tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
            __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 tree ->
            bool -> 'a1 coq_R_mem -> 'a2

          val coq_R_mem_rec :
            T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> bool ->
            'a1 coq_R_mem -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree -> key ->
            'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1
            tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
            __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 tree ->
            bool -> 'a1 coq_R_mem -> 'a2

          type 'elt coq_R_find = 'elt R.Defs.SigFM.Raw.Proofs.coq_R_find =
          | R_find_0 of 'elt tree
          | R_find_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt option * 'elt coq_R_find
          | R_find_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t
          | R_find_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt option * 'elt coq_R_find

          val coq_R_find_rect :
            T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
            option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree
            -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2)
            -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
            -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2)
            -> 'a1 tree -> 'a1 option -> 'a1 coq_R_find -> 'a2

          val coq_R_find_rec :
            T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
            option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree
            -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2)
            -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
            -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2)
            -> 'a1 tree -> 'a1 option -> 'a1 coq_R_find -> 'a2

          type 'elt coq_R_bal = 'elt R.Defs.SigFM.Raw.Proofs.coq_R_bal =
          | R_bal_0 of 'elt tree * key * 'elt * 'elt tree
          | R_bal_1 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
             key * 'elt * 'elt tree * Z_as_Int.t
          | R_bal_2 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
             key * 'elt * 'elt tree * Z_as_Int.t
          | R_bal_3 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
             key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 
             'elt * 'elt tree * Z_as_Int.t
          | R_bal_4 of 'elt tree * key * 'elt * 'elt tree
          | R_bal_5 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
             key * 'elt * 'elt tree * Z_as_Int.t
          | R_bal_6 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
             key * 'elt * 'elt tree * Z_as_Int.t
          | R_bal_7 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
             key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 
             'elt * 'elt tree * Z_as_Int.t
          | R_bal_8 of 'elt tree * key * 'elt * 'elt tree

          val coq_R_bal_rect :
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> 'a2) ->
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) ->
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> __ ->
            'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2) ->
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> __
            -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __
            -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
            -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __
            -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key ->
            'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1
            -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> key ->
            'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2) -> ('a1 tree -> key
            -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a2) -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_bal -> 'a2

          val coq_R_bal_rec :
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> 'a2) ->
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) ->
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> __ ->
            'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2) ->
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> __
            -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __
            -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
            -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __
            -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key ->
            'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1
            -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> key ->
            'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2) -> ('a1 tree -> key
            -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a2) -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_bal -> 'a2

          type 'elt coq_R_add = 'elt R.Defs.SigFM.Raw.Proofs.coq_R_add =
          | R_add_0 of 'elt tree
          | R_add_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt tree * 'elt coq_R_add
          | R_add_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t
          | R_add_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt tree * 'elt coq_R_add

          val coq_R_add_rect :
            key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
            tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) ->
            ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
            __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1
            tree -> 'a1 tree -> 'a1 coq_R_add -> 'a2

          val coq_R_add_rec :
            key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
            tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) ->
            ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
            __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1
            tree -> 'a1 tree -> 'a1 coq_R_add -> 'a2

          type 'elt coq_R_remove_min = 'elt R.Defs.SigFM.Raw.Proofs.coq_R_remove_min =
          | R_remove_min_0 of 'elt tree * key * 'elt * 'elt tree
          | R_remove_min_1 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
             * key * 'elt * 'elt tree * Z_as_Int.t
             * ('elt tree * (key * 'elt)) * 'elt coq_R_remove_min * 'elt tree
             * (key * 'elt)

          val coq_R_remove_min_rect :
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1 tree ->
            key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> ('a1 tree * (key * 'a1)) -> 'a1
            coq_R_remove_min -> 'a2 -> 'a1 tree -> (key * 'a1) -> __ -> 'a2)
            -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> ('a1 tree * (key * 'a1))
            -> 'a1 coq_R_remove_min -> 'a2

          val coq_R_remove_min_rec :
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1 tree ->
            key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> ('a1 tree * (key * 'a1)) -> 'a1
            coq_R_remove_min -> 'a2 -> 'a1 tree -> (key * 'a1) -> __ -> 'a2)
            -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> ('a1 tree * (key * 'a1))
            -> 'a1 coq_R_remove_min -> 'a2

          type 'elt coq_R_merge = 'elt R.Defs.SigFM.Raw.Proofs.coq_R_merge =
          | R_merge_0 of 'elt tree * 'elt tree
          | R_merge_1 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
             * 'elt tree * Z_as_Int.t
          | R_merge_2 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
             * 'elt tree * Z_as_Int.t * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt tree * (key * 'elt) * key * 'elt

          val coq_R_merge_rect :
            ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
            'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
            tree -> Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> key -> 'a1
            -> __ -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 tree -> 'a1
            coq_R_merge -> 'a2

          val coq_R_merge_rec :
            ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
            'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
            tree -> Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> key -> 'a1
            -> __ -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 tree -> 'a1
            coq_R_merge -> 'a2

          type 'elt coq_R_remove = 'elt R.Defs.SigFM.Raw.Proofs.coq_R_remove =
          | R_remove_0 of 'elt tree
          | R_remove_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt tree * 'elt coq_R_remove
          | R_remove_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t
          | R_remove_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt tree * 'elt coq_R_remove

          val coq_R_remove_rect :
            T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
            tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree
            -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2)
            -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
            -> __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2)
            -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_remove -> 'a2

          val coq_R_remove_rec :
            T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
            tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree
            -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2)
            -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
            -> __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2)
            -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_remove -> 'a2

          type 'elt coq_R_concat = 'elt R.Defs.SigFM.Raw.Proofs.coq_R_concat =
          | R_concat_0 of 'elt tree * 'elt tree
          | R_concat_1 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
             * 'elt tree * Z_as_Int.t
          | R_concat_2 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
             * 'elt tree * Z_as_Int.t * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt tree * (key * 'elt)

          val coq_R_concat_rect :
            ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
            'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
            tree -> Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> 'a2) -> 'a1
            tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_concat -> 'a2

          val coq_R_concat_rec :
            ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
            'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
            tree -> Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> 'a2) -> 'a1
            tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_concat -> 'a2

          type 'elt coq_R_split = 'elt R.Defs.SigFM.Raw.Proofs.coq_R_split =
          | R_split_0 of 'elt tree
          | R_split_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt triple * 'elt coq_R_split * 'elt tree
             * 'elt option * 'elt tree
          | R_split_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t
          | R_split_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt triple * 'elt coq_R_split * 'elt tree
             * 'elt option * 'elt tree

          val coq_R_split_rect :
            T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
            triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option -> 'a1
            tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
            tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option ->
            'a1 tree -> __ -> 'a2) -> 'a1 tree -> 'a1 triple -> 'a1
            coq_R_split -> 'a2

          val coq_R_split_rec :
            T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
            triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option -> 'a1
            tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
            tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option ->
            'a1 tree -> __ -> 'a2) -> 'a1 tree -> 'a1 triple -> 'a1
            coq_R_split -> 'a2

          type ('elt, 'x) coq_R_map_option = ('elt, 'x) R.Defs.SigFM.Raw.Proofs.coq_R_map_option =
          | R_map_option_0 of 'elt tree
          | R_map_option_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'x * 'x tree * ('elt, 'x) coq_R_map_option
             * 'x tree * ('elt, 'x) coq_R_map_option
          | R_map_option_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'x tree * ('elt, 'x) coq_R_map_option * 'x tree
             * ('elt, 'x) coq_R_map_option

          val coq_R_map_option_rect :
            (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) -> ('a1
            tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
            'a2 -> __ -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 ->
            'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> ('a1
            tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
            __ -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2 tree
            -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> 'a1 tree -> 'a2
            tree -> ('a1, 'a2) coq_R_map_option -> 'a3

          val coq_R_map_option_rec :
            (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) -> ('a1
            tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
            'a2 -> __ -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 ->
            'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> ('a1
            tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
            __ -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2 tree
            -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> 'a1 tree -> 'a2
            tree -> ('a1, 'a2) coq_R_map_option -> 'a3

          type ('elt, 'x0, 'x) coq_R_map2_opt = ('elt, 'x0, 'x) R.Defs.SigFM.Raw.Proofs.coq_R_map2_opt =
          | R_map2_opt_0 of 'elt tree * 'x0 tree
          | R_map2_opt_1 of 'elt tree * 'x0 tree * 'elt tree * key * 
             'elt * 'elt tree * Z_as_Int.t
          | R_map2_opt_2 of 'elt tree * 'x0 tree * 'elt tree * key * 
             'elt * 'elt tree * Z_as_Int.t * 'x0 tree * key * 'x0 * 'x0 tree
             * Z_as_Int.t * 'x0 tree * 'x0 option * 'x0 tree * 'x * 'x tree
             * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
             * ('elt, 'x0, 'x) coq_R_map2_opt
          | R_map2_opt_3 of 'elt tree * 'x0 tree * 'elt tree * key * 
             'elt * 'elt tree * Z_as_Int.t * 'x0 tree * key * 'x0 * 'x0 tree
             * Z_as_Int.t * 'x0 tree * 'x0 option * 'x0 tree * 'x tree
             * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
             * ('elt, 'x0, 'x) coq_R_map2_opt

          val coq_R_map2_opt_rect :
            (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3
            tree) -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2 tree -> __ ->
            'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1
            tree -> Z_as_Int.t -> __ -> __ -> 'a4) -> ('a1 tree -> 'a2 tree
            -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2
            tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ -> 'a2 tree ->
            'a2 option -> 'a2 tree -> __ -> 'a3 -> __ -> 'a3 tree -> ('a1,
            'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
            coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 tree ->
            key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2
            option -> 'a2 tree -> __ -> __ -> 'a3 tree -> ('a1, 'a2, 'a3)
            coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
            coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1 tree -> 'a2 tree -> 'a3 tree
            -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4

          val coq_R_map2_opt_rec :
            (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3
            tree) -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2 tree -> __ ->
            'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1
            tree -> Z_as_Int.t -> __ -> __ -> 'a4) -> ('a1 tree -> 'a2 tree
            -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2
            tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ -> 'a2 tree ->
            'a2 option -> 'a2 tree -> __ -> 'a3 -> __ -> 'a3 tree -> ('a1,
            'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
            coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 tree ->
            key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2
            option -> 'a2 tree -> __ -> __ -> 'a3 tree -> ('a1, 'a2, 'a3)
            coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
            coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1 tree -> 'a2 tree -> 'a3 tree
            -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4

          val fold' : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

          val flatten_e : 'a1 enumeration -> (key * 'a1) list
         end
       end

      type 'elt bst =
        'elt Raw.tree
        (* singleton inductive, whose constructor was Bst *)

      val this : 'a1 bst -> 'a1 Raw.tree

      type 'elt t = 'elt bst

      type key = T_as_UCT.t

      val empty : 'a1 t

      val is_empty : 'a1 t -> bool

      val add : key -> 'a1 -> 'a1 t -> 'a1 t

      val remove : key -> 'a1 t -> 'a1 t

      val mem : key -> 'a1 t -> bool

      val find : key -> 'a1 t -> 'a1 option

      val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

      val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

      val map2 :
        ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t -> 'a3 t

      val elements : 'a1 t -> (key * 'a1) list

      val cardinal : 'a1 t -> nat

      val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

      val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool
     end

    module SigFMF :
     sig
      val eqb : T_as_UCT.t -> T_as_UCT.t -> bool

      val coq_In_dec : 'a1 SigFM.t -> SigFM.key -> bool
     end

    module Strings :
     sig
      type coq_String = R.Ty.coq_Sigma list

      val coq_String_dec : coq_String -> coq_String -> bool

      val rm_empty : coq_String list -> R.Ty.coq_Sigma list list
     end

    module Regexes :
     sig
      type regex = R.Defs.Regexes.regex =
      | EmptySet
      | EmptyStr
      | Char of R.Ty.coq_Sigma
      | App of regex * regex
      | Union of regex * regex
      | Star of regex

      val regex_rect :
        'a1 -> 'a1 -> (R.Ty.coq_Sigma -> 'a1) -> (regex -> 'a1 -> regex ->
        'a1 -> 'a1) -> (regex -> 'a1 -> regex -> 'a1 -> 'a1) -> (regex -> 'a1
        -> 'a1) -> regex -> 'a1

      val regex_rec :
        'a1 -> 'a1 -> (R.Ty.coq_Sigma -> 'a1) -> (regex -> 'a1 -> regex ->
        'a1 -> 'a1) -> (regex -> 'a1 -> regex -> 'a1 -> 'a1) -> (regex -> 'a1
        -> 'a1) -> regex -> 'a1

      val regex_dec : regex -> regex -> bool

      val regex_eq : regex -> regex -> bool

      val nullable' : regex -> bool

      val nullable : regex -> bool

      val derivative : R.Ty.coq_Sigma -> regex -> regex

      val derivative_list : R.Ty.coq_Sigma list -> regex -> regex

      val re_compare : regex -> regex -> comparison
     end

    module Coq_regex_as_UCT :
     sig
      type t = Regexes.regex

      val compare : Regexes.regex -> Regexes.regex -> comparison
     end

    module Coq_regex_as_UOT :
     sig
      type t = Coq_regex_as_UCT.t

      val compare : t -> t -> t compare0

      val eq_dec : t -> t -> bool
     end

    module Coq_reFS :
     sig
      module X' :
       sig
        type t = Coq_regex_as_UCT.t

        val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

        val compare : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> comparison
       end

      module MSet :
       sig
        module Raw :
         sig
          type elt = Coq_regex_as_UCT.t

          type tree = R.Defs.Coq_reFS.MSet.Raw.tree =
          | Leaf
          | Node of Z_as_Int.t * tree * Coq_regex_as_UCT.t * tree

          val empty : tree

          val is_empty : tree -> bool

          val mem : Coq_regex_as_UCT.t -> tree -> bool

          val min_elt : tree -> elt option

          val max_elt : tree -> elt option

          val choose : tree -> elt option

          val fold : (elt -> 'a1 -> 'a1) -> tree -> 'a1 -> 'a1

          val elements_aux :
            Coq_regex_as_UCT.t list -> tree -> Coq_regex_as_UCT.t list

          val elements : tree -> Coq_regex_as_UCT.t list

          val rev_elements_aux :
            Coq_regex_as_UCT.t list -> tree -> Coq_regex_as_UCT.t list

          val rev_elements : tree -> Coq_regex_as_UCT.t list

          val cardinal : tree -> nat

          val maxdepth : tree -> nat

          val mindepth : tree -> nat

          val for_all : (elt -> bool) -> tree -> bool

          val exists_ : (elt -> bool) -> tree -> bool

          type enumeration = R.Defs.Coq_reFS.MSet.Raw.enumeration =
          | End
          | More of elt * tree * enumeration

          val cons : tree -> enumeration -> enumeration

          val compare_more :
            Coq_regex_as_UCT.t -> (enumeration -> comparison) -> enumeration
            -> comparison

          val compare_cont :
            tree -> (enumeration -> comparison) -> enumeration -> comparison

          val compare_end : enumeration -> comparison

          val compare : tree -> tree -> comparison

          val equal : tree -> tree -> bool

          val subsetl : (tree -> bool) -> Coq_regex_as_UCT.t -> tree -> bool

          val subsetr : (tree -> bool) -> Coq_regex_as_UCT.t -> tree -> bool

          val subset : tree -> tree -> bool

          type t = tree

          val height : t -> Z_as_Int.t

          val singleton : Coq_regex_as_UCT.t -> tree

          val create : t -> Coq_regex_as_UCT.t -> t -> tree

          val assert_false : t -> Coq_regex_as_UCT.t -> t -> tree

          val bal : t -> Coq_regex_as_UCT.t -> t -> tree

          val add : Coq_regex_as_UCT.t -> tree -> tree

          val join : tree -> elt -> t -> t

          val remove_min : tree -> elt -> t -> t * elt

          val merge : tree -> tree -> tree

          val remove : Coq_regex_as_UCT.t -> tree -> tree

          val concat : tree -> tree -> tree

          type triple = R.Defs.Coq_reFS.MSet.Raw.triple = { t_left : 
                                                            t; t_in : 
                                                            bool; t_right : 
                                                            t }

          val t_left : triple -> t

          val t_in : triple -> bool

          val t_right : triple -> t

          val split : Coq_regex_as_UCT.t -> tree -> triple

          val inter : tree -> tree -> tree

          val diff : tree -> tree -> tree

          val union : tree -> tree -> tree

          val filter : (elt -> bool) -> tree -> tree

          val partition : (elt -> bool) -> t -> t * t

          val ltb_tree : Coq_regex_as_UCT.t -> tree -> bool

          val gtb_tree : Coq_regex_as_UCT.t -> tree -> bool

          val isok : tree -> bool

          module MX :
           sig
            module OrderTac :
             sig
              module OTF :
               sig
                type t = Coq_regex_as_UCT.t

                val compare :
                  Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> comparison

                val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
               end

              module TO :
               sig
                type t = Coq_regex_as_UCT.t

                val compare :
                  Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> comparison

                val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
               end
             end

            val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

            val lt_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

            val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
           end

          type coq_R_min_elt = R.Defs.Coq_reFS.MSet.Raw.coq_R_min_elt =
          | R_min_elt_0 of tree
          | R_min_elt_1 of tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
             * tree
          | R_min_elt_2 of tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
             * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t * tree
             * elt option * coq_R_min_elt

          type coq_R_max_elt = R.Defs.Coq_reFS.MSet.Raw.coq_R_max_elt =
          | R_max_elt_0 of tree
          | R_max_elt_1 of tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
             * tree
          | R_max_elt_2 of tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
             * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t * tree
             * elt option * coq_R_max_elt

          module L :
           sig
            module MO :
             sig
              module OrderTac :
               sig
                module OTF :
                 sig
                  type t = Coq_regex_as_UCT.t

                  val compare :
                    Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> comparison

                  val eq_dec :
                    Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                 end

                module TO :
                 sig
                  type t = Coq_regex_as_UCT.t

                  val compare :
                    Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> comparison

                  val eq_dec :
                    Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                 end
               end

              val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

              val lt_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

              val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
             end
           end

          val flatten_e : enumeration -> elt list

          type coq_R_bal = R.Defs.Coq_reFS.MSet.Raw.coq_R_bal =
          | R_bal_0 of t * Coq_regex_as_UCT.t * t
          | R_bal_1 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * tree
             * Coq_regex_as_UCT.t * tree
          | R_bal_2 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * tree
             * Coq_regex_as_UCT.t * tree
          | R_bal_3 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * tree
             * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
             * Coq_regex_as_UCT.t * tree
          | R_bal_4 of t * Coq_regex_as_UCT.t * t
          | R_bal_5 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * tree
             * Coq_regex_as_UCT.t * tree
          | R_bal_6 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * tree
             * Coq_regex_as_UCT.t * tree
          | R_bal_7 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * tree
             * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
             * Coq_regex_as_UCT.t * tree
          | R_bal_8 of t * Coq_regex_as_UCT.t * t

          type coq_R_remove_min = R.Defs.Coq_reFS.MSet.Raw.coq_R_remove_min =
          | R_remove_min_0 of tree * elt * t
          | R_remove_min_1 of tree * elt * t * Z_as_Int.t * tree
             * Coq_regex_as_UCT.t * tree * (t * elt) * coq_R_remove_min * 
             t * elt

          type coq_R_merge = R.Defs.Coq_reFS.MSet.Raw.coq_R_merge =
          | R_merge_0 of tree * tree
          | R_merge_1 of tree * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
             * tree
          | R_merge_2 of tree * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
             * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t * tree * 
             t * elt

          type coq_R_concat = R.Defs.Coq_reFS.MSet.Raw.coq_R_concat =
          | R_concat_0 of tree * tree
          | R_concat_1 of tree * tree * Z_as_Int.t * tree
             * Coq_regex_as_UCT.t * tree
          | R_concat_2 of tree * tree * Z_as_Int.t * tree
             * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
             * Coq_regex_as_UCT.t * tree * t * elt

          type coq_R_inter = R.Defs.Coq_reFS.MSet.Raw.coq_R_inter =
          | R_inter_0 of tree * tree
          | R_inter_1 of tree * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
             * tree
          | R_inter_2 of tree * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
             * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t * tree * 
             t * bool * t * tree * coq_R_inter * tree * coq_R_inter
          | R_inter_3 of tree * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
             * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t * tree * 
             t * bool * t * tree * coq_R_inter * tree * coq_R_inter

          type coq_R_diff = R.Defs.Coq_reFS.MSet.Raw.coq_R_diff =
          | R_diff_0 of tree * tree
          | R_diff_1 of tree * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
             * tree
          | R_diff_2 of tree * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
             * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t * tree * 
             t * bool * t * tree * coq_R_diff * tree * coq_R_diff
          | R_diff_3 of tree * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
             * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t * tree * 
             t * bool * t * tree * coq_R_diff * tree * coq_R_diff

          type coq_R_union = R.Defs.Coq_reFS.MSet.Raw.coq_R_union =
          | R_union_0 of tree * tree
          | R_union_1 of tree * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
             * tree
          | R_union_2 of tree * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t
             * tree * Z_as_Int.t * tree * Coq_regex_as_UCT.t * tree * 
             t * bool * t * tree * coq_R_union * tree * coq_R_union
         end

        module E :
         sig
          type t = Coq_regex_as_UCT.t

          val compare : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> comparison

          val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
         end

        type elt = Coq_regex_as_UCT.t

        type t_ = Raw.t
          (* singleton inductive, whose constructor was Mkt *)

        val this : t_ -> Raw.t

        type t = t_

        val mem : elt -> t -> bool

        val add : elt -> t -> t

        val remove : elt -> t -> t

        val singleton : elt -> t

        val union : t -> t -> t

        val inter : t -> t -> t

        val diff : t -> t -> t

        val equal : t -> t -> bool

        val subset : t -> t -> bool

        val empty : t

        val is_empty : t -> bool

        val elements : t -> elt list

        val choose : t -> elt option

        val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

        val cardinal : t -> nat

        val filter : (elt -> bool) -> t -> t

        val for_all : (elt -> bool) -> t -> bool

        val exists_ : (elt -> bool) -> t -> bool

        val partition : (elt -> bool) -> t -> t * t

        val eq_dec : t -> t -> bool

        val compare : t -> t -> comparison

        val min_elt : t -> elt option

        val max_elt : t -> elt option
       end

      type elt = Coq_regex_as_UCT.t

      type t = MSet.t

      val empty : t

      val is_empty : t -> bool

      val mem : elt -> t -> bool

      val add : elt -> t -> t

      val singleton : elt -> t

      val remove : elt -> t -> t

      val union : t -> t -> t

      val inter : t -> t -> t

      val diff : t -> t -> t

      val eq_dec : t -> t -> bool

      val equal : t -> t -> bool

      val subset : t -> t -> bool

      val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

      val for_all : (elt -> bool) -> t -> bool

      val exists_ : (elt -> bool) -> t -> bool

      val filter : (elt -> bool) -> t -> t

      val partition : (elt -> bool) -> t -> t * t

      val cardinal : t -> nat

      val elements : t -> elt list

      val choose : t -> elt option

      module MF :
       sig
        val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
       end

      val min_elt : t -> elt option

      val max_elt : t -> elt option

      val compare : t -> t -> t compare0

      module E :
       sig
        type t = Coq_regex_as_UCT.t

        val compare :
          Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t
          compare0

        val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
       end
     end

    module Coq_reFSF :
     sig
      val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
     end

    module Coq_reFM :
     sig
      module E :
       sig
        type t = Coq_regex_as_UCT.t

        val compare :
          Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t
          compare0

        val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
       end

      module Raw :
       sig
        type key = Coq_regex_as_UCT.t

        type 'elt tree = 'elt R.Defs.Coq_reFM.Raw.tree =
        | Leaf
        | Node of 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t

        val tree_rect :
          'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
          Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

        val tree_rec :
          'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
          Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

        val height : 'a1 tree -> Z_as_Int.t

        val cardinal : 'a1 tree -> nat

        val empty : 'a1 tree

        val is_empty : 'a1 tree -> bool

        val mem : Coq_regex_as_UCT.t -> 'a1 tree -> bool

        val find : Coq_regex_as_UCT.t -> 'a1 tree -> 'a1 option

        val create : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

        val assert_false : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

        val bal : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

        val add : key -> 'a1 -> 'a1 tree -> 'a1 tree

        val remove_min :
          'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree * (key * 'a1)

        val merge : 'a1 tree -> 'a1 tree -> 'a1 tree

        val remove : Coq_regex_as_UCT.t -> 'a1 tree -> 'a1 tree

        val join : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

        type 'elt triple = 'elt R.Defs.Coq_reFM.Raw.triple = { t_left : 
                                                               'elt tree;
                                                               t_opt : 
                                                               'elt option;
                                                               t_right : 
                                                               'elt tree }

        val t_left : 'a1 triple -> 'a1 tree

        val t_opt : 'a1 triple -> 'a1 option

        val t_right : 'a1 triple -> 'a1 tree

        val split : Coq_regex_as_UCT.t -> 'a1 tree -> 'a1 triple

        val concat : 'a1 tree -> 'a1 tree -> 'a1 tree

        val elements_aux : (key * 'a1) list -> 'a1 tree -> (key * 'a1) list

        val elements : 'a1 tree -> (key * 'a1) list

        val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

        type 'elt enumeration = 'elt R.Defs.Coq_reFM.Raw.enumeration =
        | End
        | More of key * 'elt * 'elt tree * 'elt enumeration

        val enumeration_rect :
          'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 -> 'a2) ->
          'a1 enumeration -> 'a2

        val enumeration_rec :
          'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 -> 'a2) ->
          'a1 enumeration -> 'a2

        val cons : 'a1 tree -> 'a1 enumeration -> 'a1 enumeration

        val equal_more :
          ('a1 -> 'a1 -> bool) -> Coq_regex_as_UCT.t -> 'a1 -> ('a1
          enumeration -> bool) -> 'a1 enumeration -> bool

        val equal_cont :
          ('a1 -> 'a1 -> bool) -> 'a1 tree -> ('a1 enumeration -> bool) ->
          'a1 enumeration -> bool

        val equal_end : 'a1 enumeration -> bool

        val equal : ('a1 -> 'a1 -> bool) -> 'a1 tree -> 'a1 tree -> bool

        val map : ('a1 -> 'a2) -> 'a1 tree -> 'a2 tree

        val mapi : (key -> 'a1 -> 'a2) -> 'a1 tree -> 'a2 tree

        val map_option : (key -> 'a1 -> 'a2 option) -> 'a1 tree -> 'a2 tree

        val map2_opt :
          (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3 tree)
          -> ('a2 tree -> 'a3 tree) -> 'a1 tree -> 'a2 tree -> 'a3 tree

        val map2 :
          ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 tree -> 'a2 tree ->
          'a3 tree

        module Proofs :
         sig
          module MX :
           sig
            module TO :
             sig
              type t = Coq_regex_as_UCT.t
             end

            module IsTO :
             sig
             end

            module OrderTac :
             sig
             end

            val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

            val lt_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

            val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
           end

          module PX :
           sig
            module MO :
             sig
              module TO :
               sig
                type t = Coq_regex_as_UCT.t
               end

              module IsTO :
               sig
               end

              module OrderTac :
               sig
               end

              val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

              val lt_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

              val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
             end
           end

          module L :
           sig
            module MX :
             sig
              module TO :
               sig
                type t = Coq_regex_as_UCT.t
               end

              module IsTO :
               sig
               end

              module OrderTac :
               sig
               end

              val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

              val lt_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

              val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
             end

            module PX :
             sig
              module MO :
               sig
                module TO :
                 sig
                  type t = Coq_regex_as_UCT.t
                 end

                module IsTO :
                 sig
                 end

                module OrderTac :
                 sig
                 end

                val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                val lt_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
               end
             end

            type key = Coq_regex_as_UCT.t

            type 'elt t = (Coq_regex_as_UCT.t * 'elt) list

            val empty : 'a1 t

            val is_empty : 'a1 t -> bool

            val mem : key -> 'a1 t -> bool

            type 'elt coq_R_mem = 'elt R.Defs.Coq_reFM.Raw.Proofs.L.coq_R_mem =
            | R_mem_0 of 'elt t
            | R_mem_1 of 'elt t * Coq_regex_as_UCT.t * 'elt
               * (Coq_regex_as_UCT.t * 'elt) list
            | R_mem_2 of 'elt t * Coq_regex_as_UCT.t * 'elt
               * (Coq_regex_as_UCT.t * 'elt) list
            | R_mem_3 of 'elt t * Coq_regex_as_UCT.t * 'elt
               * (Coq_regex_as_UCT.t * 'elt) list * bool * 'elt coq_R_mem

            val coq_R_mem_rect :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
              'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> bool ->
              'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 t -> bool -> 'a1 coq_R_mem
              -> 'a2

            val coq_R_mem_rec :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
              'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> bool ->
              'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 t -> bool -> 'a1 coq_R_mem
              -> 'a2

            val mem_rect :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
              'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
              'a2) -> 'a1 t -> 'a2

            val mem_rec :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
              'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
              'a2) -> 'a1 t -> 'a2

            val coq_R_mem_correct : key -> 'a1 t -> bool -> 'a1 coq_R_mem

            val find : key -> 'a1 t -> 'a1 option

            type 'elt coq_R_find = 'elt R.Defs.Coq_reFM.Raw.Proofs.L.coq_R_find =
            | R_find_0 of 'elt t
            | R_find_1 of 'elt t * Coq_regex_as_UCT.t * 'elt
               * (Coq_regex_as_UCT.t * 'elt) list
            | R_find_2 of 'elt t * Coq_regex_as_UCT.t * 'elt
               * (Coq_regex_as_UCT.t * 'elt) list
            | R_find_3 of 'elt t * Coq_regex_as_UCT.t * 'elt
               * (Coq_regex_as_UCT.t * 'elt) list * 'elt option
               * 'elt coq_R_find

            val coq_R_find_rect :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
              'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1 option
              -> 'a1 coq_R_find -> 'a2 -> 'a2) -> 'a1 t -> 'a1 option -> 'a1
              coq_R_find -> 'a2

            val coq_R_find_rec :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
              'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1 option
              -> 'a1 coq_R_find -> 'a2 -> 'a2) -> 'a1 t -> 'a1 option -> 'a1
              coq_R_find -> 'a2

            val find_rect :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
              'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
              'a2) -> 'a1 t -> 'a2

            val find_rec :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
              'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
              'a2) -> 'a1 t -> 'a2

            val coq_R_find_correct :
              key -> 'a1 t -> 'a1 option -> 'a1 coq_R_find

            val add : key -> 'a1 -> 'a1 t -> 'a1 t

            type 'elt coq_R_add = 'elt R.Defs.Coq_reFM.Raw.Proofs.L.coq_R_add =
            | R_add_0 of 'elt t
            | R_add_1 of 'elt t * Coq_regex_as_UCT.t * 'elt
               * (Coq_regex_as_UCT.t * 'elt) list
            | R_add_2 of 'elt t * Coq_regex_as_UCT.t * 'elt
               * (Coq_regex_as_UCT.t * 'elt) list
            | R_add_3 of 'elt t * Coq_regex_as_UCT.t * 'elt
               * (Coq_regex_as_UCT.t * 'elt) list * 'elt t * 'elt coq_R_add

            val coq_R_add_rect :
              key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
              Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list ->
              __ -> __ -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1
              -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1 t ->
              'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_add
              -> 'a2

            val coq_R_add_rec :
              key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
              Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list ->
              __ -> __ -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1
              -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1 t ->
              'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_add
              -> 'a2

            val add_rect :
              key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
              Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list ->
              __ -> __ -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1
              -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
              'a2) -> 'a1 t -> 'a2

            val add_rec :
              key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
              Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list ->
              __ -> __ -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1
              -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
              'a2) -> 'a1 t -> 'a2

            val coq_R_add_correct :
              key -> 'a1 -> 'a1 t -> 'a1 t -> 'a1 coq_R_add

            val remove : key -> 'a1 t -> 'a1 t

            type 'elt coq_R_remove = 'elt R.Defs.Coq_reFM.Raw.Proofs.L.coq_R_remove =
            | R_remove_0 of 'elt t
            | R_remove_1 of 'elt t * Coq_regex_as_UCT.t * 'elt
               * (Coq_regex_as_UCT.t * 'elt) list
            | R_remove_2 of 'elt t * Coq_regex_as_UCT.t * 'elt
               * (Coq_regex_as_UCT.t * 'elt) list
            | R_remove_3 of 'elt t * Coq_regex_as_UCT.t * 'elt
               * (Coq_regex_as_UCT.t * 'elt) list * 'elt t * 'elt coq_R_remove

            val coq_R_remove_rect :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
              'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1 t ->
              'a1 coq_R_remove -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1
              coq_R_remove -> 'a2

            val coq_R_remove_rec :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
              'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1 t ->
              'a1 coq_R_remove -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1
              coq_R_remove -> 'a2

            val remove_rect :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
              'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
              'a2) -> 'a1 t -> 'a2

            val remove_rec :
              key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
              'a2) -> ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
              ('a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
              'a2) -> 'a1 t -> 'a2

            val coq_R_remove_correct :
              key -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove

            val elements : 'a1 t -> 'a1 t

            val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

            type ('elt, 'a) coq_R_fold = ('elt, 'a) R.Defs.Coq_reFM.Raw.Proofs.L.coq_R_fold =
            | R_fold_0 of 'elt t * 'a
            | R_fold_1 of 'elt t * 'a * Coq_regex_as_UCT.t * 'elt
               * (Coq_regex_as_UCT.t * 'elt) list * 'a * ('elt, 'a) coq_R_fold

            val coq_R_fold_rect :
              (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) ->
              ('a1 t -> 'a2 -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> 'a2 -> ('a1, 'a2)
              coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a2 -> ('a1, 'a2)
              coq_R_fold -> 'a3

            val coq_R_fold_rec :
              (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) ->
              ('a1 t -> 'a2 -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> 'a2 -> ('a1, 'a2)
              coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a2 -> ('a1, 'a2)
              coq_R_fold -> 'a3

            val fold_rect :
              (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) ->
              ('a1 t -> 'a2 -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> 'a3 -> 'a3) -> 'a1 t
              -> 'a2 -> 'a3

            val fold_rec :
              (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) ->
              ('a1 t -> 'a2 -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> 'a3 -> 'a3) -> 'a1 t
              -> 'a2 -> 'a3

            val coq_R_fold_correct :
              (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2 -> ('a1, 'a2)
              coq_R_fold

            val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool

            type 'elt coq_R_equal = 'elt R.Defs.Coq_reFM.Raw.Proofs.L.coq_R_equal =
            | R_equal_0 of 'elt t * 'elt t
            | R_equal_1 of 'elt t * 'elt t * Coq_regex_as_UCT.t * 'elt
               * (Coq_regex_as_UCT.t * 'elt) list * Coq_regex_as_UCT.t * 
               'elt * (Coq_regex_as_UCT.t * 'elt) list * bool
               * 'elt coq_R_equal
            | R_equal_2 of 'elt t * 'elt t * Coq_regex_as_UCT.t * 'elt
               * (Coq_regex_as_UCT.t * 'elt) list * Coq_regex_as_UCT.t * 
               'elt * (Coq_regex_as_UCT.t * 'elt) list
               * Coq_regex_as_UCT.t compare0
            | R_equal_3 of 'elt t * 'elt t * 'elt t * 'elt t

            val coq_R_equal_rect :
              ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) ->
              ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
              bool -> 'a1 coq_R_equal -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t ->
              Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list ->
              __ -> Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
              list -> __ -> Coq_regex_as_UCT.t compare0 -> __ -> __ -> 'a2)
              -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2)
              -> 'a1 t -> 'a1 t -> bool -> 'a1 coq_R_equal -> 'a2

            val coq_R_equal_rec :
              ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) ->
              ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
              bool -> 'a1 coq_R_equal -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t ->
              Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1) list ->
              __ -> Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
              list -> __ -> Coq_regex_as_UCT.t compare0 -> __ -> __ -> 'a2)
              -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2)
              -> 'a1 t -> 'a1 t -> bool -> 'a1 coq_R_equal -> 'a2

            val equal_rect :
              ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) ->
              ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2
              -> 'a2) -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ ->
              Coq_regex_as_UCT.t compare0 -> __ -> __ -> 'a2) -> ('a1 t ->
              'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2) -> 'a1 t ->
              'a1 t -> 'a2

            val equal_rec :
              ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) ->
              ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2
              -> 'a2) -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
              (Coq_regex_as_UCT.t * 'a1) list -> __ -> Coq_regex_as_UCT.t ->
              'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ ->
              Coq_regex_as_UCT.t compare0 -> __ -> __ -> 'a2) -> ('a1 t ->
              'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2) -> 'a1 t ->
              'a1 t -> 'a2

            val coq_R_equal_correct :
              ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool -> 'a1
              coq_R_equal

            val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

            val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

            val option_cons :
              key -> 'a1 option -> (key * 'a1) list -> (key * 'a1) list

            val map2_l :
              ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a3 t

            val map2_r :
              ('a1 option -> 'a2 option -> 'a3 option) -> 'a2 t -> 'a3 t

            val map2 :
              ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t ->
              'a3 t

            val combine : 'a1 t -> 'a2 t -> ('a1 option * 'a2 option) t

            val fold_right_pair :
              ('a1 -> 'a2 -> 'a3 -> 'a3) -> ('a1 * 'a2) list -> 'a3 -> 'a3

            val map2_alt :
              ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t ->
              (key * 'a3) list

            val at_least_one :
              'a1 option -> 'a2 option -> ('a1 option * 'a2 option) option

            val at_least_one_then_f :
              ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 option -> 'a2
              option -> 'a3 option
           end

          type 'elt coq_R_mem = 'elt R.Defs.Coq_reFM.Raw.Proofs.coq_R_mem =
          | R_mem_0 of 'elt tree
          | R_mem_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * bool * 'elt coq_R_mem
          | R_mem_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t
          | R_mem_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * bool * 'elt coq_R_mem

          val coq_R_mem_rect :
            Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) ->
            ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
            __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1
            tree -> bool -> 'a1 coq_R_mem -> 'a2

          val coq_R_mem_rec :
            Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) ->
            ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
            __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1
            tree -> bool -> 'a1 coq_R_mem -> 'a2

          type 'elt coq_R_find = 'elt R.Defs.Coq_reFM.Raw.Proofs.coq_R_find =
          | R_find_0 of 'elt tree
          | R_find_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt option * 'elt coq_R_find
          | R_find_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t
          | R_find_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt option * 'elt coq_R_find

          val coq_R_find_rect :
            Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> ('a1 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find ->
            'a2 -> 'a2) -> 'a1 tree -> 'a1 option -> 'a1 coq_R_find -> 'a2

          val coq_R_find_rec :
            Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> ('a1 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find ->
            'a2 -> 'a2) -> 'a1 tree -> 'a1 option -> 'a1 coq_R_find -> 'a2

          type 'elt coq_R_bal = 'elt R.Defs.Coq_reFM.Raw.Proofs.coq_R_bal =
          | R_bal_0 of 'elt tree * key * 'elt * 'elt tree
          | R_bal_1 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
             key * 'elt * 'elt tree * Z_as_Int.t
          | R_bal_2 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
             key * 'elt * 'elt tree * Z_as_Int.t
          | R_bal_3 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
             key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 
             'elt * 'elt tree * Z_as_Int.t
          | R_bal_4 of 'elt tree * key * 'elt * 'elt tree
          | R_bal_5 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
             key * 'elt * 'elt tree * Z_as_Int.t
          | R_bal_6 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
             key * 'elt * 'elt tree * Z_as_Int.t
          | R_bal_7 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
             key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 
             'elt * 'elt tree * Z_as_Int.t
          | R_bal_8 of 'elt tree * key * 'elt * 'elt tree

          val coq_R_bal_rect :
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> 'a2) ->
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) ->
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> __ ->
            'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2) ->
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> __
            -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __
            -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
            -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __
            -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key ->
            'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1
            -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> key ->
            'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2) -> ('a1 tree -> key
            -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a2) -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_bal -> 'a2

          val coq_R_bal_rec :
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> 'a2) ->
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) ->
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> __ ->
            'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2) ->
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> __
            -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __
            -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
            -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __
            -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key ->
            'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1
            -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> key ->
            'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2) -> ('a1 tree -> key
            -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a2) -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_bal -> 'a2

          type 'elt coq_R_add = 'elt R.Defs.Coq_reFM.Raw.Proofs.coq_R_add =
          | R_add_0 of 'elt tree
          | R_add_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt tree * 'elt coq_R_add
          | R_add_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t
          | R_add_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt tree * 'elt coq_R_add

          val coq_R_add_rect :
            key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
            tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) ->
            ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
            __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1
            tree -> 'a1 tree -> 'a1 coq_R_add -> 'a2

          val coq_R_add_rec :
            key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
            tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree ->
            key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) ->
            ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
            __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1
            tree -> 'a1 tree -> 'a1 coq_R_add -> 'a2

          type 'elt coq_R_remove_min = 'elt R.Defs.Coq_reFM.Raw.Proofs.coq_R_remove_min =
          | R_remove_min_0 of 'elt tree * key * 'elt * 'elt tree
          | R_remove_min_1 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
             * key * 'elt * 'elt tree * Z_as_Int.t
             * ('elt tree * (key * 'elt)) * 'elt coq_R_remove_min * 'elt tree
             * (key * 'elt)

          val coq_R_remove_min_rect :
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1 tree ->
            key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> ('a1 tree * (key * 'a1)) -> 'a1
            coq_R_remove_min -> 'a2 -> 'a1 tree -> (key * 'a1) -> __ -> 'a2)
            -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> ('a1 tree * (key * 'a1))
            -> 'a1 coq_R_remove_min -> 'a2

          val coq_R_remove_min_rec :
            ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1 tree ->
            key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> ('a1 tree * (key * 'a1)) -> 'a1
            coq_R_remove_min -> 'a2 -> 'a1 tree -> (key * 'a1) -> __ -> 'a2)
            -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> ('a1 tree * (key * 'a1))
            -> 'a1 coq_R_remove_min -> 'a2

          type 'elt coq_R_merge = 'elt R.Defs.Coq_reFM.Raw.Proofs.coq_R_merge =
          | R_merge_0 of 'elt tree * 'elt tree
          | R_merge_1 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
             * 'elt tree * Z_as_Int.t
          | R_merge_2 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
             * 'elt tree * Z_as_Int.t * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt tree * (key * 'elt) * key * 'elt

          val coq_R_merge_rect :
            ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
            'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
            tree -> Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> key -> 'a1
            -> __ -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 tree -> 'a1
            coq_R_merge -> 'a2

          val coq_R_merge_rec :
            ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
            'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
            tree -> Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> key -> 'a1
            -> __ -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 tree -> 'a1
            coq_R_merge -> 'a2

          type 'elt coq_R_remove = 'elt R.Defs.Coq_reFM.Raw.Proofs.coq_R_remove =
          | R_remove_0 of 'elt tree
          | R_remove_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt tree * 'elt coq_R_remove
          | R_remove_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t
          | R_remove_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt tree * 'elt coq_R_remove

          val coq_R_remove_rect :
            Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> ('a1 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove ->
            'a2 -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_remove -> 'a2

          val coq_R_remove_rec :
            Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> ('a1 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove ->
            'a2 -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_remove -> 'a2

          type 'elt coq_R_concat = 'elt R.Defs.Coq_reFM.Raw.Proofs.coq_R_concat =
          | R_concat_0 of 'elt tree * 'elt tree
          | R_concat_1 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
             * 'elt tree * Z_as_Int.t
          | R_concat_2 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
             * 'elt tree * Z_as_Int.t * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt tree * (key * 'elt)

          val coq_R_concat_rect :
            ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
            'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
            tree -> Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> 'a2) -> 'a1
            tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_concat -> 'a2

          val coq_R_concat_rec :
            ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
            'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
            'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
            tree -> Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
            Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> 'a2) -> 'a1
            tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_concat -> 'a2

          type 'elt coq_R_split = 'elt R.Defs.Coq_reFM.Raw.Proofs.coq_R_split =
          | R_split_0 of 'elt tree
          | R_split_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt triple * 'elt coq_R_split * 'elt tree
             * 'elt option * 'elt tree
          | R_split_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t
          | R_split_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'elt triple * 'elt coq_R_split * 'elt tree
             * 'elt option * 'elt tree

          val coq_R_split_rect :
            Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option ->
            'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 ->
            'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree ->
            'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
            __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1
            option -> 'a1 tree -> __ -> 'a2) -> 'a1 tree -> 'a1 triple -> 'a1
            coq_R_split -> 'a2

          val coq_R_split_rec :
            Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
            'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option ->
            'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 ->
            'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree ->
            'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
            __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1
            option -> 'a1 tree -> __ -> 'a2) -> 'a1 tree -> 'a1 triple -> 'a1
            coq_R_split -> 'a2

          type ('elt, 'x) coq_R_map_option = ('elt, 'x) R.Defs.Coq_reFM.Raw.Proofs.coq_R_map_option =
          | R_map_option_0 of 'elt tree
          | R_map_option_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'x * 'x tree * ('elt, 'x) coq_R_map_option
             * 'x tree * ('elt, 'x) coq_R_map_option
          | R_map_option_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
             * Z_as_Int.t * 'x tree * ('elt, 'x) coq_R_map_option * 'x tree
             * ('elt, 'x) coq_R_map_option

          val coq_R_map_option_rect :
            (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) -> ('a1
            tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
            'a2 -> __ -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 ->
            'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> ('a1
            tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
            __ -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2 tree
            -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> 'a1 tree -> 'a2
            tree -> ('a1, 'a2) coq_R_map_option -> 'a3

          val coq_R_map_option_rec :
            (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) -> ('a1
            tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
            'a2 -> __ -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 ->
            'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> ('a1
            tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
            __ -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2 tree
            -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> 'a1 tree -> 'a2
            tree -> ('a1, 'a2) coq_R_map_option -> 'a3

          type ('elt, 'x0, 'x) coq_R_map2_opt = ('elt, 'x0, 'x) R.Defs.Coq_reFM.Raw.Proofs.coq_R_map2_opt =
          | R_map2_opt_0 of 'elt tree * 'x0 tree
          | R_map2_opt_1 of 'elt tree * 'x0 tree * 'elt tree * key * 
             'elt * 'elt tree * Z_as_Int.t
          | R_map2_opt_2 of 'elt tree * 'x0 tree * 'elt tree * key * 
             'elt * 'elt tree * Z_as_Int.t * 'x0 tree * key * 'x0 * 'x0 tree
             * Z_as_Int.t * 'x0 tree * 'x0 option * 'x0 tree * 'x * 'x tree
             * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
             * ('elt, 'x0, 'x) coq_R_map2_opt
          | R_map2_opt_3 of 'elt tree * 'x0 tree * 'elt tree * key * 
             'elt * 'elt tree * Z_as_Int.t * 'x0 tree * key * 'x0 * 'x0 tree
             * Z_as_Int.t * 'x0 tree * 'x0 option * 'x0 tree * 'x tree
             * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
             * ('elt, 'x0, 'x) coq_R_map2_opt

          val coq_R_map2_opt_rect :
            (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3
            tree) -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2 tree -> __ ->
            'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1
            tree -> Z_as_Int.t -> __ -> __ -> 'a4) -> ('a1 tree -> 'a2 tree
            -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2
            tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ -> 'a2 tree ->
            'a2 option -> 'a2 tree -> __ -> 'a3 -> __ -> 'a3 tree -> ('a1,
            'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
            coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 tree ->
            key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2
            option -> 'a2 tree -> __ -> __ -> 'a3 tree -> ('a1, 'a2, 'a3)
            coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
            coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1 tree -> 'a2 tree -> 'a3 tree
            -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4

          val coq_R_map2_opt_rec :
            (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3
            tree) -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2 tree -> __ ->
            'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1
            tree -> Z_as_Int.t -> __ -> __ -> 'a4) -> ('a1 tree -> 'a2 tree
            -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2
            tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ -> 'a2 tree ->
            'a2 option -> 'a2 tree -> __ -> 'a3 -> __ -> 'a3 tree -> ('a1,
            'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
            coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1
            tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 tree ->
            key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2
            option -> 'a2 tree -> __ -> __ -> 'a3 tree -> ('a1, 'a2, 'a3)
            coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
            coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1 tree -> 'a2 tree -> 'a3 tree
            -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4

          val fold' : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

          val flatten_e : 'a1 enumeration -> (key * 'a1) list
         end
       end

      type 'elt bst =
        'elt Raw.tree
        (* singleton inductive, whose constructor was Bst *)

      val this : 'a1 bst -> 'a1 Raw.tree

      type 'elt t = 'elt bst

      type key = Coq_regex_as_UCT.t

      val empty : 'a1 t

      val is_empty : 'a1 t -> bool

      val add : key -> 'a1 -> 'a1 t -> 'a1 t

      val remove : key -> 'a1 t -> 'a1 t

      val mem : key -> 'a1 t -> bool

      val find : key -> 'a1 t -> 'a1 option

      val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

      val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

      val map2 :
        ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t -> 'a3 t

      val elements : 'a1 t -> (key * 'a1) list

      val cardinal : 'a1 t -> nat

      val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

      val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool
     end

    module Coq_reFMF :
     sig
      val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

      val coq_In_dec : 'a1 Coq_reFM.t -> Coq_reFM.key -> bool
     end

    module MatchSpec :
     sig
     end

    module MatchSpecLemmas :
     sig
     end

    module Notations :
     sig
     end

    module Helpers :
     sig
      val coq_Plus : Regexes.regex -> Regexes.regex

      val coq_IterUnion : Regexes.regex list -> Regexes.regex

      val coq_IterApp : Regexes.regex list -> Regexes.regex

      val coq_Optional : Regexes.regex -> Regexes.regex

      val coq_REString : Strings.coq_String -> Regexes.regex
     end
   end

  module Sigma_as_UOT :
   sig
    type t = R.Defs.T_as_UCT.t

    val compare : t -> t -> t compare0

    val eq_dec : t -> t -> bool
   end

  module Coq_regex_as_UOT :
   sig
    type t = R.Defs.Coq_regex_as_UCT.t

    val compare : t -> t -> t compare0

    val eq_dec : t -> t -> bool
   end

  module Coq_pair_as_UOT :
   sig
    module FA :
     sig
     end

    module FB :
     sig
     end

    type t = R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t

    val compare :
      t -> t -> (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) compare0

    val eq_dec : t -> t -> bool
   end

  module FM :
   sig
    module E :
     sig
      type t = R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t

      val compare :
        (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
        (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
        (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) compare0

      val eq_dec :
        (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
        (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> bool
     end

    module Raw :
     sig
      type key = R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t

      type 'elt tree =
      | Leaf
      | Node of 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t

      val tree_rect :
        'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
        Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

      val tree_rec :
        'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
        Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

      val height : 'a1 tree -> Z_as_Int.t

      val cardinal : 'a1 tree -> nat

      val empty : 'a1 tree

      val is_empty : 'a1 tree -> bool

      val mem :
        (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 tree -> bool

      val find :
        (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 tree -> 'a1
        option

      val create : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

      val assert_false : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

      val bal : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

      val add : key -> 'a1 -> 'a1 tree -> 'a1 tree

      val remove_min :
        'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree * (key * 'a1)

      val merge : 'a1 tree -> 'a1 tree -> 'a1 tree

      val remove :
        (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 tree -> 'a1
        tree

      val join : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

      type 'elt triple = { t_left : 'elt tree; t_opt : 'elt option;
                           t_right : 'elt tree }

      val t_left : 'a1 triple -> 'a1 tree

      val t_opt : 'a1 triple -> 'a1 option

      val t_right : 'a1 triple -> 'a1 tree

      val split :
        (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 tree -> 'a1
        triple

      val concat : 'a1 tree -> 'a1 tree -> 'a1 tree

      val elements_aux : (key * 'a1) list -> 'a1 tree -> (key * 'a1) list

      val elements : 'a1 tree -> (key * 'a1) list

      val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

      type 'elt enumeration =
      | End
      | More of key * 'elt * 'elt tree * 'elt enumeration

      val enumeration_rect :
        'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 -> 'a2) ->
        'a1 enumeration -> 'a2

      val enumeration_rec :
        'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 -> 'a2) ->
        'a1 enumeration -> 'a2

      val cons : 'a1 tree -> 'a1 enumeration -> 'a1 enumeration

      val equal_more :
        ('a1 -> 'a1 -> bool) ->
        (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 -> ('a1
        enumeration -> bool) -> 'a1 enumeration -> bool

      val equal_cont :
        ('a1 -> 'a1 -> bool) -> 'a1 tree -> ('a1 enumeration -> bool) -> 'a1
        enumeration -> bool

      val equal_end : 'a1 enumeration -> bool

      val equal : ('a1 -> 'a1 -> bool) -> 'a1 tree -> 'a1 tree -> bool

      val map : ('a1 -> 'a2) -> 'a1 tree -> 'a2 tree

      val mapi : (key -> 'a1 -> 'a2) -> 'a1 tree -> 'a2 tree

      val map_option : (key -> 'a1 -> 'a2 option) -> 'a1 tree -> 'a2 tree

      val map2_opt :
        (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3 tree) ->
        ('a2 tree -> 'a3 tree) -> 'a1 tree -> 'a2 tree -> 'a3 tree

      val map2 :
        ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 tree -> 'a2 tree ->
        'a3 tree

      module Proofs :
       sig
        module MX :
         sig
          module TO :
           sig
            type t = R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t
           end

          module IsTO :
           sig
           end

          module OrderTac :
           sig
           end

          val eq_dec :
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> bool

          val lt_dec :
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> bool

          val eqb :
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> bool
         end

        module PX :
         sig
          module MO :
           sig
            module TO :
             sig
              type t = R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t
             end

            module IsTO :
             sig
             end

            module OrderTac :
             sig
             end

            val eq_dec :
              (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
              (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> bool

            val lt_dec :
              (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
              (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> bool

            val eqb :
              (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
              (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> bool
           end
         end

        module L :
         sig
          module MX :
           sig
            module TO :
             sig
              type t = R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t
             end

            module IsTO :
             sig
             end

            module OrderTac :
             sig
             end

            val eq_dec :
              (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
              (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> bool

            val lt_dec :
              (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
              (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> bool

            val eqb :
              (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
              (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> bool
           end

          module PX :
           sig
            module MO :
             sig
              module TO :
               sig
                type t = R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t
               end

              module IsTO :
               sig
               end

              module OrderTac :
               sig
               end

              val eq_dec :
                (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
                (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> bool

              val lt_dec :
                (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
                (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> bool

              val eqb :
                (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
                (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> bool
             end
           end

          type key = R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t

          type 'elt t =
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt) list

          val empty : 'a1 t

          val is_empty : 'a1 t -> bool

          val mem : key -> 'a1 t -> bool

          type 'elt coq_R_mem =
          | R_mem_0 of 'elt t
          | R_mem_1 of 'elt t
             * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt
             * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt) list
          | R_mem_2 of 'elt t
             * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt
             * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt) list
          | R_mem_3 of 'elt t
             * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt
             * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt) list
             * bool * 'elt coq_R_mem

          val coq_R_mem_rect :
            key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> 'a2) -> ('a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> 'a2) -> ('a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 t
            -> bool -> 'a1 coq_R_mem -> 'a2

          val coq_R_mem_rec :
            key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> 'a2) -> ('a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> 'a2) -> ('a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 t
            -> bool -> 'a1 coq_R_mem -> 'a2

          val mem_rect :
            key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> 'a2) -> ('a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> 'a2) -> ('a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

          val mem_rec :
            key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> 'a2) -> ('a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> 'a2) -> ('a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

          val coq_R_mem_correct : key -> 'a1 t -> bool -> 'a1 coq_R_mem

          val find : key -> 'a1 t -> 'a1 option

          type 'elt coq_R_find =
          | R_find_0 of 'elt t
          | R_find_1 of 'elt t
             * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt
             * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt) list
          | R_find_2 of 'elt t
             * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt
             * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt) list
          | R_find_3 of 'elt t
             * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt
             * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt) list
             * 'elt option * 'elt coq_R_find

          val coq_R_find_rect :
            key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> 'a2) -> ('a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> 'a2) -> ('a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) ->
            'a1 t -> 'a1 option -> 'a1 coq_R_find -> 'a2

          val coq_R_find_rec :
            key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> 'a2) -> ('a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> 'a2) -> ('a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) ->
            'a1 t -> 'a1 option -> 'a1 coq_R_find -> 'a2

          val find_rect :
            key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> 'a2) -> ('a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> 'a2) -> ('a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

          val find_rec :
            key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> 'a2) -> ('a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> 'a2) -> ('a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

          val coq_R_find_correct :
            key -> 'a1 t -> 'a1 option -> 'a1 coq_R_find

          val add : key -> 'a1 -> 'a1 t -> 'a1 t

          type 'elt coq_R_add =
          | R_add_0 of 'elt t
          | R_add_1 of 'elt t
             * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt
             * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt) list
          | R_add_2 of 'elt t
             * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt
             * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt) list
          | R_add_3 of 'elt t
             * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt
             * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt) list
             * 'elt t * 'elt coq_R_add

          val coq_R_add_rect :
            key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> 'a2) -> ('a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> 'a2) -> ('a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 t
            -> 'a1 t -> 'a1 coq_R_add -> 'a2

          val coq_R_add_rec :
            key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> 'a2) -> ('a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> 'a2) -> ('a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 t
            -> 'a1 t -> 'a1 coq_R_add -> 'a2

          val add_rect :
            key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> 'a2) -> ('a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> 'a2) -> ('a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

          val add_rec :
            key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> 'a2) -> ('a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> 'a2) -> ('a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

          val coq_R_add_correct :
            key -> 'a1 -> 'a1 t -> 'a1 t -> 'a1 coq_R_add

          val remove : key -> 'a1 t -> 'a1 t

          type 'elt coq_R_remove =
          | R_remove_0 of 'elt t
          | R_remove_1 of 'elt t
             * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt
             * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt) list
          | R_remove_2 of 'elt t
             * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt
             * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt) list
          | R_remove_3 of 'elt t
             * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt
             * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt) list
             * 'elt t * 'elt coq_R_remove

          val coq_R_remove_rect :
            key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> 'a2) -> ('a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> 'a2) -> ('a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> 'a1
            t -> 'a1 t -> 'a1 coq_R_remove -> 'a2

          val coq_R_remove_rec :
            key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> 'a2) -> ('a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> 'a2) -> ('a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> 'a1
            t -> 'a1 t -> 'a1 coq_R_remove -> 'a2

          val remove_rect :
            key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> 'a2) -> ('a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> 'a2) -> ('a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

          val remove_rec :
            key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> 'a2) -> ('a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> 'a2) -> ('a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

          val coq_R_remove_correct : key -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove

          val elements : 'a1 t -> 'a1 t

          val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

          type ('elt, 'a) coq_R_fold =
          | R_fold_0 of 'elt t * 'a
          | R_fold_1 of 'elt t * 'a
             * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt
             * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt) list
             * 'a * ('elt, 'a) coq_R_fold

          val coq_R_fold_rect :
            (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) -> ('a1
            t -> 'a2 -> (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
            'a1 -> ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
            list -> __ -> 'a2 -> ('a1, 'a2) coq_R_fold -> 'a3 -> 'a3) -> 'a1
            t -> 'a2 -> 'a2 -> ('a1, 'a2) coq_R_fold -> 'a3

          val coq_R_fold_rec :
            (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) -> ('a1
            t -> 'a2 -> (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
            'a1 -> ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
            list -> __ -> 'a2 -> ('a1, 'a2) coq_R_fold -> 'a3 -> 'a3) -> 'a1
            t -> 'a2 -> 'a2 -> ('a1, 'a2) coq_R_fold -> 'a3

          val fold_rect :
            (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) -> ('a1
            t -> 'a2 -> (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
            'a1 -> ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
            list -> __ -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a3

          val fold_rec :
            (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) -> ('a1
            t -> 'a2 -> (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
            'a1 -> ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
            list -> __ -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a3

          val coq_R_fold_correct :
            (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2 -> ('a1, 'a2)
            coq_R_fold

          val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool

          type 'elt coq_R_equal =
          | R_equal_0 of 'elt t * 'elt t
          | R_equal_1 of 'elt t * 'elt t
             * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt
             * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt) list
             * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt
             * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt) list
             * bool * 'elt coq_R_equal
          | R_equal_2 of 'elt t * 'elt t
             * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt
             * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt) list
             * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt
             * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt) list
             * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) compare0
          | R_equal_3 of 'elt t * 'elt t * 'elt t * 'elt t

          val coq_R_equal_rect :
            ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) ->
            ('a1 t -> 'a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> bool -> 'a1 coq_R_equal -> 'a2 -> 'a2) -> ('a1
            t -> 'a1 t -> (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
            'a1 -> ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
            list -> __ -> (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
            'a1 -> ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
            list -> __ -> (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t)
            compare0 -> __ -> __ -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ ->
            'a1 t -> __ -> __ -> 'a2) -> 'a1 t -> 'a1 t -> bool -> 'a1
            coq_R_equal -> 'a2

          val coq_R_equal_rec :
            ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) ->
            ('a1 t -> 'a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> bool -> 'a1 coq_R_equal -> 'a2 -> 'a2) -> ('a1
            t -> 'a1 t -> (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
            'a1 -> ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
            list -> __ -> (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
            'a1 -> ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
            list -> __ -> (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t)
            compare0 -> __ -> __ -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ ->
            'a1 t -> __ -> __ -> 'a2) -> 'a1 t -> 'a1 t -> bool -> 'a1
            coq_R_equal -> 'a2

          val equal_rect :
            ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) ->
            ('a1 t -> 'a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) compare0 ->
            __ -> __ -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __
            -> __ -> 'a2) -> 'a1 t -> 'a1 t -> 'a2

          val equal_rec :
            ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) ->
            ('a1 t -> 'a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> __ -> __ -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t ->
            (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
            ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1) list ->
            __ -> (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) compare0 ->
            __ -> __ -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __
            -> __ -> 'a2) -> 'a1 t -> 'a1 t -> 'a2

          val coq_R_equal_correct :
            ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool -> 'a1 coq_R_equal

          val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

          val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

          val option_cons :
            key -> 'a1 option -> (key * 'a1) list -> (key * 'a1) list

          val map2_l :
            ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a3 t

          val map2_r :
            ('a1 option -> 'a2 option -> 'a3 option) -> 'a2 t -> 'a3 t

          val map2 :
            ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t -> 'a3
            t

          val combine : 'a1 t -> 'a2 t -> ('a1 option * 'a2 option) t

          val fold_right_pair :
            ('a1 -> 'a2 -> 'a3 -> 'a3) -> ('a1 * 'a2) list -> 'a3 -> 'a3

          val map2_alt :
            ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t ->
            (key * 'a3) list

          val at_least_one :
            'a1 option -> 'a2 option -> ('a1 option * 'a2 option) option

          val at_least_one_then_f :
            ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 option -> 'a2
            option -> 'a3 option
         end

        type 'elt coq_R_mem =
        | R_mem_0 of 'elt tree
        | R_mem_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * bool * 'elt coq_R_mem
        | R_mem_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t
        | R_mem_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * bool * 'elt coq_R_mem

        val coq_R_mem_rect :
          (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> ('a1 tree -> __
          -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 ->
          'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
          key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> bool ->
          'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 tree -> bool -> 'a1 coq_R_mem
          -> 'a2

        val coq_R_mem_rec :
          (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> ('a1 tree -> __
          -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 ->
          'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
          key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> bool ->
          'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 tree -> bool -> 'a1 coq_R_mem
          -> 'a2

        type 'elt coq_R_find =
        | R_find_0 of 'elt tree
        | R_find_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * 'elt option * 'elt coq_R_find
        | R_find_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t
        | R_find_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * 'elt option * 'elt coq_R_find

        val coq_R_find_rect :
          (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> ('a1 tree -> __
          -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2
          -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
          key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
          option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 option
          -> 'a1 coq_R_find -> 'a2

        val coq_R_find_rec :
          (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> ('a1 tree -> __
          -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2
          -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
          key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
          option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 option
          -> 'a1 coq_R_find -> 'a2

        type 'elt coq_R_bal =
        | R_bal_0 of 'elt tree * key * 'elt * 'elt tree
        | R_bal_1 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
           key * 'elt * 'elt tree * Z_as_Int.t
        | R_bal_2 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
           key * 'elt * 'elt tree * Z_as_Int.t
        | R_bal_3 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
           key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 'elt
           * 'elt tree * Z_as_Int.t
        | R_bal_4 of 'elt tree * key * 'elt * 'elt tree
        | R_bal_5 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
           key * 'elt * 'elt tree * Z_as_Int.t
        | R_bal_6 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
           key * 'elt * 'elt tree * Z_as_Int.t
        | R_bal_7 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
           key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 'elt
           * 'elt tree * Z_as_Int.t
        | R_bal_8 of 'elt tree * key * 'elt * 'elt tree

        val coq_R_bal_rect :
          ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> 'a2) ->
          ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key
          -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1
          tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key ->
          'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) ->
          ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key
          -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree ->
          key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2) -> ('a1 tree ->
          key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> __ -> 'a2) ->
          ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1
          tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
          'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __
          -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
          __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
          -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
          __ -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
          -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ ->
          __ -> __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree
          -> 'a1 coq_R_bal -> 'a2

        val coq_R_bal_rec :
          ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> 'a2) ->
          ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key
          -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1
          tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key ->
          'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) ->
          ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key
          -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree ->
          key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2) -> ('a1 tree ->
          key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> __ -> 'a2) ->
          ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1
          tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
          'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __
          -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
          __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
          -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
          __ -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
          -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ ->
          __ -> __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree
          -> 'a1 coq_R_bal -> 'a2

        type 'elt coq_R_add =
        | R_add_0 of 'elt tree
        | R_add_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * 'elt tree * 'elt coq_R_add
        | R_add_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t
        | R_add_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * 'elt tree * 'elt coq_R_add

        val coq_R_add_rect :
          key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
          key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree
          -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree -> key ->
          'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1
          tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
          __ -> __ -> 'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 tree ->
          'a1 tree -> 'a1 coq_R_add -> 'a2

        val coq_R_add_rec :
          key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
          key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree
          -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree -> key ->
          'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1
          tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
          __ -> __ -> 'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 tree ->
          'a1 tree -> 'a1 coq_R_add -> 'a2

        type 'elt coq_R_remove_min =
        | R_remove_min_0 of 'elt tree * key * 'elt * 'elt tree
        | R_remove_min_1 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
           * key * 'elt * 'elt tree * Z_as_Int.t * ('elt tree * (key * 'elt))
           * 'elt coq_R_remove_min * 'elt tree * (key * 'elt)

        val coq_R_remove_min_rect :
          ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1 tree ->
          key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> ('a1 tree * (key * 'a1)) -> 'a1
          coq_R_remove_min -> 'a2 -> 'a1 tree -> (key * 'a1) -> __ -> 'a2) ->
          'a1 tree -> key -> 'a1 -> 'a1 tree -> ('a1 tree * (key * 'a1)) ->
          'a1 coq_R_remove_min -> 'a2

        val coq_R_remove_min_rec :
          ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1 tree ->
          key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> ('a1 tree * (key * 'a1)) -> 'a1
          coq_R_remove_min -> 'a2 -> 'a1 tree -> (key * 'a1) -> __ -> 'a2) ->
          'a1 tree -> key -> 'a1 -> 'a1 tree -> ('a1 tree * (key * 'a1)) ->
          'a1 coq_R_remove_min -> 'a2

        type 'elt coq_R_merge =
        | R_merge_0 of 'elt tree * 'elt tree
        | R_merge_1 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
           * 'elt tree * Z_as_Int.t
        | R_merge_2 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
           * 'elt tree * Z_as_Int.t * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * 'elt tree * (key * 'elt) * key * 'elt

        val coq_R_merge_rect :
          ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1
          tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a2) ->
          ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> key -> 'a1 ->
          __ -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_merge
          -> 'a2

        val coq_R_merge_rec :
          ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1
          tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a2) ->
          ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> key -> 'a1 ->
          __ -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_merge
          -> 'a2

        type 'elt coq_R_remove =
        | R_remove_0 of 'elt tree
        | R_remove_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * 'elt tree * 'elt coq_R_remove
        | R_remove_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t
        | R_remove_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * 'elt tree * 'elt coq_R_remove

        val coq_R_remove_rect :
          (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> ('a1 tree -> __
          -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2
          -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
          key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree
          -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1
          coq_R_remove -> 'a2

        val coq_R_remove_rec :
          (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> ('a1 tree -> __
          -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2
          -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
          key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree
          -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1
          coq_R_remove -> 'a2

        type 'elt coq_R_concat =
        | R_concat_0 of 'elt tree * 'elt tree
        | R_concat_1 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
           * 'elt tree * Z_as_Int.t
        | R_concat_2 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
           * 'elt tree * Z_as_Int.t * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * 'elt tree * (key * 'elt)

        val coq_R_concat_rect :
          ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1
          tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a2) ->
          ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> 'a2) -> 'a1
          tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_concat -> 'a2

        val coq_R_concat_rec :
          ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1
          tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a2) ->
          ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> 'a2) -> 'a1
          tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_concat -> 'a2

        type 'elt coq_R_split =
        | R_split_0 of 'elt tree
        | R_split_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * 'elt triple * 'elt coq_R_split * 'elt tree
           * 'elt option * 'elt tree
        | R_split_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t
        | R_split_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * 'elt triple * 'elt coq_R_split * 'elt tree
           * 'elt option * 'elt tree

        val coq_R_split_rect :
          (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> ('a1 tree -> __
          -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> __ -> __ -> 'a1 triple -> 'a1 coq_R_split ->
          'a2 -> 'a1 tree -> 'a1 option -> 'a1 tree -> __ -> 'a2) -> ('a1
          tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
          __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree
          -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 triple -> 'a1 coq_R_split ->
          'a2 -> 'a1 tree -> 'a1 option -> 'a1 tree -> __ -> 'a2) -> 'a1 tree
          -> 'a1 triple -> 'a1 coq_R_split -> 'a2

        val coq_R_split_rec :
          (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> ('a1 tree -> __
          -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> __ -> __ -> 'a1 triple -> 'a1 coq_R_split ->
          'a2 -> 'a1 tree -> 'a1 option -> 'a1 tree -> __ -> 'a2) -> ('a1
          tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
          __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree
          -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 triple -> 'a1 coq_R_split ->
          'a2 -> 'a1 tree -> 'a1 option -> 'a1 tree -> __ -> 'a2) -> 'a1 tree
          -> 'a1 triple -> 'a1 coq_R_split -> 'a2

        type ('elt, 'x) coq_R_map_option =
        | R_map_option_0 of 'elt tree
        | R_map_option_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * 'x * 'x tree * ('elt, 'x) coq_R_map_option
           * 'x tree * ('elt, 'x) coq_R_map_option
        | R_map_option_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * 'x tree * ('elt, 'x) coq_R_map_option * 'x tree
           * ('elt, 'x) coq_R_map_option

        val coq_R_map_option_rect :
          (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) -> ('a1 tree
          -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 ->
          __ -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2 tree ->
          ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> ('a1 tree -> 'a1 tree
          -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a2 tree ->
          ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2 tree -> ('a1, 'a2)
          coq_R_map_option -> 'a3 -> 'a3) -> 'a1 tree -> 'a2 tree -> ('a1,
          'a2) coq_R_map_option -> 'a3

        val coq_R_map_option_rec :
          (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) -> ('a1 tree
          -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 ->
          __ -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2 tree ->
          ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> ('a1 tree -> 'a1 tree
          -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a2 tree ->
          ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2 tree -> ('a1, 'a2)
          coq_R_map_option -> 'a3 -> 'a3) -> 'a1 tree -> 'a2 tree -> ('a1,
          'a2) coq_R_map_option -> 'a3

        type ('elt, 'x0, 'x) coq_R_map2_opt =
        | R_map2_opt_0 of 'elt tree * 'x0 tree
        | R_map2_opt_1 of 'elt tree * 'x0 tree * 'elt tree * key * 'elt
           * 'elt tree * Z_as_Int.t
        | R_map2_opt_2 of 'elt tree * 'x0 tree * 'elt tree * key * 'elt
           * 'elt tree * Z_as_Int.t * 'x0 tree * key * 'x0 * 'x0 tree
           * Z_as_Int.t * 'x0 tree * 'x0 option * 'x0 tree * 'x * 'x tree
           * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
           * ('elt, 'x0, 'x) coq_R_map2_opt
        | R_map2_opt_3 of 'elt tree * 'x0 tree * 'elt tree * key * 'elt
           * 'elt tree * Z_as_Int.t * 'x0 tree * key * 'x0 * 'x0 tree
           * Z_as_Int.t * 'x0 tree * 'x0 option * 'x0 tree * 'x tree
           * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
           * ('elt, 'x0, 'x) coq_R_map2_opt

        val coq_R_map2_opt_rect :
          (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3 tree)
          -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2 tree -> __ -> 'a4) ->
          ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> __ -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree
          -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 tree -> key ->
          'a2 -> 'a2 tree -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2 option ->
          'a2 tree -> __ -> 'a3 -> __ -> 'a3 tree -> ('a1, 'a2, 'a3)
          coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt
          -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1
          -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 tree -> key -> 'a2 -> 'a2
          tree -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2 option -> 'a2 tree ->
          __ -> __ -> 'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 ->
          'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1
          tree -> 'a2 tree -> 'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt ->
          'a4

        val coq_R_map2_opt_rec :
          (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3 tree)
          -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2 tree -> __ -> 'a4) ->
          ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> __ -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree
          -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 tree -> key ->
          'a2 -> 'a2 tree -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2 option ->
          'a2 tree -> __ -> 'a3 -> __ -> 'a3 tree -> ('a1, 'a2, 'a3)
          coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt
          -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1
          -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 tree -> key -> 'a2 -> 'a2
          tree -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2 option -> 'a2 tree ->
          __ -> __ -> 'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 ->
          'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1
          tree -> 'a2 tree -> 'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt ->
          'a4

        val fold' : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

        val flatten_e : 'a1 enumeration -> (key * 'a1) list
       end
     end

    type 'elt bst =
      'elt Raw.tree
      (* singleton inductive, whose constructor was Bst *)

    val this : 'a1 bst -> 'a1 Raw.tree

    type 'elt t = 'elt bst

    type key = R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t

    val empty : 'a1 t

    val is_empty : 'a1 t -> bool

    val add : key -> 'a1 -> 'a1 t -> 'a1 t

    val remove : key -> 'a1 t -> 'a1 t

    val mem : key -> 'a1 t -> bool

    val find : key -> 'a1 t -> 'a1 option

    val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

    val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

    val map2 :
      ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t -> 'a3 t

    val elements : 'a1 t -> (key * 'a1) list

    val cardinal : 'a1 t -> nat

    val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

    val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool
   end

  module FMF :
   sig
    val eqb :
      (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
      (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> bool

    val coq_In_dec : 'a1 FM.t -> FM.key -> bool
   end

  module Coq_reFS :
   sig
    module X' :
     sig
      type t = R.Defs.Coq_regex_as_UCT.t

      val eq_dec :
        R.Defs.Coq_regex_as_UCT.t -> R.Defs.Coq_regex_as_UCT.t -> bool

      val compare :
        R.Defs.Coq_regex_as_UCT.t -> R.Defs.Coq_regex_as_UCT.t -> comparison
     end

    module MSet :
     sig
      module Raw :
       sig
        type elt = R.Defs.Coq_regex_as_UCT.t

        type tree = R.Defs.Coq_reFS.MSet.Raw.tree =
        | Leaf
        | Node of Z_as_Int.t * tree * R.Defs.Coq_regex_as_UCT.t * tree

        val empty : tree

        val is_empty : tree -> bool

        val mem : R.Defs.Coq_regex_as_UCT.t -> tree -> bool

        val min_elt : tree -> elt option

        val max_elt : tree -> elt option

        val choose : tree -> elt option

        val fold : (elt -> 'a1 -> 'a1) -> tree -> 'a1 -> 'a1

        val elements_aux :
          R.Defs.Coq_regex_as_UCT.t list -> tree -> R.Defs.Coq_regex_as_UCT.t
          list

        val elements : tree -> R.Defs.Coq_regex_as_UCT.t list

        val rev_elements_aux :
          R.Defs.Coq_regex_as_UCT.t list -> tree -> R.Defs.Coq_regex_as_UCT.t
          list

        val rev_elements : tree -> R.Defs.Coq_regex_as_UCT.t list

        val cardinal : tree -> nat

        val maxdepth : tree -> nat

        val mindepth : tree -> nat

        val for_all : (elt -> bool) -> tree -> bool

        val exists_ : (elt -> bool) -> tree -> bool

        type enumeration = R.Defs.Coq_reFS.MSet.Raw.enumeration =
        | End
        | More of elt * tree * enumeration

        val cons : tree -> enumeration -> enumeration

        val compare_more :
          R.Defs.Coq_regex_as_UCT.t -> (enumeration -> comparison) ->
          enumeration -> comparison

        val compare_cont :
          tree -> (enumeration -> comparison) -> enumeration -> comparison

        val compare_end : enumeration -> comparison

        val compare : tree -> tree -> comparison

        val equal : tree -> tree -> bool

        val subsetl :
          (tree -> bool) -> R.Defs.Coq_regex_as_UCT.t -> tree -> bool

        val subsetr :
          (tree -> bool) -> R.Defs.Coq_regex_as_UCT.t -> tree -> bool

        val subset : tree -> tree -> bool

        type t = tree

        val height : t -> Z_as_Int.t

        val singleton : R.Defs.Coq_regex_as_UCT.t -> tree

        val create : t -> R.Defs.Coq_regex_as_UCT.t -> t -> tree

        val assert_false : t -> R.Defs.Coq_regex_as_UCT.t -> t -> tree

        val bal : t -> R.Defs.Coq_regex_as_UCT.t -> t -> tree

        val add : R.Defs.Coq_regex_as_UCT.t -> tree -> tree

        val join : tree -> elt -> t -> t

        val remove_min : tree -> elt -> t -> t * elt

        val merge : tree -> tree -> tree

        val remove : R.Defs.Coq_regex_as_UCT.t -> tree -> tree

        val concat : tree -> tree -> tree

        type triple = R.Defs.Coq_reFS.MSet.Raw.triple = { t_left : t;
                                                          t_in : bool;
                                                          t_right : t }

        val t_left : triple -> t

        val t_in : triple -> bool

        val t_right : triple -> t

        val split : R.Defs.Coq_regex_as_UCT.t -> tree -> triple

        val inter : tree -> tree -> tree

        val diff : tree -> tree -> tree

        val union : tree -> tree -> tree

        val filter : (elt -> bool) -> tree -> tree

        val partition : (elt -> bool) -> t -> t * t

        val ltb_tree : R.Defs.Coq_regex_as_UCT.t -> tree -> bool

        val gtb_tree : R.Defs.Coq_regex_as_UCT.t -> tree -> bool

        val isok : tree -> bool

        module MX :
         sig
          module OrderTac :
           sig
            module OTF :
             sig
              type t = R.Defs.Coq_regex_as_UCT.t

              val compare :
                R.Defs.Coq_regex_as_UCT.t -> R.Defs.Coq_regex_as_UCT.t ->
                comparison

              val eq_dec :
                R.Defs.Coq_regex_as_UCT.t -> R.Defs.Coq_regex_as_UCT.t -> bool
             end

            module TO :
             sig
              type t = R.Defs.Coq_regex_as_UCT.t

              val compare :
                R.Defs.Coq_regex_as_UCT.t -> R.Defs.Coq_regex_as_UCT.t ->
                comparison

              val eq_dec :
                R.Defs.Coq_regex_as_UCT.t -> R.Defs.Coq_regex_as_UCT.t -> bool
             end
           end

          val eq_dec :
            R.Defs.Coq_regex_as_UCT.t -> R.Defs.Coq_regex_as_UCT.t -> bool

          val lt_dec :
            R.Defs.Coq_regex_as_UCT.t -> R.Defs.Coq_regex_as_UCT.t -> bool

          val eqb :
            R.Defs.Coq_regex_as_UCT.t -> R.Defs.Coq_regex_as_UCT.t -> bool
         end

        type coq_R_min_elt = R.Defs.Coq_reFS.MSet.Raw.coq_R_min_elt =
        | R_min_elt_0 of tree
        | R_min_elt_1 of tree * Z_as_Int.t * tree * R.Defs.Coq_regex_as_UCT.t
           * tree
        | R_min_elt_2 of tree * Z_as_Int.t * tree * R.Defs.Coq_regex_as_UCT.t
           * tree * Z_as_Int.t * tree * R.Defs.Coq_regex_as_UCT.t * tree
           * elt option * coq_R_min_elt

        type coq_R_max_elt = R.Defs.Coq_reFS.MSet.Raw.coq_R_max_elt =
        | R_max_elt_0 of tree
        | R_max_elt_1 of tree * Z_as_Int.t * tree * R.Defs.Coq_regex_as_UCT.t
           * tree
        | R_max_elt_2 of tree * Z_as_Int.t * tree * R.Defs.Coq_regex_as_UCT.t
           * tree * Z_as_Int.t * tree * R.Defs.Coq_regex_as_UCT.t * tree
           * elt option * coq_R_max_elt

        module L :
         sig
          module MO :
           sig
            module OrderTac :
             sig
              module OTF :
               sig
                type t = R.Defs.Coq_regex_as_UCT.t

                val compare :
                  R.Defs.Coq_regex_as_UCT.t -> R.Defs.Coq_regex_as_UCT.t ->
                  comparison

                val eq_dec :
                  R.Defs.Coq_regex_as_UCT.t -> R.Defs.Coq_regex_as_UCT.t ->
                  bool
               end

              module TO :
               sig
                type t = R.Defs.Coq_regex_as_UCT.t

                val compare :
                  R.Defs.Coq_regex_as_UCT.t -> R.Defs.Coq_regex_as_UCT.t ->
                  comparison

                val eq_dec :
                  R.Defs.Coq_regex_as_UCT.t -> R.Defs.Coq_regex_as_UCT.t ->
                  bool
               end
             end

            val eq_dec :
              R.Defs.Coq_regex_as_UCT.t -> R.Defs.Coq_regex_as_UCT.t -> bool

            val lt_dec :
              R.Defs.Coq_regex_as_UCT.t -> R.Defs.Coq_regex_as_UCT.t -> bool

            val eqb :
              R.Defs.Coq_regex_as_UCT.t -> R.Defs.Coq_regex_as_UCT.t -> bool
           end
         end

        val flatten_e : enumeration -> elt list

        type coq_R_bal = R.Defs.Coq_reFS.MSet.Raw.coq_R_bal =
        | R_bal_0 of t * R.Defs.Coq_regex_as_UCT.t * t
        | R_bal_1 of t * R.Defs.Coq_regex_as_UCT.t * t * Z_as_Int.t * 
           tree * R.Defs.Coq_regex_as_UCT.t * tree
        | R_bal_2 of t * R.Defs.Coq_regex_as_UCT.t * t * Z_as_Int.t * 
           tree * R.Defs.Coq_regex_as_UCT.t * tree
        | R_bal_3 of t * R.Defs.Coq_regex_as_UCT.t * t * Z_as_Int.t * 
           tree * R.Defs.Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
           * R.Defs.Coq_regex_as_UCT.t * tree
        | R_bal_4 of t * R.Defs.Coq_regex_as_UCT.t * t
        | R_bal_5 of t * R.Defs.Coq_regex_as_UCT.t * t * Z_as_Int.t * 
           tree * R.Defs.Coq_regex_as_UCT.t * tree
        | R_bal_6 of t * R.Defs.Coq_regex_as_UCT.t * t * Z_as_Int.t * 
           tree * R.Defs.Coq_regex_as_UCT.t * tree
        | R_bal_7 of t * R.Defs.Coq_regex_as_UCT.t * t * Z_as_Int.t * 
           tree * R.Defs.Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
           * R.Defs.Coq_regex_as_UCT.t * tree
        | R_bal_8 of t * R.Defs.Coq_regex_as_UCT.t * t

        type coq_R_remove_min = R.Defs.Coq_reFS.MSet.Raw.coq_R_remove_min =
        | R_remove_min_0 of tree * elt * t
        | R_remove_min_1 of tree * elt * t * Z_as_Int.t * tree
           * R.Defs.Coq_regex_as_UCT.t * tree * (t * elt) * coq_R_remove_min
           * t * elt

        type coq_R_merge = R.Defs.Coq_reFS.MSet.Raw.coq_R_merge =
        | R_merge_0 of tree * tree
        | R_merge_1 of tree * tree * Z_as_Int.t * tree
           * R.Defs.Coq_regex_as_UCT.t * tree
        | R_merge_2 of tree * tree * Z_as_Int.t * tree
           * R.Defs.Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
           * R.Defs.Coq_regex_as_UCT.t * tree * t * elt

        type coq_R_concat = R.Defs.Coq_reFS.MSet.Raw.coq_R_concat =
        | R_concat_0 of tree * tree
        | R_concat_1 of tree * tree * Z_as_Int.t * tree
           * R.Defs.Coq_regex_as_UCT.t * tree
        | R_concat_2 of tree * tree * Z_as_Int.t * tree
           * R.Defs.Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
           * R.Defs.Coq_regex_as_UCT.t * tree * t * elt

        type coq_R_inter = R.Defs.Coq_reFS.MSet.Raw.coq_R_inter =
        | R_inter_0 of tree * tree
        | R_inter_1 of tree * tree * Z_as_Int.t * tree
           * R.Defs.Coq_regex_as_UCT.t * tree
        | R_inter_2 of tree * tree * Z_as_Int.t * tree
           * R.Defs.Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
           * R.Defs.Coq_regex_as_UCT.t * tree * t * bool * t * tree
           * coq_R_inter * tree * coq_R_inter
        | R_inter_3 of tree * tree * Z_as_Int.t * tree
           * R.Defs.Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
           * R.Defs.Coq_regex_as_UCT.t * tree * t * bool * t * tree
           * coq_R_inter * tree * coq_R_inter

        type coq_R_diff = R.Defs.Coq_reFS.MSet.Raw.coq_R_diff =
        | R_diff_0 of tree * tree
        | R_diff_1 of tree * tree * Z_as_Int.t * tree
           * R.Defs.Coq_regex_as_UCT.t * tree
        | R_diff_2 of tree * tree * Z_as_Int.t * tree
           * R.Defs.Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
           * R.Defs.Coq_regex_as_UCT.t * tree * t * bool * t * tree
           * coq_R_diff * tree * coq_R_diff
        | R_diff_3 of tree * tree * Z_as_Int.t * tree
           * R.Defs.Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
           * R.Defs.Coq_regex_as_UCT.t * tree * t * bool * t * tree
           * coq_R_diff * tree * coq_R_diff

        type coq_R_union = R.Defs.Coq_reFS.MSet.Raw.coq_R_union =
        | R_union_0 of tree * tree
        | R_union_1 of tree * tree * Z_as_Int.t * tree
           * R.Defs.Coq_regex_as_UCT.t * tree
        | R_union_2 of tree * tree * Z_as_Int.t * tree
           * R.Defs.Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
           * R.Defs.Coq_regex_as_UCT.t * tree * t * bool * t * tree
           * coq_R_union * tree * coq_R_union
       end

      module E :
       sig
        type t = R.Defs.Coq_regex_as_UCT.t

        val compare :
          R.Defs.Coq_regex_as_UCT.t -> R.Defs.Coq_regex_as_UCT.t -> comparison

        val eq_dec :
          R.Defs.Coq_regex_as_UCT.t -> R.Defs.Coq_regex_as_UCT.t -> bool
       end

      type elt = R.Defs.Coq_regex_as_UCT.t

      type t_ = Raw.t
        (* singleton inductive, whose constructor was Mkt *)

      val this : t_ -> Raw.t

      type t = t_

      val mem : elt -> t -> bool

      val add : elt -> t -> t

      val remove : elt -> t -> t

      val singleton : elt -> t

      val union : t -> t -> t

      val inter : t -> t -> t

      val diff : t -> t -> t

      val equal : t -> t -> bool

      val subset : t -> t -> bool

      val empty : t

      val is_empty : t -> bool

      val elements : t -> elt list

      val choose : t -> elt option

      val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

      val cardinal : t -> nat

      val filter : (elt -> bool) -> t -> t

      val for_all : (elt -> bool) -> t -> bool

      val exists_ : (elt -> bool) -> t -> bool

      val partition : (elt -> bool) -> t -> t * t

      val eq_dec : t -> t -> bool

      val compare : t -> t -> comparison

      val min_elt : t -> elt option

      val max_elt : t -> elt option
     end

    type elt = R.Defs.Coq_regex_as_UCT.t

    type t = MSet.t

    val empty : t

    val is_empty : t -> bool

    val mem : elt -> t -> bool

    val add : elt -> t -> t

    val singleton : elt -> t

    val remove : elt -> t -> t

    val union : t -> t -> t

    val inter : t -> t -> t

    val diff : t -> t -> t

    val eq_dec : t -> t -> bool

    val equal : t -> t -> bool

    val subset : t -> t -> bool

    val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

    val for_all : (elt -> bool) -> t -> bool

    val exists_ : (elt -> bool) -> t -> bool

    val filter : (elt -> bool) -> t -> t

    val partition : (elt -> bool) -> t -> t * t

    val cardinal : t -> nat

    val elements : t -> elt list

    val choose : t -> elt option

    module MF :
     sig
      val eqb : R.Defs.Coq_regex_as_UCT.t -> R.Defs.Coq_regex_as_UCT.t -> bool
     end

    val min_elt : t -> elt option

    val max_elt : t -> elt option

    val compare : t -> t -> t compare0

    module E :
     sig
      type t = R.Defs.Coq_regex_as_UCT.t

      val compare :
        R.Defs.Coq_regex_as_UCT.t -> R.Defs.Coq_regex_as_UCT.t ->
        R.Defs.Coq_regex_as_UCT.t compare0

      val eq_dec :
        R.Defs.Coq_regex_as_UCT.t -> R.Defs.Coq_regex_as_UCT.t -> bool
     end
   end

  type coq_Table = R.Defs.Regexes.regex FM.t * Coq_reFS.t

  val emptyTable : coq_Table

  val set_Table :
    coq_Table -> R.Defs.Regexes.regex -> R.Ty.coq_Sigma ->
    R.Defs.Regexes.regex -> coq_Table

  val get_Table :
    coq_Table -> R.Defs.Regexes.regex -> R.Ty.coq_Sigma ->
    R.Defs.Regexes.regex option

  val add_state : coq_Table -> R.Defs.Regexes.regex -> coq_Table

  val get_states : coq_Table -> Coq_reFS.t

  val get_eq :
    coq_Table -> R.Defs.Regexes.regex -> R.Defs.Regexes.regex option
 end

module Coq_LemmasFn :
 functor (ST:Coq_T) ->
 sig
  module IMPL :
   sig
    module LEM :
     sig
      module IMPL :
       sig
        val max_pref_fn :
          ST.R.Defs.Strings.coq_String -> ST.Ty.index -> ST.Ty.coq_State ->
          ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
          option

        val extract_fsm_for_max :
          ST.R.Defs.Strings.coq_String -> ST.Ty.index ->
          (ST.Ty.coq_Label * ST.Ty.coq_State) ->
          ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
          option

        val max_prefs :
          ST.R.Defs.Strings.coq_String -> ST.Ty.index ->
          (ST.Ty.coq_Label * ST.Ty.coq_State) list ->
          (ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
          option) list

        val longer_pref :
          (ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
          option) ->
          (ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
          option) ->
          ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
          option

        val max_of_prefs :
          (ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
          option) list ->
          ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
          option

        val init_srule : ST.Defs.Coredefs.coq_Rule -> ST.Defs.Coredefs.sRule
       end
     end

    module Lex :
     sig
      val lex' :
        ST.Defs.Coredefs.sRule list -> ST.R.Defs.Strings.coq_String ->
        ST.Ty.index -> ST.Defs.Coredefs.coq_Token
        list * ST.R.Defs.Strings.coq_String

      val lex :
        ST.Defs.Coredefs.coq_Rule list -> ST.R.Defs.Strings.coq_String ->
        ST.Defs.Coredefs.coq_Token list * ST.R.Defs.Strings.coq_String
     end
   end

  module Lemmas :
   sig
    module IMPL :
     sig
      val max_pref_fn :
        ST.R.Defs.Strings.coq_String -> ST.Ty.index -> ST.Ty.coq_State ->
        ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
        option

      val extract_fsm_for_max :
        ST.R.Defs.Strings.coq_String -> ST.Ty.index ->
        (ST.Ty.coq_Label * ST.Ty.coq_State) ->
        ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
        option

      val max_prefs :
        ST.R.Defs.Strings.coq_String -> ST.Ty.index ->
        (ST.Ty.coq_Label * ST.Ty.coq_State) list ->
        (ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
        option) list

      val longer_pref :
        (ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
        option) ->
        (ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
        option) ->
        ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
        option

      val max_of_prefs :
        (ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
        option) list ->
        ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
        option

      val init_srule : ST.Defs.Coredefs.coq_Rule -> ST.Defs.Coredefs.sRule
     end
   end
 end

module CorrectFn :
 functor (ST:Coq_T) ->
 sig
  module LEM :
   sig
    module IMPL :
     sig
      module LEM :
       sig
        module IMPL :
         sig
          val max_pref_fn :
            ST.R.Defs.Strings.coq_String -> ST.Ty.index -> ST.Ty.coq_State ->
            ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
            option

          val extract_fsm_for_max :
            ST.R.Defs.Strings.coq_String -> ST.Ty.index ->
            (ST.Ty.coq_Label * ST.Ty.coq_State) ->
            ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
            option

          val max_prefs :
            ST.R.Defs.Strings.coq_String -> ST.Ty.index ->
            (ST.Ty.coq_Label * ST.Ty.coq_State) list ->
            (ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
            option) list

          val longer_pref :
            (ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
            option) ->
            (ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
            option) ->
            ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
            option

          val max_of_prefs :
            (ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
            option) list ->
            ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
            option

          val init_srule : ST.Defs.Coredefs.coq_Rule -> ST.Defs.Coredefs.sRule
         end
       end

      module Lex :
       sig
        val lex' :
          ST.Defs.Coredefs.sRule list -> ST.R.Defs.Strings.coq_String ->
          ST.Ty.index -> ST.Defs.Coredefs.coq_Token
          list * ST.R.Defs.Strings.coq_String

        val lex :
          ST.Defs.Coredefs.coq_Rule list -> ST.R.Defs.Strings.coq_String ->
          ST.Defs.Coredefs.coq_Token list * ST.R.Defs.Strings.coq_String
       end
     end

    module Lemmas :
     sig
      module IMPL :
       sig
        val max_pref_fn :
          ST.R.Defs.Strings.coq_String -> ST.Ty.index -> ST.Ty.coq_State ->
          ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
          option

        val extract_fsm_for_max :
          ST.R.Defs.Strings.coq_String -> ST.Ty.index ->
          (ST.Ty.coq_Label * ST.Ty.coq_State) ->
          ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
          option

        val max_prefs :
          ST.R.Defs.Strings.coq_String -> ST.Ty.index ->
          (ST.Ty.coq_Label * ST.Ty.coq_State) list ->
          (ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
          option) list

        val longer_pref :
          (ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
          option) ->
          (ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
          option) ->
          ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
          option

        val max_of_prefs :
          (ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
          option) list ->
          ST.Ty.coq_Label * ((ST.Defs.Coredefs.coq_Prefix * ST.Defs.Coredefs.coq_Suffix) * ST.Ty.index)
          option

        val init_srule : ST.Defs.Coredefs.coq_Rule -> ST.Defs.Coredefs.sRule
       end
     end
   end
 end

module MemoDefsFn :
 functor (STT:Coq_T) ->
 functor (MEM:sig
  type coq_Memo

  val emptyMemo : coq_Memo

  val set_Memo :
    coq_Memo -> STT.Ty.coq_Pointer -> STT.Ty.index ->
    ((STT.R.Defs.Strings.coq_String * STT.R.Defs.Strings.coq_String) * STT.Ty.index)
    option -> coq_Memo

  val get_Memo :
    coq_Memo -> STT.Ty.coq_Pointer -> STT.Ty.index ->
    ((STT.R.Defs.Strings.coq_String * STT.R.Defs.Strings.coq_String) * STT.Ty.index)
    option option
 end) ->
 sig
  module NaiveLexer :
   sig
    module LEM :
     sig
      module IMPL :
       sig
        val max_pref_fn :
          STT.R.Defs.Strings.coq_String -> STT.Ty.index -> STT.Ty.coq_State
          ->
          ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
          option

        val extract_fsm_for_max :
          STT.R.Defs.Strings.coq_String -> STT.Ty.index ->
          (STT.Ty.coq_Label * STT.Ty.coq_State) ->
          STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
          option

        val max_prefs :
          STT.R.Defs.Strings.coq_String -> STT.Ty.index ->
          (STT.Ty.coq_Label * STT.Ty.coq_State) list ->
          (STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
          option) list

        val longer_pref :
          (STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
          option) ->
          (STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
          option) ->
          STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
          option

        val max_of_prefs :
          (STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
          option) list ->
          STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
          option

        val init_srule : STT.Defs.Coredefs.coq_Rule -> STT.Defs.Coredefs.sRule
       end
     end

    module Lex :
     sig
      val lex' :
        STT.Defs.Coredefs.sRule list -> STT.R.Defs.Strings.coq_String ->
        STT.Ty.index -> STT.Defs.Coredefs.coq_Token
        list * STT.R.Defs.Strings.coq_String

      val lex :
        STT.Defs.Coredefs.coq_Rule list -> STT.R.Defs.Strings.coq_String ->
        STT.Defs.Coredefs.coq_Token list * STT.R.Defs.Strings.coq_String
     end
   end

  module NaiveLexerF :
   sig
    module LEM :
     sig
      module IMPL :
       sig
        module LEM :
         sig
          module IMPL :
           sig
            val max_pref_fn :
              STT.R.Defs.Strings.coq_String -> STT.Ty.index ->
              STT.Ty.coq_State ->
              ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
              option

            val extract_fsm_for_max :
              STT.R.Defs.Strings.coq_String -> STT.Ty.index ->
              (STT.Ty.coq_Label * STT.Ty.coq_State) ->
              STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
              option

            val max_prefs :
              STT.R.Defs.Strings.coq_String -> STT.Ty.index ->
              (STT.Ty.coq_Label * STT.Ty.coq_State) list ->
              (STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
              option) list

            val longer_pref :
              (STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
              option) ->
              (STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
              option) ->
              STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
              option

            val max_of_prefs :
              (STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
              option) list ->
              STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
              option

            val init_srule :
              STT.Defs.Coredefs.coq_Rule -> STT.Defs.Coredefs.sRule
           end
         end

        module Lex :
         sig
          val lex' :
            STT.Defs.Coredefs.sRule list -> STT.R.Defs.Strings.coq_String ->
            STT.Ty.index -> STT.Defs.Coredefs.coq_Token
            list * STT.R.Defs.Strings.coq_String

          val lex :
            STT.Defs.Coredefs.coq_Rule list -> STT.R.Defs.Strings.coq_String
            -> STT.Defs.Coredefs.coq_Token
            list * STT.R.Defs.Strings.coq_String
         end
       end

      module Lemmas :
       sig
        module IMPL :
         sig
          val max_pref_fn :
            STT.R.Defs.Strings.coq_String -> STT.Ty.index -> STT.Ty.coq_State
            ->
            ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
            option

          val extract_fsm_for_max :
            STT.R.Defs.Strings.coq_String -> STT.Ty.index ->
            (STT.Ty.coq_Label * STT.Ty.coq_State) ->
            STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
            option

          val max_prefs :
            STT.R.Defs.Strings.coq_String -> STT.Ty.index ->
            (STT.Ty.coq_Label * STT.Ty.coq_State) list ->
            (STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
            option) list

          val longer_pref :
            (STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
            option) ->
            (STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
            option) ->
            STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
            option

          val max_of_prefs :
            (STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
            option) list ->
            STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
            option

          val init_srule :
            STT.Defs.Coredefs.coq_Rule -> STT.Defs.Coredefs.sRule
         end
       end
     end
   end

  module Invariants :
   sig
   end
 end

module type Coq1_T =
 sig
  module STT :
   Coq_T

  module MemTy :
   sig
    type coq_Memo

    val emptyMemo : coq_Memo

    val set_Memo :
      coq_Memo -> STT.Ty.coq_Pointer -> STT.Ty.index ->
      ((STT.R.Defs.Strings.coq_String * STT.R.Defs.Strings.coq_String) * STT.Ty.index)
      option -> coq_Memo

    val get_Memo :
      coq_Memo -> STT.Ty.coq_Pointer -> STT.Ty.index ->
      ((STT.R.Defs.Strings.coq_String * STT.R.Defs.Strings.coq_String) * STT.Ty.index)
      option option
   end

  module Defs :
   sig
    module NaiveLexer :
     sig
      module LEM :
       sig
        module IMPL :
         sig
          val max_pref_fn :
            STT.R.Defs.Strings.coq_String -> STT.Ty.index -> STT.Ty.coq_State
            ->
            ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
            option

          val extract_fsm_for_max :
            STT.R.Defs.Strings.coq_String -> STT.Ty.index ->
            (STT.Ty.coq_Label * STT.Ty.coq_State) ->
            STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
            option

          val max_prefs :
            STT.R.Defs.Strings.coq_String -> STT.Ty.index ->
            (STT.Ty.coq_Label * STT.Ty.coq_State) list ->
            (STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
            option) list

          val longer_pref :
            (STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
            option) ->
            (STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
            option) ->
            STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
            option

          val max_of_prefs :
            (STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
            option) list ->
            STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
            option

          val init_srule :
            STT.Defs.Coredefs.coq_Rule -> STT.Defs.Coredefs.sRule
         end
       end

      module Lex :
       sig
        val lex' :
          STT.Defs.Coredefs.sRule list -> STT.R.Defs.Strings.coq_String ->
          STT.Ty.index -> STT.Defs.Coredefs.coq_Token
          list * STT.R.Defs.Strings.coq_String

        val lex :
          STT.Defs.Coredefs.coq_Rule list -> STT.R.Defs.Strings.coq_String ->
          STT.Defs.Coredefs.coq_Token list * STT.R.Defs.Strings.coq_String
       end
     end

    module NaiveLexerF :
     sig
      module LEM :
       sig
        module IMPL :
         sig
          module LEM :
           sig
            module IMPL :
             sig
              val max_pref_fn :
                STT.R.Defs.Strings.coq_String -> STT.Ty.index ->
                STT.Ty.coq_State ->
                ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
                option

              val extract_fsm_for_max :
                STT.R.Defs.Strings.coq_String -> STT.Ty.index ->
                (STT.Ty.coq_Label * STT.Ty.coq_State) ->
                STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
                option

              val max_prefs :
                STT.R.Defs.Strings.coq_String -> STT.Ty.index ->
                (STT.Ty.coq_Label * STT.Ty.coq_State) list ->
                (STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
                option) list

              val longer_pref :
                (STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
                option) ->
                (STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
                option) ->
                STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
                option

              val max_of_prefs :
                (STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
                option) list ->
                STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
                option

              val init_srule :
                STT.Defs.Coredefs.coq_Rule -> STT.Defs.Coredefs.sRule
             end
           end

          module Lex :
           sig
            val lex' :
              STT.Defs.Coredefs.sRule list -> STT.R.Defs.Strings.coq_String
              -> STT.Ty.index -> STT.Defs.Coredefs.coq_Token
              list * STT.R.Defs.Strings.coq_String

            val lex :
              STT.Defs.Coredefs.coq_Rule list ->
              STT.R.Defs.Strings.coq_String -> STT.Defs.Coredefs.coq_Token
              list * STT.R.Defs.Strings.coq_String
           end
         end

        module Lemmas :
         sig
          module IMPL :
           sig
            val max_pref_fn :
              STT.R.Defs.Strings.coq_String -> STT.Ty.index ->
              STT.Ty.coq_State ->
              ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
              option

            val extract_fsm_for_max :
              STT.R.Defs.Strings.coq_String -> STT.Ty.index ->
              (STT.Ty.coq_Label * STT.Ty.coq_State) ->
              STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
              option

            val max_prefs :
              STT.R.Defs.Strings.coq_String -> STT.Ty.index ->
              (STT.Ty.coq_Label * STT.Ty.coq_State) list ->
              (STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
              option) list

            val longer_pref :
              (STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
              option) ->
              (STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
              option) ->
              STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
              option

            val max_of_prefs :
              (STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
              option) list ->
              STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
              option

            val init_srule :
              STT.Defs.Coredefs.coq_Rule -> STT.Defs.Coredefs.sRule
           end
         end
       end
     end

    module Invariants :
     sig
     end
   end
 end

module Coq0_ImplFn :
 functor (MEM:Coq1_T) ->
 sig
  module MEMO :
   sig
    type coq_Memo = MEM.MemTy.coq_Memo

    val emptyMemo : coq_Memo

    val set_Memo :
      coq_Memo -> MEM.STT.Ty.coq_Pointer -> MEM.STT.Ty.index ->
      ((MEM.STT.R.Defs.Strings.coq_String * MEM.STT.R.Defs.Strings.coq_String) * MEM.STT.Ty.index)
      option -> coq_Memo

    val get_Memo :
      coq_Memo -> MEM.STT.Ty.coq_Pointer -> MEM.STT.Ty.index ->
      ((MEM.STT.R.Defs.Strings.coq_String * MEM.STT.R.Defs.Strings.coq_String) * MEM.STT.Ty.index)
      option option
   end

  module Defs :
   sig
    module NaiveLexer :
     sig
      module LEM :
       sig
        module IMPL :
         sig
          val max_pref_fn :
            MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
            MEM.STT.Ty.coq_State ->
            ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
            option

          val extract_fsm_for_max :
            MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
            (MEM.STT.Ty.coq_Label * MEM.STT.Ty.coq_State) ->
            MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
            option

          val max_prefs :
            MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
            (MEM.STT.Ty.coq_Label * MEM.STT.Ty.coq_State) list ->
            (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
            option) list

          val longer_pref :
            (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
            option) ->
            (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
            option) ->
            MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
            option

          val max_of_prefs :
            (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
            option) list ->
            MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
            option

          val init_srule :
            MEM.STT.Defs.Coredefs.coq_Rule -> MEM.STT.Defs.Coredefs.sRule
         end
       end

      module Lex :
       sig
        val lex' :
          MEM.STT.Defs.Coredefs.sRule list ->
          MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
          MEM.STT.Defs.Coredefs.coq_Token
          list * MEM.STT.R.Defs.Strings.coq_String

        val lex :
          MEM.STT.Defs.Coredefs.coq_Rule list ->
          MEM.STT.R.Defs.Strings.coq_String ->
          MEM.STT.Defs.Coredefs.coq_Token
          list * MEM.STT.R.Defs.Strings.coq_String
       end
     end

    module NaiveLexerF :
     sig
      module LEM :
       sig
        module IMPL :
         sig
          module LEM :
           sig
            module IMPL :
             sig
              val max_pref_fn :
                MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
                MEM.STT.Ty.coq_State ->
                ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                option

              val extract_fsm_for_max :
                MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
                (MEM.STT.Ty.coq_Label * MEM.STT.Ty.coq_State) ->
                MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                option

              val max_prefs :
                MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
                (MEM.STT.Ty.coq_Label * MEM.STT.Ty.coq_State) list ->
                (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                option) list

              val longer_pref :
                (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                option) ->
                (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                option) ->
                MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                option

              val max_of_prefs :
                (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                option) list ->
                MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                option

              val init_srule :
                MEM.STT.Defs.Coredefs.coq_Rule -> MEM.STT.Defs.Coredefs.sRule
             end
           end

          module Lex :
           sig
            val lex' :
              MEM.STT.Defs.Coredefs.sRule list ->
              MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
              MEM.STT.Defs.Coredefs.coq_Token
              list * MEM.STT.R.Defs.Strings.coq_String

            val lex :
              MEM.STT.Defs.Coredefs.coq_Rule list ->
              MEM.STT.R.Defs.Strings.coq_String ->
              MEM.STT.Defs.Coredefs.coq_Token
              list * MEM.STT.R.Defs.Strings.coq_String
           end
         end

        module Lemmas :
         sig
          module IMPL :
           sig
            val max_pref_fn :
              MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
              MEM.STT.Ty.coq_State ->
              ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
              option

            val extract_fsm_for_max :
              MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
              (MEM.STT.Ty.coq_Label * MEM.STT.Ty.coq_State) ->
              MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
              option

            val max_prefs :
              MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
              (MEM.STT.Ty.coq_Label * MEM.STT.Ty.coq_State) list ->
              (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
              option) list

            val longer_pref :
              (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
              option) ->
              (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
              option) ->
              MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
              option

            val max_of_prefs :
              (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
              option) list ->
              MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
              option

            val init_srule :
              MEM.STT.Defs.Coredefs.coq_Rule -> MEM.STT.Defs.Coredefs.sRule
           end
         end
       end
     end

    module Invariants :
     sig
     end
   end

  module L :
   sig
    module IMPL :
     sig
      module LEM :
       sig
        module IMPL :
         sig
          val max_pref_fn :
            MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
            MEM.STT.Ty.coq_State ->
            ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
            option

          val extract_fsm_for_max :
            MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
            (MEM.STT.Ty.coq_Label * MEM.STT.Ty.coq_State) ->
            MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
            option

          val max_prefs :
            MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
            (MEM.STT.Ty.coq_Label * MEM.STT.Ty.coq_State) list ->
            (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
            option) list

          val longer_pref :
            (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
            option) ->
            (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
            option) ->
            MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
            option

          val max_of_prefs :
            (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
            option) list ->
            MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
            option

          val init_srule :
            MEM.STT.Defs.Coredefs.coq_Rule -> MEM.STT.Defs.Coredefs.sRule
         end
       end

      module Lex :
       sig
        val lex' :
          MEM.STT.Defs.Coredefs.sRule list ->
          MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
          MEM.STT.Defs.Coredefs.coq_Token
          list * MEM.STT.R.Defs.Strings.coq_String

        val lex :
          MEM.STT.Defs.Coredefs.coq_Rule list ->
          MEM.STT.R.Defs.Strings.coq_String ->
          MEM.STT.Defs.Coredefs.coq_Token
          list * MEM.STT.R.Defs.Strings.coq_String
       end
     end

    module Lemmas :
     sig
      module IMPL :
       sig
        val max_pref_fn :
          MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
          MEM.STT.Ty.coq_State ->
          ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
          option

        val extract_fsm_for_max :
          MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
          (MEM.STT.Ty.coq_Label * MEM.STT.Ty.coq_State) ->
          MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
          option

        val max_prefs :
          MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
          (MEM.STT.Ty.coq_Label * MEM.STT.Ty.coq_State) list ->
          (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
          option) list

        val longer_pref :
          (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
          option) ->
          (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
          option) ->
          MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
          option

        val max_of_prefs :
          (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
          option) list ->
          MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
          option

        val init_srule :
          MEM.STT.Defs.Coredefs.coq_Rule -> MEM.STT.Defs.Coredefs.sRule
       end
     end
   end

  module Utils :
   sig
    val zip : 'a1 list -> 'a2 list -> ('a1 * 'a2) list

    val unzip : ('a1 * 'a2) list -> 'a1 list * 'a2 list

    val ssnd : ('a1 * ('a2 * 'a3)) -> 'a3
   end

  module MPref :
   sig
    val max_pref_fn_M :
      MEMO.coq_Memo -> MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index
      -> MEM.STT.Ty.coq_State ->
      MEMO.coq_Memo * ((MEM.STT.R.Defs.Strings.coq_String * MEM.STT.R.Defs.Strings.coq_String) * MEM.STT.Ty.index)
      option

    val extract_fsm_for_max_M :
      MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
      (MEMO.coq_Memo * (MEM.STT.Ty.coq_Label * MEM.STT.Ty.coq_State)) ->
      MEMO.coq_Memo * (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
      option)

    val max_prefs_M :
      MEMO.coq_Memo list -> MEM.STT.R.Defs.Strings.coq_String ->
      MEM.STT.Ty.index -> (MEM.STT.Ty.coq_Label * MEM.STT.Ty.coq_State) list
      -> MEMO.coq_Memo
      list * (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
      option) list

    val max_of_prefs_M :
      (MEMO.coq_Memo
      list * (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
      option) list) -> (MEMO.coq_Memo
      list * MEM.STT.Ty.coq_Label) * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
      option
   end

  module TypeCheckLemmas :
   sig
    module MemoEq :
     sig
     end

    module Accessible :
     sig
     end

    module Lengths :
     sig
     end

    module LexyClosure :
     sig
     end

    module IndexClosure :
     sig
     end
   end

  module Lex :
   sig
    val lex'_M :
      MEM.STT.R.Defs.Strings.coq_String -> MEMO.coq_Memo list ->
      MEM.STT.Defs.Coredefs.sRule list -> MEM.STT.R.Defs.Strings.coq_String
      -> MEM.STT.Ty.index -> (MEMO.coq_Memo
      list * MEM.STT.Defs.Coredefs.coq_Token
      list) * MEM.STT.R.Defs.Strings.coq_String

    val init_srule :
      MEM.STT.Defs.Coredefs.coq_Rule -> MEM.STT.Defs.Coredefs.sRule

    val init_Memos : MEM.STT.Defs.Coredefs.sRule list -> MEMO.coq_Memo list

    val lex_M :
      MEM.STT.Defs.Coredefs.coq_Rule list ->
      MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Defs.Coredefs.coq_Token
      list * MEM.STT.R.Defs.Strings.coq_String
   end
 end

module Coq_CorrectFn :
 functor (MEM:Coq1_T) ->
 sig
  module IMPL :
   sig
    module MEMO :
     sig
      type coq_Memo = MEM.MemTy.coq_Memo

      val emptyMemo : coq_Memo

      val set_Memo :
        coq_Memo -> MEM.STT.Ty.coq_Pointer -> MEM.STT.Ty.index ->
        ((MEM.STT.R.Defs.Strings.coq_String * MEM.STT.R.Defs.Strings.coq_String) * MEM.STT.Ty.index)
        option -> coq_Memo

      val get_Memo :
        coq_Memo -> MEM.STT.Ty.coq_Pointer -> MEM.STT.Ty.index ->
        ((MEM.STT.R.Defs.Strings.coq_String * MEM.STT.R.Defs.Strings.coq_String) * MEM.STT.Ty.index)
        option option
     end

    module Defs :
     sig
      module NaiveLexer :
       sig
        module LEM :
         sig
          module IMPL :
           sig
            val max_pref_fn :
              MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
              MEM.STT.Ty.coq_State ->
              ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
              option

            val extract_fsm_for_max :
              MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
              (MEM.STT.Ty.coq_Label * MEM.STT.Ty.coq_State) ->
              MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
              option

            val max_prefs :
              MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
              (MEM.STT.Ty.coq_Label * MEM.STT.Ty.coq_State) list ->
              (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
              option) list

            val longer_pref :
              (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
              option) ->
              (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
              option) ->
              MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
              option

            val max_of_prefs :
              (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
              option) list ->
              MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
              option

            val init_srule :
              MEM.STT.Defs.Coredefs.coq_Rule -> MEM.STT.Defs.Coredefs.sRule
           end
         end

        module Lex :
         sig
          val lex' :
            MEM.STT.Defs.Coredefs.sRule list ->
            MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
            MEM.STT.Defs.Coredefs.coq_Token
            list * MEM.STT.R.Defs.Strings.coq_String

          val lex :
            MEM.STT.Defs.Coredefs.coq_Rule list ->
            MEM.STT.R.Defs.Strings.coq_String ->
            MEM.STT.Defs.Coredefs.coq_Token
            list * MEM.STT.R.Defs.Strings.coq_String
         end
       end

      module NaiveLexerF :
       sig
        module LEM :
         sig
          module IMPL :
           sig
            module LEM :
             sig
              module IMPL :
               sig
                val max_pref_fn :
                  MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
                  MEM.STT.Ty.coq_State ->
                  ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                  option

                val extract_fsm_for_max :
                  MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
                  (MEM.STT.Ty.coq_Label * MEM.STT.Ty.coq_State) ->
                  MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                  option

                val max_prefs :
                  MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
                  (MEM.STT.Ty.coq_Label * MEM.STT.Ty.coq_State) list ->
                  (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                  option) list

                val longer_pref :
                  (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                  option) ->
                  (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                  option) ->
                  MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                  option

                val max_of_prefs :
                  (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                  option) list ->
                  MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                  option

                val init_srule :
                  MEM.STT.Defs.Coredefs.coq_Rule ->
                  MEM.STT.Defs.Coredefs.sRule
               end
             end

            module Lex :
             sig
              val lex' :
                MEM.STT.Defs.Coredefs.sRule list ->
                MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
                MEM.STT.Defs.Coredefs.coq_Token
                list * MEM.STT.R.Defs.Strings.coq_String

              val lex :
                MEM.STT.Defs.Coredefs.coq_Rule list ->
                MEM.STT.R.Defs.Strings.coq_String ->
                MEM.STT.Defs.Coredefs.coq_Token
                list * MEM.STT.R.Defs.Strings.coq_String
             end
           end

          module Lemmas :
           sig
            module IMPL :
             sig
              val max_pref_fn :
                MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
                MEM.STT.Ty.coq_State ->
                ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                option

              val extract_fsm_for_max :
                MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
                (MEM.STT.Ty.coq_Label * MEM.STT.Ty.coq_State) ->
                MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                option

              val max_prefs :
                MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
                (MEM.STT.Ty.coq_Label * MEM.STT.Ty.coq_State) list ->
                (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                option) list

              val longer_pref :
                (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                option) ->
                (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                option) ->
                MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                option

              val max_of_prefs :
                (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                option) list ->
                MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                option

              val init_srule :
                MEM.STT.Defs.Coredefs.coq_Rule -> MEM.STT.Defs.Coredefs.sRule
             end
           end
         end
       end

      module Invariants :
       sig
       end
     end

    module L :
     sig
      module IMPL :
       sig
        module LEM :
         sig
          module IMPL :
           sig
            val max_pref_fn :
              MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
              MEM.STT.Ty.coq_State ->
              ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
              option

            val extract_fsm_for_max :
              MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
              (MEM.STT.Ty.coq_Label * MEM.STT.Ty.coq_State) ->
              MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
              option

            val max_prefs :
              MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
              (MEM.STT.Ty.coq_Label * MEM.STT.Ty.coq_State) list ->
              (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
              option) list

            val longer_pref :
              (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
              option) ->
              (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
              option) ->
              MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
              option

            val max_of_prefs :
              (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
              option) list ->
              MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
              option

            val init_srule :
              MEM.STT.Defs.Coredefs.coq_Rule -> MEM.STT.Defs.Coredefs.sRule
           end
         end

        module Lex :
         sig
          val lex' :
            MEM.STT.Defs.Coredefs.sRule list ->
            MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
            MEM.STT.Defs.Coredefs.coq_Token
            list * MEM.STT.R.Defs.Strings.coq_String

          val lex :
            MEM.STT.Defs.Coredefs.coq_Rule list ->
            MEM.STT.R.Defs.Strings.coq_String ->
            MEM.STT.Defs.Coredefs.coq_Token
            list * MEM.STT.R.Defs.Strings.coq_String
         end
       end

      module Lemmas :
       sig
        module IMPL :
         sig
          val max_pref_fn :
            MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
            MEM.STT.Ty.coq_State ->
            ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
            option

          val extract_fsm_for_max :
            MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
            (MEM.STT.Ty.coq_Label * MEM.STT.Ty.coq_State) ->
            MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
            option

          val max_prefs :
            MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
            (MEM.STT.Ty.coq_Label * MEM.STT.Ty.coq_State) list ->
            (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
            option) list

          val longer_pref :
            (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
            option) ->
            (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
            option) ->
            MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
            option

          val max_of_prefs :
            (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
            option) list ->
            MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
            option

          val init_srule :
            MEM.STT.Defs.Coredefs.coq_Rule -> MEM.STT.Defs.Coredefs.sRule
         end
       end
     end

    module Utils :
     sig
      val zip : 'a1 list -> 'a2 list -> ('a1 * 'a2) list

      val unzip : ('a1 * 'a2) list -> 'a1 list * 'a2 list

      val ssnd : ('a1 * ('a2 * 'a3)) -> 'a3
     end

    module MPref :
     sig
      val max_pref_fn_M :
        MEMO.coq_Memo -> MEM.STT.R.Defs.Strings.coq_String ->
        MEM.STT.Ty.index -> MEM.STT.Ty.coq_State ->
        MEMO.coq_Memo * ((MEM.STT.R.Defs.Strings.coq_String * MEM.STT.R.Defs.Strings.coq_String) * MEM.STT.Ty.index)
        option

      val extract_fsm_for_max_M :
        MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
        (MEMO.coq_Memo * (MEM.STT.Ty.coq_Label * MEM.STT.Ty.coq_State)) ->
        MEMO.coq_Memo * (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
        option)

      val max_prefs_M :
        MEMO.coq_Memo list -> MEM.STT.R.Defs.Strings.coq_String ->
        MEM.STT.Ty.index -> (MEM.STT.Ty.coq_Label * MEM.STT.Ty.coq_State)
        list -> MEMO.coq_Memo
        list * (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
        option) list

      val max_of_prefs_M :
        (MEMO.coq_Memo
        list * (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
        option) list) -> (MEMO.coq_Memo
        list * MEM.STT.Ty.coq_Label) * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
        option
     end

    module TypeCheckLemmas :
     sig
      module MemoEq :
       sig
       end

      module Accessible :
       sig
       end

      module Lengths :
       sig
       end

      module LexyClosure :
       sig
       end

      module IndexClosure :
       sig
       end
     end

    module Lex :
     sig
      val lex'_M :
        MEM.STT.R.Defs.Strings.coq_String -> MEMO.coq_Memo list ->
        MEM.STT.Defs.Coredefs.sRule list -> MEM.STT.R.Defs.Strings.coq_String
        -> MEM.STT.Ty.index -> (MEMO.coq_Memo
        list * MEM.STT.Defs.Coredefs.coq_Token
        list) * MEM.STT.R.Defs.Strings.coq_String

      val init_srule :
        MEM.STT.Defs.Coredefs.coq_Rule -> MEM.STT.Defs.Coredefs.sRule

      val init_Memos : MEM.STT.Defs.Coredefs.sRule list -> MEMO.coq_Memo list

      val lex_M :
        MEM.STT.Defs.Coredefs.coq_Rule list ->
        MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Defs.Coredefs.coq_Token
        list * MEM.STT.R.Defs.Strings.coq_String
     end
   end

  module CaseLemmas :
   sig
   end
 end

module Trie :
 sig
  type 'target coq_Trie =
  | Leaf
  | Branch of 'target option * 'target coq_Trie * 'target coq_Trie

  val set_Trie : 'a1 coq_Trie -> bool list -> 'a1 -> 'a1 coq_Trie

  val get_Trie : 'a1 coq_Trie -> bool list -> 'a1 option
 end

module FMemo :
 functor (STT:Coq_T) ->
 sig
  module Pointer_as_UOT :
   sig
    type t = STT.Defs.Pointer_as_UCT.t

    val compare : t -> t -> t compare0

    val eq_dec : t -> t -> bool
   end

  module FM :
   sig
    module E :
     sig
      type t = STT.Defs.Pointer_as_UCT.t

      val compare :
        STT.Defs.Pointer_as_UCT.t -> STT.Defs.Pointer_as_UCT.t ->
        STT.Defs.Pointer_as_UCT.t compare0

      val eq_dec :
        STT.Defs.Pointer_as_UCT.t -> STT.Defs.Pointer_as_UCT.t -> bool
     end

    module Raw :
     sig
      type key = STT.Defs.Pointer_as_UCT.t

      type 'elt tree =
      | Leaf
      | Node of 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t

      val tree_rect :
        'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
        Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

      val tree_rec :
        'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
        Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

      val height : 'a1 tree -> Z_as_Int.t

      val cardinal : 'a1 tree -> nat

      val empty : 'a1 tree

      val is_empty : 'a1 tree -> bool

      val mem : STT.Defs.Pointer_as_UCT.t -> 'a1 tree -> bool

      val find : STT.Defs.Pointer_as_UCT.t -> 'a1 tree -> 'a1 option

      val create : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

      val assert_false : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

      val bal : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

      val add : key -> 'a1 -> 'a1 tree -> 'a1 tree

      val remove_min :
        'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree * (key * 'a1)

      val merge : 'a1 tree -> 'a1 tree -> 'a1 tree

      val remove : STT.Defs.Pointer_as_UCT.t -> 'a1 tree -> 'a1 tree

      val join : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

      type 'elt triple = { t_left : 'elt tree; t_opt : 'elt option;
                           t_right : 'elt tree }

      val t_left : 'a1 triple -> 'a1 tree

      val t_opt : 'a1 triple -> 'a1 option

      val t_right : 'a1 triple -> 'a1 tree

      val split : STT.Defs.Pointer_as_UCT.t -> 'a1 tree -> 'a1 triple

      val concat : 'a1 tree -> 'a1 tree -> 'a1 tree

      val elements_aux : (key * 'a1) list -> 'a1 tree -> (key * 'a1) list

      val elements : 'a1 tree -> (key * 'a1) list

      val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

      type 'elt enumeration =
      | End
      | More of key * 'elt * 'elt tree * 'elt enumeration

      val enumeration_rect :
        'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 -> 'a2) ->
        'a1 enumeration -> 'a2

      val enumeration_rec :
        'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 -> 'a2) ->
        'a1 enumeration -> 'a2

      val cons : 'a1 tree -> 'a1 enumeration -> 'a1 enumeration

      val equal_more :
        ('a1 -> 'a1 -> bool) -> STT.Defs.Pointer_as_UCT.t -> 'a1 -> ('a1
        enumeration -> bool) -> 'a1 enumeration -> bool

      val equal_cont :
        ('a1 -> 'a1 -> bool) -> 'a1 tree -> ('a1 enumeration -> bool) -> 'a1
        enumeration -> bool

      val equal_end : 'a1 enumeration -> bool

      val equal : ('a1 -> 'a1 -> bool) -> 'a1 tree -> 'a1 tree -> bool

      val map : ('a1 -> 'a2) -> 'a1 tree -> 'a2 tree

      val mapi : (key -> 'a1 -> 'a2) -> 'a1 tree -> 'a2 tree

      val map_option : (key -> 'a1 -> 'a2 option) -> 'a1 tree -> 'a2 tree

      val map2_opt :
        (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3 tree) ->
        ('a2 tree -> 'a3 tree) -> 'a1 tree -> 'a2 tree -> 'a3 tree

      val map2 :
        ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 tree -> 'a2 tree ->
        'a3 tree

      module Proofs :
       sig
        module MX :
         sig
          module TO :
           sig
            type t = STT.Defs.Pointer_as_UCT.t
           end

          module IsTO :
           sig
           end

          module OrderTac :
           sig
           end

          val eq_dec :
            STT.Defs.Pointer_as_UCT.t -> STT.Defs.Pointer_as_UCT.t -> bool

          val lt_dec :
            STT.Defs.Pointer_as_UCT.t -> STT.Defs.Pointer_as_UCT.t -> bool

          val eqb :
            STT.Defs.Pointer_as_UCT.t -> STT.Defs.Pointer_as_UCT.t -> bool
         end

        module PX :
         sig
          module MO :
           sig
            module TO :
             sig
              type t = STT.Defs.Pointer_as_UCT.t
             end

            module IsTO :
             sig
             end

            module OrderTac :
             sig
             end

            val eq_dec :
              STT.Defs.Pointer_as_UCT.t -> STT.Defs.Pointer_as_UCT.t -> bool

            val lt_dec :
              STT.Defs.Pointer_as_UCT.t -> STT.Defs.Pointer_as_UCT.t -> bool

            val eqb :
              STT.Defs.Pointer_as_UCT.t -> STT.Defs.Pointer_as_UCT.t -> bool
           end
         end

        module L :
         sig
          module MX :
           sig
            module TO :
             sig
              type t = STT.Defs.Pointer_as_UCT.t
             end

            module IsTO :
             sig
             end

            module OrderTac :
             sig
             end

            val eq_dec :
              STT.Defs.Pointer_as_UCT.t -> STT.Defs.Pointer_as_UCT.t -> bool

            val lt_dec :
              STT.Defs.Pointer_as_UCT.t -> STT.Defs.Pointer_as_UCT.t -> bool

            val eqb :
              STT.Defs.Pointer_as_UCT.t -> STT.Defs.Pointer_as_UCT.t -> bool
           end

          module PX :
           sig
            module MO :
             sig
              module TO :
               sig
                type t = STT.Defs.Pointer_as_UCT.t
               end

              module IsTO :
               sig
               end

              module OrderTac :
               sig
               end

              val eq_dec :
                STT.Defs.Pointer_as_UCT.t -> STT.Defs.Pointer_as_UCT.t -> bool

              val lt_dec :
                STT.Defs.Pointer_as_UCT.t -> STT.Defs.Pointer_as_UCT.t -> bool

              val eqb :
                STT.Defs.Pointer_as_UCT.t -> STT.Defs.Pointer_as_UCT.t -> bool
             end
           end

          type key = STT.Defs.Pointer_as_UCT.t

          type 'elt t = (STT.Defs.Pointer_as_UCT.t * 'elt) list

          val empty : 'a1 t

          val is_empty : 'a1 t -> bool

          val mem : key -> 'a1 t -> bool

          type 'elt coq_R_mem =
          | R_mem_0 of 'elt t
          | R_mem_1 of 'elt t * STT.Defs.Pointer_as_UCT.t * 'elt
             * (STT.Defs.Pointer_as_UCT.t * 'elt) list
          | R_mem_2 of 'elt t * STT.Defs.Pointer_as_UCT.t * 'elt
             * (STT.Defs.Pointer_as_UCT.t * 'elt) list
          | R_mem_3 of 'elt t * STT.Defs.Pointer_as_UCT.t * 'elt
             * (STT.Defs.Pointer_as_UCT.t * 'elt) list * bool * 'elt coq_R_mem

          val coq_R_mem_rect :
            key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
            STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
            -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
            -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> bool
            -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 t -> bool -> 'a1 coq_R_mem
            -> 'a2

          val coq_R_mem_rec :
            key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
            STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
            -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
            -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> bool
            -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 t -> bool -> 'a1 coq_R_mem
            -> 'a2

          val mem_rect :
            key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
            STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
            -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
            -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2
            -> 'a2) -> 'a1 t -> 'a2

          val mem_rec :
            key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
            STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
            -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
            -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2
            -> 'a2) -> 'a1 t -> 'a2

          val coq_R_mem_correct : key -> 'a1 t -> bool -> 'a1 coq_R_mem

          val find : key -> 'a1 t -> 'a1 option

          type 'elt coq_R_find =
          | R_find_0 of 'elt t
          | R_find_1 of 'elt t * STT.Defs.Pointer_as_UCT.t * 'elt
             * (STT.Defs.Pointer_as_UCT.t * 'elt) list
          | R_find_2 of 'elt t * STT.Defs.Pointer_as_UCT.t * 'elt
             * (STT.Defs.Pointer_as_UCT.t * 'elt) list
          | R_find_3 of 'elt t * STT.Defs.Pointer_as_UCT.t * 'elt
             * (STT.Defs.Pointer_as_UCT.t * 'elt) list * 'elt option
             * 'elt coq_R_find

          val coq_R_find_rect :
            key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
            STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
            -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
            -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1
            option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> 'a1 t -> 'a1 option ->
            'a1 coq_R_find -> 'a2

          val coq_R_find_rec :
            key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
            STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
            -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
            -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1
            option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> 'a1 t -> 'a1 option ->
            'a1 coq_R_find -> 'a2

          val find_rect :
            key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
            STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
            -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
            -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2
            -> 'a2) -> 'a1 t -> 'a2

          val find_rec :
            key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
            STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
            -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
            -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2
            -> 'a2) -> 'a1 t -> 'a2

          val coq_R_find_correct :
            key -> 'a1 t -> 'a1 option -> 'a1 coq_R_find

          val add : key -> 'a1 -> 'a1 t -> 'a1 t

          type 'elt coq_R_add =
          | R_add_0 of 'elt t
          | R_add_1 of 'elt t * STT.Defs.Pointer_as_UCT.t * 'elt
             * (STT.Defs.Pointer_as_UCT.t * 'elt) list
          | R_add_2 of 'elt t * STT.Defs.Pointer_as_UCT.t * 'elt
             * (STT.Defs.Pointer_as_UCT.t * 'elt) list
          | R_add_3 of 'elt t * STT.Defs.Pointer_as_UCT.t * 'elt
             * (STT.Defs.Pointer_as_UCT.t * 'elt) list * 'elt t
             * 'elt coq_R_add

          val coq_R_add_rect :
            key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
            STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
            -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
            -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1 t
            -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1
            coq_R_add -> 'a2

          val coq_R_add_rec :
            key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
            STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
            -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
            -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1 t
            -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1
            coq_R_add -> 'a2

          val add_rect :
            key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
            STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
            -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
            -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2
            -> 'a2) -> 'a1 t -> 'a2

          val add_rec :
            key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
            STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
            -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
            -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2
            -> 'a2) -> 'a1 t -> 'a2

          val coq_R_add_correct :
            key -> 'a1 -> 'a1 t -> 'a1 t -> 'a1 coq_R_add

          val remove : key -> 'a1 t -> 'a1 t

          type 'elt coq_R_remove =
          | R_remove_0 of 'elt t
          | R_remove_1 of 'elt t * STT.Defs.Pointer_as_UCT.t * 'elt
             * (STT.Defs.Pointer_as_UCT.t * 'elt) list
          | R_remove_2 of 'elt t * STT.Defs.Pointer_as_UCT.t * 'elt
             * (STT.Defs.Pointer_as_UCT.t * 'elt) list
          | R_remove_3 of 'elt t * STT.Defs.Pointer_as_UCT.t * 'elt
             * (STT.Defs.Pointer_as_UCT.t * 'elt) list * 'elt t
             * 'elt coq_R_remove

          val coq_R_remove_rect :
            key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
            STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
            -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
            -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1 t
            -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1
            coq_R_remove -> 'a2

          val coq_R_remove_rec :
            key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
            STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
            -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
            -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1 t
            -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1
            coq_R_remove -> 'a2

          val remove_rect :
            key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
            STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
            -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
            -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2
            -> 'a2) -> 'a1 t -> 'a2

          val remove_rec :
            key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
            STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
            -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
            -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2
            -> 'a2) -> 'a1 t -> 'a2

          val coq_R_remove_correct : key -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove

          val elements : 'a1 t -> 'a1 t

          val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

          type ('elt, 'a) coq_R_fold =
          | R_fold_0 of 'elt t * 'a
          | R_fold_1 of 'elt t * 'a * STT.Defs.Pointer_as_UCT.t * 'elt
             * (STT.Defs.Pointer_as_UCT.t * 'elt) list * 'a
             * ('elt, 'a) coq_R_fold

          val coq_R_fold_rect :
            (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) -> ('a1
            t -> 'a2 -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> 'a2 -> ('a1, 'a2)
            coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a2 -> ('a1, 'a2)
            coq_R_fold -> 'a3

          val coq_R_fold_rec :
            (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) -> ('a1
            t -> 'a2 -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> 'a2 -> ('a1, 'a2)
            coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a2 -> ('a1, 'a2)
            coq_R_fold -> 'a3

          val fold_rect :
            (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) -> ('a1
            t -> 'a2 -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> 'a3 -> 'a3) ->
            'a1 t -> 'a2 -> 'a3

          val fold_rec :
            (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) -> ('a1
            t -> 'a2 -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> 'a3 -> 'a3) ->
            'a1 t -> 'a2 -> 'a3

          val coq_R_fold_correct :
            (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2 -> ('a1, 'a2)
            coq_R_fold

          val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool

          type 'elt coq_R_equal =
          | R_equal_0 of 'elt t * 'elt t
          | R_equal_1 of 'elt t * 'elt t * STT.Defs.Pointer_as_UCT.t * 
             'elt * (STT.Defs.Pointer_as_UCT.t * 'elt) list
             * STT.Defs.Pointer_as_UCT.t * 'elt
             * (STT.Defs.Pointer_as_UCT.t * 'elt) list * bool
             * 'elt coq_R_equal
          | R_equal_2 of 'elt t * 'elt t * STT.Defs.Pointer_as_UCT.t * 
             'elt * (STT.Defs.Pointer_as_UCT.t * 'elt) list
             * STT.Defs.Pointer_as_UCT.t * 'elt
             * (STT.Defs.Pointer_as_UCT.t * 'elt) list
             * STT.Defs.Pointer_as_UCT.t compare0
          | R_equal_3 of 'elt t * 'elt t * 'elt t * 'elt t

          val coq_R_equal_rect :
            ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) ->
            ('a1 t -> 'a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ ->
            STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> bool
            -> 'a1 coq_R_equal -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t ->
            STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ ->
            STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ ->
            STT.Defs.Pointer_as_UCT.t compare0 -> __ -> __ -> 'a2) -> ('a1 t
            -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2) -> 'a1 t ->
            'a1 t -> bool -> 'a1 coq_R_equal -> 'a2

          val coq_R_equal_rec :
            ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) ->
            ('a1 t -> 'a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ ->
            STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> bool
            -> 'a1 coq_R_equal -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t ->
            STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ ->
            STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ ->
            STT.Defs.Pointer_as_UCT.t compare0 -> __ -> __ -> 'a2) -> ('a1 t
            -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2) -> 'a1 t ->
            'a1 t -> bool -> 'a1 coq_R_equal -> 'a2

          val equal_rect :
            ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) ->
            ('a1 t -> 'a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ ->
            STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2
            -> 'a2) -> ('a1 t -> 'a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ ->
            STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ ->
            STT.Defs.Pointer_as_UCT.t compare0 -> __ -> __ -> 'a2) -> ('a1 t
            -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2) -> 'a1 t ->
            'a1 t -> 'a2

          val equal_rec :
            ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2) ->
            ('a1 t -> 'a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ ->
            STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2
            -> 'a2) -> ('a1 t -> 'a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ ->
            STT.Defs.Pointer_as_UCT.t -> 'a1 ->
            (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ ->
            STT.Defs.Pointer_as_UCT.t compare0 -> __ -> __ -> 'a2) -> ('a1 t
            -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2) -> 'a1 t ->
            'a1 t -> 'a2

          val coq_R_equal_correct :
            ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool -> 'a1 coq_R_equal

          val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

          val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

          val option_cons :
            key -> 'a1 option -> (key * 'a1) list -> (key * 'a1) list

          val map2_l :
            ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a3 t

          val map2_r :
            ('a1 option -> 'a2 option -> 'a3 option) -> 'a2 t -> 'a3 t

          val map2 :
            ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t -> 'a3
            t

          val combine : 'a1 t -> 'a2 t -> ('a1 option * 'a2 option) t

          val fold_right_pair :
            ('a1 -> 'a2 -> 'a3 -> 'a3) -> ('a1 * 'a2) list -> 'a3 -> 'a3

          val map2_alt :
            ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t ->
            (key * 'a3) list

          val at_least_one :
            'a1 option -> 'a2 option -> ('a1 option * 'a2 option) option

          val at_least_one_then_f :
            ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 option -> 'a2
            option -> 'a3 option
         end

        type 'elt coq_R_mem =
        | R_mem_0 of 'elt tree
        | R_mem_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * bool * 'elt coq_R_mem
        | R_mem_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t
        | R_mem_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * bool * 'elt coq_R_mem

        val coq_R_mem_rect :
          STT.Defs.Pointer_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree
          -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
          __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree
          -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2)
          -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
          __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 tree
          -> bool -> 'a1 coq_R_mem -> 'a2

        val coq_R_mem_rec :
          STT.Defs.Pointer_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree
          -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
          __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree
          -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2)
          -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
          __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 tree
          -> bool -> 'a1 coq_R_mem -> 'a2

        type 'elt coq_R_find =
        | R_find_0 of 'elt tree
        | R_find_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * 'elt option * 'elt coq_R_find
        | R_find_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t
        | R_find_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * 'elt option * 'elt coq_R_find

        val coq_R_find_rect :
          STT.Defs.Pointer_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree
          -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
          __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> ('a1 tree ->
          'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __
          -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2
          -> 'a2) -> 'a1 tree -> 'a1 option -> 'a1 coq_R_find -> 'a2

        val coq_R_find_rec :
          STT.Defs.Pointer_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree
          -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
          __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> ('a1 tree ->
          'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __
          -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2
          -> 'a2) -> 'a1 tree -> 'a1 option -> 'a1 coq_R_find -> 'a2

        type 'elt coq_R_bal =
        | R_bal_0 of 'elt tree * key * 'elt * 'elt tree
        | R_bal_1 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
           key * 'elt * 'elt tree * Z_as_Int.t
        | R_bal_2 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
           key * 'elt * 'elt tree * Z_as_Int.t
        | R_bal_3 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
           key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 'elt
           * 'elt tree * Z_as_Int.t
        | R_bal_4 of 'elt tree * key * 'elt * 'elt tree
        | R_bal_5 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
           key * 'elt * 'elt tree * Z_as_Int.t
        | R_bal_6 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
           key * 'elt * 'elt tree * Z_as_Int.t
        | R_bal_7 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
           key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 'elt
           * 'elt tree * Z_as_Int.t
        | R_bal_8 of 'elt tree * key * 'elt * 'elt tree

        val coq_R_bal_rect :
          ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> 'a2) ->
          ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key
          -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1
          tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key ->
          'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) ->
          ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key
          -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree ->
          key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2) -> ('a1 tree ->
          key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> __ -> 'a2) ->
          ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1
          tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
          'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __
          -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
          __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
          -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
          __ -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
          -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ ->
          __ -> __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree
          -> 'a1 coq_R_bal -> 'a2

        val coq_R_bal_rec :
          ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> 'a2) ->
          ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key
          -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1
          tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key ->
          'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) ->
          ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key
          -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree ->
          key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2) -> ('a1 tree ->
          key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> __ -> 'a2) ->
          ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1
          tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
          'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __
          -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
          __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
          -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
          __ -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
          -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ ->
          __ -> __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree
          -> 'a1 coq_R_bal -> 'a2

        type 'elt coq_R_add =
        | R_add_0 of 'elt tree
        | R_add_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * 'elt tree * 'elt coq_R_add
        | R_add_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t
        | R_add_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * 'elt tree * 'elt coq_R_add

        val coq_R_add_rect :
          key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
          key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree
          -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree -> key ->
          'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1
          tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
          __ -> __ -> 'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 tree ->
          'a1 tree -> 'a1 coq_R_add -> 'a2

        val coq_R_add_rec :
          key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
          key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree
          -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree -> key ->
          'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1
          tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
          __ -> __ -> 'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 tree ->
          'a1 tree -> 'a1 coq_R_add -> 'a2

        type 'elt coq_R_remove_min =
        | R_remove_min_0 of 'elt tree * key * 'elt * 'elt tree
        | R_remove_min_1 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
           * key * 'elt * 'elt tree * Z_as_Int.t * ('elt tree * (key * 'elt))
           * 'elt coq_R_remove_min * 'elt tree * (key * 'elt)

        val coq_R_remove_min_rect :
          ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1 tree ->
          key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> ('a1 tree * (key * 'a1)) -> 'a1
          coq_R_remove_min -> 'a2 -> 'a1 tree -> (key * 'a1) -> __ -> 'a2) ->
          'a1 tree -> key -> 'a1 -> 'a1 tree -> ('a1 tree * (key * 'a1)) ->
          'a1 coq_R_remove_min -> 'a2

        val coq_R_remove_min_rec :
          ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1 tree ->
          key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> ('a1 tree * (key * 'a1)) -> 'a1
          coq_R_remove_min -> 'a2 -> 'a1 tree -> (key * 'a1) -> __ -> 'a2) ->
          'a1 tree -> key -> 'a1 -> 'a1 tree -> ('a1 tree * (key * 'a1)) ->
          'a1 coq_R_remove_min -> 'a2

        type 'elt coq_R_merge =
        | R_merge_0 of 'elt tree * 'elt tree
        | R_merge_1 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
           * 'elt tree * Z_as_Int.t
        | R_merge_2 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
           * 'elt tree * Z_as_Int.t * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * 'elt tree * (key * 'elt) * key * 'elt

        val coq_R_merge_rect :
          ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1
          tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a2) ->
          ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> key -> 'a1 ->
          __ -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_merge
          -> 'a2

        val coq_R_merge_rec :
          ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1
          tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a2) ->
          ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> key -> 'a1 ->
          __ -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_merge
          -> 'a2

        type 'elt coq_R_remove =
        | R_remove_0 of 'elt tree
        | R_remove_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * 'elt tree * 'elt coq_R_remove
        | R_remove_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t
        | R_remove_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * 'elt tree * 'elt coq_R_remove

        val coq_R_remove_rect :
          STT.Defs.Pointer_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree
          -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
          __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> ('a1 tree ->
          'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __
          -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2
          -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_remove -> 'a2

        val coq_R_remove_rec :
          STT.Defs.Pointer_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree
          -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
          __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> ('a1 tree ->
          'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __
          -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2
          -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_remove -> 'a2

        type 'elt coq_R_concat =
        | R_concat_0 of 'elt tree * 'elt tree
        | R_concat_1 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
           * 'elt tree * Z_as_Int.t
        | R_concat_2 of 'elt tree * 'elt tree * 'elt tree * key * 'elt
           * 'elt tree * Z_as_Int.t * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * 'elt tree * (key * 'elt)

        val coq_R_concat_rect :
          ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1
          tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a2) ->
          ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> 'a2) -> 'a1
          tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_concat -> 'a2

        val coq_R_concat_rec :
          ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1
          tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a2) ->
          ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> 'a2) -> 'a1
          tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_concat -> 'a2

        type 'elt coq_R_split =
        | R_split_0 of 'elt tree
        | R_split_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * 'elt triple * 'elt coq_R_split * 'elt tree
           * 'elt option * 'elt tree
        | R_split_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t
        | R_split_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * 'elt triple * 'elt coq_R_split * 'elt tree
           * 'elt option * 'elt tree

        val coq_R_split_rect :
          STT.Defs.Pointer_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree
          -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
          __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1
          option -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key ->
          'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1
          tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
          __ -> __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1
          option -> 'a1 tree -> __ -> 'a2) -> 'a1 tree -> 'a1 triple -> 'a1
          coq_R_split -> 'a2

        val coq_R_split_rec :
          STT.Defs.Pointer_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree
          -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
          __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1
          option -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key ->
          'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1
          tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
          __ -> __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1
          option -> 'a1 tree -> __ -> 'a2) -> 'a1 tree -> 'a1 triple -> 'a1
          coq_R_split -> 'a2

        type ('elt, 'x) coq_R_map_option =
        | R_map_option_0 of 'elt tree
        | R_map_option_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * 'x * 'x tree * ('elt, 'x) coq_R_map_option
           * 'x tree * ('elt, 'x) coq_R_map_option
        | R_map_option_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
           * Z_as_Int.t * 'x tree * ('elt, 'x) coq_R_map_option * 'x tree
           * ('elt, 'x) coq_R_map_option

        val coq_R_map_option_rect :
          (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) -> ('a1 tree
          -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 ->
          __ -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2 tree ->
          ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> ('a1 tree -> 'a1 tree
          -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a2 tree ->
          ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2 tree -> ('a1, 'a2)
          coq_R_map_option -> 'a3 -> 'a3) -> 'a1 tree -> 'a2 tree -> ('a1,
          'a2) coq_R_map_option -> 'a3

        val coq_R_map_option_rec :
          (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) -> ('a1 tree
          -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 ->
          __ -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2 tree ->
          ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> ('a1 tree -> 'a1 tree
          -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a2 tree ->
          ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2 tree -> ('a1, 'a2)
          coq_R_map_option -> 'a3 -> 'a3) -> 'a1 tree -> 'a2 tree -> ('a1,
          'a2) coq_R_map_option -> 'a3

        type ('elt, 'x0, 'x) coq_R_map2_opt =
        | R_map2_opt_0 of 'elt tree * 'x0 tree
        | R_map2_opt_1 of 'elt tree * 'x0 tree * 'elt tree * key * 'elt
           * 'elt tree * Z_as_Int.t
        | R_map2_opt_2 of 'elt tree * 'x0 tree * 'elt tree * key * 'elt
           * 'elt tree * Z_as_Int.t * 'x0 tree * key * 'x0 * 'x0 tree
           * Z_as_Int.t * 'x0 tree * 'x0 option * 'x0 tree * 'x * 'x tree
           * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
           * ('elt, 'x0, 'x) coq_R_map2_opt
        | R_map2_opt_3 of 'elt tree * 'x0 tree * 'elt tree * key * 'elt
           * 'elt tree * Z_as_Int.t * 'x0 tree * key * 'x0 * 'x0 tree
           * Z_as_Int.t * 'x0 tree * 'x0 option * 'x0 tree * 'x tree
           * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
           * ('elt, 'x0, 'x) coq_R_map2_opt

        val coq_R_map2_opt_rect :
          (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3 tree)
          -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2 tree -> __ -> 'a4) ->
          ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> __ -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree
          -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 tree -> key ->
          'a2 -> 'a2 tree -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2 option ->
          'a2 tree -> __ -> 'a3 -> __ -> 'a3 tree -> ('a1, 'a2, 'a3)
          coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt
          -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1
          -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 tree -> key -> 'a2 -> 'a2
          tree -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2 option -> 'a2 tree ->
          __ -> __ -> 'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 ->
          'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1
          tree -> 'a2 tree -> 'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt ->
          'a4

        val coq_R_map2_opt_rec :
          (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3 tree)
          -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2 tree -> __ -> 'a4) ->
          ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
          Z_as_Int.t -> __ -> __ -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree
          -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 tree -> key ->
          'a2 -> 'a2 tree -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2 option ->
          'a2 tree -> __ -> 'a3 -> __ -> 'a3 tree -> ('a1, 'a2, 'a3)
          coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt
          -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1
          -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 tree -> key -> 'a2 -> 'a2
          tree -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2 option -> 'a2 tree ->
          __ -> __ -> 'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 ->
          'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1
          tree -> 'a2 tree -> 'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt ->
          'a4

        val fold' : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

        val flatten_e : 'a1 enumeration -> (key * 'a1) list
       end
     end

    type 'elt bst =
      'elt Raw.tree
      (* singleton inductive, whose constructor was Bst *)

    val this : 'a1 bst -> 'a1 Raw.tree

    type 'elt t = 'elt bst

    type key = STT.Defs.Pointer_as_UCT.t

    val empty : 'a1 t

    val is_empty : 'a1 t -> bool

    val add : key -> 'a1 -> 'a1 t -> 'a1 t

    val remove : key -> 'a1 t -> 'a1 t

    val mem : key -> 'a1 t -> bool

    val find : key -> 'a1 t -> 'a1 option

    val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

    val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

    val map2 :
      ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t -> 'a3 t

    val elements : 'a1 t -> (key * 'a1) list

    val cardinal : 'a1 t -> nat

    val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

    val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool
   end

  module FMF :
   sig
    val eqb : STT.Defs.Pointer_as_UCT.t -> STT.Defs.Pointer_as_UCT.t -> bool

    val coq_In_dec : 'a1 FM.t -> FM.key -> bool
   end

  type coq_Memo =
    ((STT.R.Defs.Strings.coq_String * STT.R.Defs.Strings.coq_String) * STT.Ty.index)
    option Trie.coq_Trie FM.t

  val emptyMemo : coq_Memo

  val get_Memo :
    coq_Memo -> STT.Ty.coq_Pointer -> STT.Ty.index ->
    ((STT.R.Defs.Strings.coq_String * STT.R.Defs.Strings.coq_String) * STT.Ty.index)
    option option

  val set_Memo :
    coq_Memo -> STT.Ty.coq_Pointer -> STT.Ty.index ->
    ((STT.R.Defs.Strings.coq_String * STT.R.Defs.Strings.coq_String) * STT.Ty.index)
    option -> coq_Memo
 end

module LexerFn :
 functor (ALPHABET__0:SIGMA) ->
 functor (LABELS:LABEL) ->
 sig
  module MEM :
   sig
    module STT :
     sig
      module TabT :
       sig
        module R :
         sig
          module Ty :
           sig
            type coq_Sigma = ALPHABET__0.coq_Sigma

            val coq_SigmaEnum : coq_Sigma list

            val coq_Sigma_dec : coq_Sigma -> coq_Sigma -> bool

            val compareT : coq_Sigma -> coq_Sigma -> comparison

            val ascii2Sigma : char -> coq_Sigma
           end

          module Defs :
           sig
            module T_as_UCT :
             sig
              type t = Ty.coq_Sigma

              val compare : Ty.coq_Sigma -> Ty.coq_Sigma -> comparison
             end

            module T_as_UOT :
             sig
              type t = T_as_UCT.t

              val compare : t -> t -> t compare0

              val eq_dec : t -> t -> bool
             end

            module SigFS :
             sig
              module X' :
               sig
                type t = T_as_UCT.t

                val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                val compare : T_as_UCT.t -> T_as_UCT.t -> comparison
               end

              module MSet :
               sig
                module Raw :
                 sig
                  type elt = T_as_UCT.t

                  type tree =
                  | Leaf
                  | Node of Z_as_Int.t * tree * T_as_UCT.t * tree

                  val empty : tree

                  val is_empty : tree -> bool

                  val mem : T_as_UCT.t -> tree -> bool

                  val min_elt : tree -> elt option

                  val max_elt : tree -> elt option

                  val choose : tree -> elt option

                  val fold : (elt -> 'a1 -> 'a1) -> tree -> 'a1 -> 'a1

                  val elements_aux :
                    T_as_UCT.t list -> tree -> T_as_UCT.t list

                  val elements : tree -> T_as_UCT.t list

                  val rev_elements_aux :
                    T_as_UCT.t list -> tree -> T_as_UCT.t list

                  val rev_elements : tree -> T_as_UCT.t list

                  val cardinal : tree -> nat

                  val maxdepth : tree -> nat

                  val mindepth : tree -> nat

                  val for_all : (elt -> bool) -> tree -> bool

                  val exists_ : (elt -> bool) -> tree -> bool

                  type enumeration =
                  | End
                  | More of elt * tree * enumeration

                  val cons : tree -> enumeration -> enumeration

                  val compare_more :
                    T_as_UCT.t -> (enumeration -> comparison) -> enumeration
                    -> comparison

                  val compare_cont :
                    tree -> (enumeration -> comparison) -> enumeration ->
                    comparison

                  val compare_end : enumeration -> comparison

                  val compare : tree -> tree -> comparison

                  val equal : tree -> tree -> bool

                  val subsetl : (tree -> bool) -> T_as_UCT.t -> tree -> bool

                  val subsetr : (tree -> bool) -> T_as_UCT.t -> tree -> bool

                  val subset : tree -> tree -> bool

                  type t = tree

                  val height : t -> Z_as_Int.t

                  val singleton : T_as_UCT.t -> tree

                  val create : t -> T_as_UCT.t -> t -> tree

                  val assert_false : t -> T_as_UCT.t -> t -> tree

                  val bal : t -> T_as_UCT.t -> t -> tree

                  val add : T_as_UCT.t -> tree -> tree

                  val join : tree -> elt -> t -> t

                  val remove_min : tree -> elt -> t -> t * elt

                  val merge : tree -> tree -> tree

                  val remove : T_as_UCT.t -> tree -> tree

                  val concat : tree -> tree -> tree

                  type triple = { t_left : t; t_in : bool; t_right : t }

                  val t_left : triple -> t

                  val t_in : triple -> bool

                  val t_right : triple -> t

                  val split : T_as_UCT.t -> tree -> triple

                  val inter : tree -> tree -> tree

                  val diff : tree -> tree -> tree

                  val union : tree -> tree -> tree

                  val filter : (elt -> bool) -> tree -> tree

                  val partition : (elt -> bool) -> t -> t * t

                  val ltb_tree : T_as_UCT.t -> tree -> bool

                  val gtb_tree : T_as_UCT.t -> tree -> bool

                  val isok : tree -> bool

                  module MX :
                   sig
                    module OrderTac :
                     sig
                      module OTF :
                       sig
                        type t = T_as_UCT.t

                        val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

                        val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
                       end

                      module TO :
                       sig
                        type t = T_as_UCT.t

                        val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

                        val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
                       end
                     end

                    val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                    val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                    val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
                   end

                  type coq_R_min_elt =
                  | R_min_elt_0 of tree
                  | R_min_elt_1 of tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree
                  | R_min_elt_2 of tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree * Z_as_Int.t * tree * T_as_UCT.t * tree
                     * elt option * coq_R_min_elt

                  type coq_R_max_elt =
                  | R_max_elt_0 of tree
                  | R_max_elt_1 of tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree
                  | R_max_elt_2 of tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree * Z_as_Int.t * tree * T_as_UCT.t * tree
                     * elt option * coq_R_max_elt

                  module L :
                   sig
                    module MO :
                     sig
                      module OrderTac :
                       sig
                        module OTF :
                         sig
                          type t = T_as_UCT.t

                          val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

                          val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
                         end

                        module TO :
                         sig
                          type t = T_as_UCT.t

                          val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

                          val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
                         end
                       end

                      val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                      val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                      val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
                     end
                   end

                  val flatten_e : enumeration -> elt list

                  type coq_R_bal =
                  | R_bal_0 of t * T_as_UCT.t * t
                  | R_bal_1 of t * T_as_UCT.t * t * Z_as_Int.t * tree
                     * T_as_UCT.t * tree
                  | R_bal_2 of t * T_as_UCT.t * t * Z_as_Int.t * tree
                     * T_as_UCT.t * tree
                  | R_bal_3 of t * T_as_UCT.t * t * Z_as_Int.t * tree
                     * T_as_UCT.t * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree
                  | R_bal_4 of t * T_as_UCT.t * t
                  | R_bal_5 of t * T_as_UCT.t * t * Z_as_Int.t * tree
                     * T_as_UCT.t * tree
                  | R_bal_6 of t * T_as_UCT.t * t * Z_as_Int.t * tree
                     * T_as_UCT.t * tree
                  | R_bal_7 of t * T_as_UCT.t * t * Z_as_Int.t * tree
                     * T_as_UCT.t * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree
                  | R_bal_8 of t * T_as_UCT.t * t

                  type coq_R_remove_min =
                  | R_remove_min_0 of tree * elt * t
                  | R_remove_min_1 of tree * elt * t * Z_as_Int.t * tree
                     * T_as_UCT.t * tree * (t * elt) * coq_R_remove_min * 
                     t * elt

                  type coq_R_merge =
                  | R_merge_0 of tree * tree
                  | R_merge_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree
                  | R_merge_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree * Z_as_Int.t * tree * T_as_UCT.t * tree * 
                     t * elt

                  type coq_R_concat =
                  | R_concat_0 of tree * tree
                  | R_concat_1 of tree * tree * Z_as_Int.t * tree
                     * T_as_UCT.t * tree
                  | R_concat_2 of tree * tree * Z_as_Int.t * tree
                     * T_as_UCT.t * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree * t * elt

                  type coq_R_inter =
                  | R_inter_0 of tree * tree
                  | R_inter_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree
                  | R_inter_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree * Z_as_Int.t * tree * T_as_UCT.t * tree * 
                     t * bool * t * tree * coq_R_inter * tree * coq_R_inter
                  | R_inter_3 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree * Z_as_Int.t * tree * T_as_UCT.t * tree * 
                     t * bool * t * tree * coq_R_inter * tree * coq_R_inter

                  type coq_R_diff =
                  | R_diff_0 of tree * tree
                  | R_diff_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree
                  | R_diff_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree * Z_as_Int.t * tree * T_as_UCT.t * tree * 
                     t * bool * t * tree * coq_R_diff * tree * coq_R_diff
                  | R_diff_3 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree * Z_as_Int.t * tree * T_as_UCT.t * tree * 
                     t * bool * t * tree * coq_R_diff * tree * coq_R_diff

                  type coq_R_union =
                  | R_union_0 of tree * tree
                  | R_union_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree
                  | R_union_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree * Z_as_Int.t * tree * T_as_UCT.t * tree * 
                     t * bool * t * tree * coq_R_union * tree * coq_R_union
                 end

                module E :
                 sig
                  type t = T_as_UCT.t

                  val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

                  val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
                 end

                type elt = T_as_UCT.t

                type t_ =
                  Raw.t
                  (* singleton inductive, whose constructor was Mkt *)

                val this : t_ -> Raw.t

                type t = t_

                val mem : elt -> t -> bool

                val add : elt -> t -> t

                val remove : elt -> t -> t

                val singleton : elt -> t

                val union : t -> t -> t

                val inter : t -> t -> t

                val diff : t -> t -> t

                val equal : t -> t -> bool

                val subset : t -> t -> bool

                val empty : t

                val is_empty : t -> bool

                val elements : t -> elt list

                val choose : t -> elt option

                val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

                val cardinal : t -> nat

                val filter : (elt -> bool) -> t -> t

                val for_all : (elt -> bool) -> t -> bool

                val exists_ : (elt -> bool) -> t -> bool

                val partition : (elt -> bool) -> t -> t * t

                val eq_dec : t -> t -> bool

                val compare : t -> t -> comparison

                val min_elt : t -> elt option

                val max_elt : t -> elt option
               end

              type elt = T_as_UCT.t

              type t = MSet.t

              val empty : t

              val is_empty : t -> bool

              val mem : elt -> t -> bool

              val add : elt -> t -> t

              val singleton : elt -> t

              val remove : elt -> t -> t

              val union : t -> t -> t

              val inter : t -> t -> t

              val diff : t -> t -> t

              val eq_dec : t -> t -> bool

              val equal : t -> t -> bool

              val subset : t -> t -> bool

              val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

              val for_all : (elt -> bool) -> t -> bool

              val exists_ : (elt -> bool) -> t -> bool

              val filter : (elt -> bool) -> t -> t

              val partition : (elt -> bool) -> t -> t * t

              val cardinal : t -> nat

              val elements : t -> elt list

              val choose : t -> elt option

              module MF :
               sig
                val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
               end

              val min_elt : t -> elt option

              val max_elt : t -> elt option

              val compare : t -> t -> t compare0

              module E :
               sig
                type t = T_as_UCT.t

                val compare : T_as_UCT.t -> T_as_UCT.t -> T_as_UCT.t compare0

                val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
               end
             end

            module SigFSF :
             sig
              val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
             end

            module SigFM :
             sig
              module E :
               sig
                type t = T_as_UCT.t

                val compare : T_as_UCT.t -> T_as_UCT.t -> T_as_UCT.t compare0

                val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
               end

              module Raw :
               sig
                type key = T_as_UCT.t

                type 'elt tree =
                | Leaf
                | Node of 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t

                val tree_rect :
                  'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
                  Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

                val tree_rec :
                  'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
                  Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

                val height : 'a1 tree -> Z_as_Int.t

                val cardinal : 'a1 tree -> nat

                val empty : 'a1 tree

                val is_empty : 'a1 tree -> bool

                val mem : T_as_UCT.t -> 'a1 tree -> bool

                val find : T_as_UCT.t -> 'a1 tree -> 'a1 option

                val create : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

                val assert_false :
                  'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

                val bal : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

                val add : key -> 'a1 -> 'a1 tree -> 'a1 tree

                val remove_min :
                  'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree * (key * 'a1)

                val merge : 'a1 tree -> 'a1 tree -> 'a1 tree

                val remove : T_as_UCT.t -> 'a1 tree -> 'a1 tree

                val join : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

                type 'elt triple = { t_left : 'elt tree; t_opt : 'elt option;
                                     t_right : 'elt tree }

                val t_left : 'a1 triple -> 'a1 tree

                val t_opt : 'a1 triple -> 'a1 option

                val t_right : 'a1 triple -> 'a1 tree

                val split : T_as_UCT.t -> 'a1 tree -> 'a1 triple

                val concat : 'a1 tree -> 'a1 tree -> 'a1 tree

                val elements_aux :
                  (key * 'a1) list -> 'a1 tree -> (key * 'a1) list

                val elements : 'a1 tree -> (key * 'a1) list

                val fold :
                  (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

                type 'elt enumeration =
                | End
                | More of key * 'elt * 'elt tree * 'elt enumeration

                val enumeration_rect :
                  'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 ->
                  'a2) -> 'a1 enumeration -> 'a2

                val enumeration_rec :
                  'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 ->
                  'a2) -> 'a1 enumeration -> 'a2

                val cons : 'a1 tree -> 'a1 enumeration -> 'a1 enumeration

                val equal_more :
                  ('a1 -> 'a1 -> bool) -> T_as_UCT.t -> 'a1 -> ('a1
                  enumeration -> bool) -> 'a1 enumeration -> bool

                val equal_cont :
                  ('a1 -> 'a1 -> bool) -> 'a1 tree -> ('a1 enumeration ->
                  bool) -> 'a1 enumeration -> bool

                val equal_end : 'a1 enumeration -> bool

                val equal :
                  ('a1 -> 'a1 -> bool) -> 'a1 tree -> 'a1 tree -> bool

                val map : ('a1 -> 'a2) -> 'a1 tree -> 'a2 tree

                val mapi : (key -> 'a1 -> 'a2) -> 'a1 tree -> 'a2 tree

                val map_option :
                  (key -> 'a1 -> 'a2 option) -> 'a1 tree -> 'a2 tree

                val map2_opt :
                  (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree ->
                  'a3 tree) -> ('a2 tree -> 'a3 tree) -> 'a1 tree -> 'a2 tree
                  -> 'a3 tree

                val map2 :
                  ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 tree -> 'a2
                  tree -> 'a3 tree

                module Proofs :
                 sig
                  module MX :
                   sig
                    module TO :
                     sig
                      type t = T_as_UCT.t
                     end

                    module IsTO :
                     sig
                     end

                    module OrderTac :
                     sig
                     end

                    val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                    val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                    val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
                   end

                  module PX :
                   sig
                    module MO :
                     sig
                      module TO :
                       sig
                        type t = T_as_UCT.t
                       end

                      module IsTO :
                       sig
                       end

                      module OrderTac :
                       sig
                       end

                      val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                      val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                      val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
                     end
                   end

                  module L :
                   sig
                    module MX :
                     sig
                      module TO :
                       sig
                        type t = T_as_UCT.t
                       end

                      module IsTO :
                       sig
                       end

                      module OrderTac :
                       sig
                       end

                      val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                      val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                      val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
                     end

                    module PX :
                     sig
                      module MO :
                       sig
                        module TO :
                         sig
                          type t = T_as_UCT.t
                         end

                        module IsTO :
                         sig
                         end

                        module OrderTac :
                         sig
                         end

                        val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                        val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                        val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
                       end
                     end

                    type key = T_as_UCT.t

                    type 'elt t = (T_as_UCT.t * 'elt) list

                    val empty : 'a1 t

                    val is_empty : 'a1 t -> bool

                    val mem : key -> 'a1 t -> bool

                    type 'elt coq_R_mem =
                    | R_mem_0 of 'elt t
                    | R_mem_1 of 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list
                    | R_mem_2 of 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list
                    | R_mem_3 of 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list * bool * 'elt coq_R_mem

                    val coq_R_mem_rect :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                      'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                      'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 ->
                      'a2) -> 'a1 t -> bool -> 'a1 coq_R_mem -> 'a2

                    val coq_R_mem_rec :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                      'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                      'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 ->
                      'a2) -> 'a1 t -> bool -> 'a1 coq_R_mem -> 'a2

                    val mem_rect :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                      'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                      'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val mem_rec :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                      'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                      'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val coq_R_mem_correct :
                      key -> 'a1 t -> bool -> 'a1 coq_R_mem

                    val find : key -> 'a1 t -> 'a1 option

                    type 'elt coq_R_find =
                    | R_find_0 of 'elt t
                    | R_find_1 of 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list
                    | R_find_2 of 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list
                    | R_find_3 of 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list * 'elt option
                       * 'elt coq_R_find

                    val coq_R_find_rect :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                      'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                      'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find ->
                      'a2 -> 'a2) -> 'a1 t -> 'a1 option -> 'a1 coq_R_find ->
                      'a2

                    val coq_R_find_rec :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                      'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                      'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find ->
                      'a2 -> 'a2) -> 'a1 t -> 'a1 option -> 'a1 coq_R_find ->
                      'a2

                    val find_rect :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                      'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                      'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val find_rec :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                      'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                      'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val coq_R_find_correct :
                      key -> 'a1 t -> 'a1 option -> 'a1 coq_R_find

                    val add : key -> 'a1 -> 'a1 t -> 'a1 t

                    type 'elt coq_R_add =
                    | R_add_0 of 'elt t
                    | R_add_1 of 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list
                    | R_add_2 of 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list
                    | R_add_3 of 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list * 'elt t * 'elt coq_R_add

                    val coq_R_add_rect :
                      key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
                      __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_add -> 'a2 ->
                      'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_add -> 'a2

                    val coq_R_add_rec :
                      key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
                      __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_add -> 'a2 ->
                      'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_add -> 'a2

                    val add_rect :
                      key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
                      __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val add_rec :
                      key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
                      __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val coq_R_add_correct :
                      key -> 'a1 -> 'a1 t -> 'a1 t -> 'a1 coq_R_add

                    val remove : key -> 'a1 t -> 'a1 t

                    type 'elt coq_R_remove =
                    | R_remove_0 of 'elt t
                    | R_remove_1 of 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list
                    | R_remove_2 of 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list
                    | R_remove_3 of 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list * 'elt t * 'elt coq_R_remove

                    val coq_R_remove_rect :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                      'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                      'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_remove -> 'a2
                      -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove -> 'a2

                    val coq_R_remove_rec :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                      'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                      'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_remove -> 'a2
                      -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove -> 'a2

                    val remove_rect :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                      'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                      'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val remove_rec :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                      'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                      'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val coq_R_remove_correct :
                      key -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove

                    val elements : 'a1 t -> 'a1 t

                    val fold :
                      (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

                    type ('elt, 'a) coq_R_fold =
                    | R_fold_0 of 'elt t * 'a
                    | R_fold_1 of 'elt t * 'a * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list * 'a * ('elt, 'a) coq_R_fold

                    val coq_R_fold_rect :
                      (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ ->
                      'a3) -> ('a1 t -> 'a2 -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> 'a2 -> ('a1, 'a2)
                      coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a2 ->
                      ('a1, 'a2) coq_R_fold -> 'a3

                    val coq_R_fold_rec :
                      (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ ->
                      'a3) -> ('a1 t -> 'a2 -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> 'a2 -> ('a1, 'a2)
                      coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a2 ->
                      ('a1, 'a2) coq_R_fold -> 'a3

                    val fold_rect :
                      (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ ->
                      'a3) -> ('a1 t -> 'a2 -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> 'a3 -> 'a3) -> 'a1 t
                      -> 'a2 -> 'a3

                    val fold_rec :
                      (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ ->
                      'a3) -> ('a1 t -> 'a2 -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> 'a3 -> 'a3) -> 'a1 t
                      -> 'a2 -> 'a3

                    val coq_R_fold_correct :
                      (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2 ->
                      ('a1, 'a2) coq_R_fold

                    val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool

                    type 'elt coq_R_equal =
                    | R_equal_0 of 'elt t * 'elt t
                    | R_equal_1 of 'elt t * 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list * bool * 'elt coq_R_equal
                    | R_equal_2 of 'elt t * 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list * T_as_UCT.t compare0
                    | R_equal_3 of 'elt t * 'elt t * 'elt t * 'elt t

                    val coq_R_equal_rect :
                      ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                      'a2) -> ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> bool ->
                      'a1 coq_R_equal -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t ->
                      T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
                      T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
                      T_as_UCT.t compare0 -> __ -> __ -> 'a2) -> ('a1 t ->
                      'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2) ->
                      'a1 t -> 'a1 t -> bool -> 'a1 coq_R_equal -> 'a2

                    val coq_R_equal_rec :
                      ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                      'a2) -> ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> bool ->
                      'a1 coq_R_equal -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t ->
                      T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
                      T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
                      T_as_UCT.t compare0 -> __ -> __ -> 'a2) -> ('a1 t ->
                      'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2) ->
                      'a1 t -> 'a1 t -> bool -> 'a1 coq_R_equal -> 'a2

                    val equal_rect :
                      ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                      'a2) -> ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
                      'a2) -> ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t compare0 ->
                      __ -> __ -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ ->
                      'a1 t -> __ -> __ -> 'a2) -> 'a1 t -> 'a1 t -> 'a2

                    val equal_rec :
                      ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                      'a2) -> ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
                      'a2) -> ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t compare0 ->
                      __ -> __ -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ ->
                      'a1 t -> __ -> __ -> 'a2) -> 'a1 t -> 'a1 t -> 'a2

                    val coq_R_equal_correct :
                      ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool -> 'a1
                      coq_R_equal

                    val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

                    val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

                    val option_cons :
                      key -> 'a1 option -> (key * 'a1) list -> (key * 'a1)
                      list

                    val map2_l :
                      ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t ->
                      'a3 t

                    val map2_r :
                      ('a1 option -> 'a2 option -> 'a3 option) -> 'a2 t ->
                      'a3 t

                    val map2 :
                      ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t ->
                      'a2 t -> 'a3 t

                    val combine :
                      'a1 t -> 'a2 t -> ('a1 option * 'a2 option) t

                    val fold_right_pair :
                      ('a1 -> 'a2 -> 'a3 -> 'a3) -> ('a1 * 'a2) list -> 'a3
                      -> 'a3

                    val map2_alt :
                      ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t ->
                      'a2 t -> (key * 'a3) list

                    val at_least_one :
                      'a1 option -> 'a2 option -> ('a1 option * 'a2 option)
                      option

                    val at_least_one_then_f :
                      ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 option
                      -> 'a2 option -> 'a3 option
                   end

                  type 'elt coq_R_mem =
                  | R_mem_0 of 'elt tree
                  | R_mem_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                     * Z_as_Int.t * bool * 'elt coq_R_mem
                  | R_mem_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                     * Z_as_Int.t
                  | R_mem_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                     * Z_as_Int.t * bool * 'elt coq_R_mem

                  val coq_R_mem_rect :
                    T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key
                    -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
                    bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 tree -> bool
                    -> 'a1 coq_R_mem -> 'a2

                  val coq_R_mem_rec :
                    T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key
                    -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
                    bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 tree -> bool
                    -> 'a1 coq_R_mem -> 'a2

                  type 'elt coq_R_find =
                  | R_find_0 of 'elt tree
                  | R_find_1 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'elt option * 'elt coq_R_find
                  | R_find_2 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t
                  | R_find_3 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'elt option * 'elt coq_R_find

                  val coq_R_find_rect :
                    T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) ->
                    ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) ->
                    'a1 tree -> 'a1 option -> 'a1 coq_R_find -> 'a2

                  val coq_R_find_rec :
                    T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) ->
                    ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) ->
                    'a1 tree -> 'a1 option -> 'a1 coq_R_find -> 'a2

                  type 'elt coq_R_bal =
                  | R_bal_0 of 'elt tree * key * 'elt * 'elt tree
                  | R_bal_1 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                     * key * 'elt * 'elt tree * Z_as_Int.t
                  | R_bal_2 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                     * key * 'elt * 'elt tree * Z_as_Int.t
                  | R_bal_3 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                     * key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t
                  | R_bal_4 of 'elt tree * key * 'elt * 'elt tree
                  | R_bal_5 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                     * key * 'elt * 'elt tree * Z_as_Int.t
                  | R_bal_6 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                     * key * 'elt * 'elt tree * Z_as_Int.t
                  | R_bal_7 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                     * key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t
                  | R_bal_8 of 'elt tree * key * 'elt * 'elt tree

                  val coq_R_bal_rect :
                    ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ ->
                    'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
                    -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                    -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1
                    tree -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree
                    -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key
                    -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
                    -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 ->
                    'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key ->
                    'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2)
                    -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __
                    -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key ->
                    'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree ->
                    key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
                    'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
                    -> __ -> __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree
                    -> 'a1 tree -> 'a1 coq_R_bal -> 'a2

                  val coq_R_bal_rec :
                    ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ ->
                    'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
                    -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                    -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1
                    tree -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree
                    -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key
                    -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
                    -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 ->
                    'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key ->
                    'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2)
                    -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __
                    -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key ->
                    'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree ->
                    key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
                    'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
                    -> __ -> __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree
                    -> 'a1 tree -> 'a1 coq_R_bal -> 'a2

                  type 'elt coq_R_add =
                  | R_add_0 of 'elt tree
                  | R_add_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                     * Z_as_Int.t * 'elt tree * 'elt coq_R_add
                  | R_add_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                     * Z_as_Int.t
                  | R_add_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                     * Z_as_Int.t * 'elt tree * 'elt coq_R_add

                  val coq_R_add_rect :
                    key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key
                    -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
                    tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 tree -> 'a1
                    tree -> 'a1 coq_R_add -> 'a2

                  val coq_R_add_rec :
                    key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key
                    -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
                    tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 tree -> 'a1
                    tree -> 'a1 coq_R_add -> 'a2

                  type 'elt coq_R_remove_min =
                  | R_remove_min_0 of 'elt tree * key * 'elt * 'elt tree
                  | R_remove_min_1 of 'elt tree * key * 'elt * 'elt tree
                     * 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t
                     * ('elt tree * (key * 'elt)) * 'elt coq_R_remove_min
                     * 'elt tree * (key * 'elt)

                  val coq_R_remove_min_rect :
                    ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1
                    tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1
                    -> 'a1 tree -> Z_as_Int.t -> __ -> ('a1
                    tree * (key * 'a1)) -> 'a1 coq_R_remove_min -> 'a2 -> 'a1
                    tree -> (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> key ->
                    'a1 -> 'a1 tree -> ('a1 tree * (key * 'a1)) -> 'a1
                    coq_R_remove_min -> 'a2

                  val coq_R_remove_min_rec :
                    ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1
                    tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1
                    -> 'a1 tree -> Z_as_Int.t -> __ -> ('a1
                    tree * (key * 'a1)) -> 'a1 coq_R_remove_min -> 'a2 -> 'a1
                    tree -> (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> key ->
                    'a1 -> 'a1 tree -> ('a1 tree * (key * 'a1)) -> 'a1
                    coq_R_remove_min -> 'a2

                  type 'elt coq_R_merge =
                  | R_merge_0 of 'elt tree * 'elt tree
                  | R_merge_1 of 'elt tree * 'elt tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t
                  | R_merge_2 of 'elt tree * 'elt tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree
                     * (key * 'elt) * key * 'elt

                  val coq_R_merge_rect :
                    ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> (key * 'a1) -> __ -> key -> 'a1 -> __ -> 'a2) -> 'a1
                    tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_merge -> 'a2

                  val coq_R_merge_rec :
                    ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> (key * 'a1) -> __ -> key -> 'a1 -> __ -> 'a2) -> 'a1
                    tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_merge -> 'a2

                  type 'elt coq_R_remove =
                  | R_remove_0 of 'elt tree
                  | R_remove_1 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'elt tree * 'elt coq_R_remove
                  | R_remove_2 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t
                  | R_remove_3 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'elt tree * 'elt coq_R_remove

                  val coq_R_remove_rect :
                    T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) ->
                    ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) ->
                    'a1 tree -> 'a1 tree -> 'a1 coq_R_remove -> 'a2

                  val coq_R_remove_rec :
                    T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) ->
                    ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) ->
                    'a1 tree -> 'a1 tree -> 'a1 coq_R_remove -> 'a2

                  type 'elt coq_R_concat =
                  | R_concat_0 of 'elt tree * 'elt tree
                  | R_concat_1 of 'elt tree * 'elt tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t
                  | R_concat_2 of 'elt tree * 'elt tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree
                     * (key * 'elt)

                  val coq_R_concat_rect :
                    ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> 'a1 tree ->
                    'a1 tree -> 'a1 coq_R_concat -> 'a2

                  val coq_R_concat_rec :
                    ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> 'a1 tree ->
                    'a1 tree -> 'a1 coq_R_concat -> 'a2

                  type 'elt coq_R_split =
                  | R_split_0 of 'elt tree
                  | R_split_1 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'elt triple
                     * 'elt coq_R_split * 'elt tree * 'elt option * 'elt tree
                  | R_split_2 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t
                  | R_split_3 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'elt triple
                     * 'elt coq_R_split * 'elt tree * 'elt option * 'elt tree

                  val coq_R_split_rect :
                    T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree
                    -> 'a1 option -> 'a1 tree -> __ -> 'a2) -> ('a1 tree ->
                    'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
                    -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 triple
                    -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option ->
                    'a1 tree -> __ -> 'a2) -> 'a1 tree -> 'a1 triple -> 'a1
                    coq_R_split -> 'a2

                  val coq_R_split_rec :
                    T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree
                    -> 'a1 option -> 'a1 tree -> __ -> 'a2) -> ('a1 tree ->
                    'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
                    -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 triple
                    -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option ->
                    'a1 tree -> __ -> 'a2) -> 'a1 tree -> 'a1 triple -> 'a1
                    coq_R_split -> 'a2

                  type ('elt, 'x) coq_R_map_option =
                  | R_map_option_0 of 'elt tree
                  | R_map_option_1 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'x * 'x tree
                     * ('elt, 'x) coq_R_map_option * 'x tree
                     * ('elt, 'x) coq_R_map_option
                  | R_map_option_2 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'x tree
                     * ('elt, 'x) coq_R_map_option * 'x tree
                     * ('elt, 'x) coq_R_map_option

                  val coq_R_map_option_rect :
                    (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) ->
                    ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> 'a2 -> __ -> 'a2 tree -> ('a1, 'a2)
                    coq_R_map_option -> 'a3 -> 'a2 tree -> ('a1, 'a2)
                    coq_R_map_option -> 'a3 -> 'a3) -> ('a1 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                    'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2
                    tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> 'a1
                    tree -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3

                  val coq_R_map_option_rec :
                    (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) ->
                    ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> 'a2 -> __ -> 'a2 tree -> ('a1, 'a2)
                    coq_R_map_option -> 'a3 -> 'a2 tree -> ('a1, 'a2)
                    coq_R_map_option -> 'a3 -> 'a3) -> ('a1 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                    'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2
                    tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> 'a1
                    tree -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3

                  type ('elt, 'x0, 'x) coq_R_map2_opt =
                  | R_map2_opt_0 of 'elt tree * 'x0 tree
                  | R_map2_opt_1 of 'elt tree * 'x0 tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t
                  | R_map2_opt_2 of 'elt tree * 'x0 tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t * 'x0 tree * 
                     key * 'x0 * 'x0 tree * Z_as_Int.t * 'x0 tree
                     * 'x0 option * 'x0 tree * 'x * 'x tree
                     * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
                     * ('elt, 'x0, 'x) coq_R_map2_opt
                  | R_map2_opt_3 of 'elt tree * 'x0 tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t * 'x0 tree * 
                     key * 'x0 * 'x0 tree * Z_as_Int.t * 'x0 tree
                     * 'x0 option * 'x0 tree * 'x tree
                     * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
                     * ('elt, 'x0, 'x) coq_R_map2_opt

                  val coq_R_map2_opt_rect :
                    (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree ->
                    'a3 tree) -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2
                    tree -> __ -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                    'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1
                    -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 tree -> key -> 'a2
                    -> 'a2 tree -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2 option
                    -> 'a2 tree -> __ -> 'a3 -> __ -> 'a3 tree -> ('a1, 'a2,
                    'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
                    coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree ->
                    'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    'a2 tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ ->
                    'a2 tree -> 'a2 option -> 'a2 tree -> __ -> __ -> 'a3
                    tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree
                    -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1
                    tree -> 'a2 tree -> 'a3 tree -> ('a1, 'a2, 'a3)
                    coq_R_map2_opt -> 'a4

                  val coq_R_map2_opt_rec :
                    (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree ->
                    'a3 tree) -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2
                    tree -> __ -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                    'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1
                    -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 tree -> key -> 'a2
                    -> 'a2 tree -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2 option
                    -> 'a2 tree -> __ -> 'a3 -> __ -> 'a3 tree -> ('a1, 'a2,
                    'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
                    coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree ->
                    'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    'a2 tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ ->
                    'a2 tree -> 'a2 option -> 'a2 tree -> __ -> __ -> 'a3
                    tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree
                    -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1
                    tree -> 'a2 tree -> 'a3 tree -> ('a1, 'a2, 'a3)
                    coq_R_map2_opt -> 'a4

                  val fold' :
                    (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

                  val flatten_e : 'a1 enumeration -> (key * 'a1) list
                 end
               end

              type 'elt bst =
                'elt Raw.tree
                (* singleton inductive, whose constructor was Bst *)

              val this : 'a1 bst -> 'a1 Raw.tree

              type 'elt t = 'elt bst

              type key = T_as_UCT.t

              val empty : 'a1 t

              val is_empty : 'a1 t -> bool

              val add : key -> 'a1 -> 'a1 t -> 'a1 t

              val remove : key -> 'a1 t -> 'a1 t

              val mem : key -> 'a1 t -> bool

              val find : key -> 'a1 t -> 'a1 option

              val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

              val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

              val map2 :
                ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t ->
                'a3 t

              val elements : 'a1 t -> (key * 'a1) list

              val cardinal : 'a1 t -> nat

              val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

              val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool
             end

            module SigFMF :
             sig
              val eqb : T_as_UCT.t -> T_as_UCT.t -> bool

              val coq_In_dec : 'a1 SigFM.t -> SigFM.key -> bool
             end

            module Strings :
             sig
              type coq_String = Ty.coq_Sigma list

              val coq_String_dec : coq_String -> coq_String -> bool

              val rm_empty : coq_String list -> Ty.coq_Sigma list list
             end

            module Regexes :
             sig
              type regex =
              | EmptySet
              | EmptyStr
              | Char of Ty.coq_Sigma
              | App of regex * regex
              | Union of regex * regex
              | Star of regex

              val regex_rect :
                'a1 -> 'a1 -> (Ty.coq_Sigma -> 'a1) -> (regex -> 'a1 -> regex
                -> 'a1 -> 'a1) -> (regex -> 'a1 -> regex -> 'a1 -> 'a1) ->
                (regex -> 'a1 -> 'a1) -> regex -> 'a1

              val regex_rec :
                'a1 -> 'a1 -> (Ty.coq_Sigma -> 'a1) -> (regex -> 'a1 -> regex
                -> 'a1 -> 'a1) -> (regex -> 'a1 -> regex -> 'a1 -> 'a1) ->
                (regex -> 'a1 -> 'a1) -> regex -> 'a1

              val regex_dec : regex -> regex -> bool

              val regex_eq : regex -> regex -> bool

              val nullable' : regex -> bool

              val nullable : regex -> bool

              val derivative : Ty.coq_Sigma -> regex -> regex

              val derivative_list : Ty.coq_Sigma list -> regex -> regex

              val re_compare : regex -> regex -> comparison
             end

            module Coq_regex_as_UCT :
             sig
              type t = Regexes.regex

              val compare : Regexes.regex -> Regexes.regex -> comparison
             end

            module Coq_regex_as_UOT :
             sig
              type t = Coq_regex_as_UCT.t

              val compare : t -> t -> t compare0

              val eq_dec : t -> t -> bool
             end

            module Coq_reFS :
             sig
              module X' :
               sig
                type t = Coq_regex_as_UCT.t

                val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                val compare :
                  Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> comparison
               end

              module MSet :
               sig
                module Raw :
                 sig
                  type elt = Coq_regex_as_UCT.t

                  type tree =
                  | Leaf
                  | Node of Z_as_Int.t * tree * Coq_regex_as_UCT.t * tree

                  val empty : tree

                  val is_empty : tree -> bool

                  val mem : Coq_regex_as_UCT.t -> tree -> bool

                  val min_elt : tree -> elt option

                  val max_elt : tree -> elt option

                  val choose : tree -> elt option

                  val fold : (elt -> 'a1 -> 'a1) -> tree -> 'a1 -> 'a1

                  val elements_aux :
                    Coq_regex_as_UCT.t list -> tree -> Coq_regex_as_UCT.t list

                  val elements : tree -> Coq_regex_as_UCT.t list

                  val rev_elements_aux :
                    Coq_regex_as_UCT.t list -> tree -> Coq_regex_as_UCT.t list

                  val rev_elements : tree -> Coq_regex_as_UCT.t list

                  val cardinal : tree -> nat

                  val maxdepth : tree -> nat

                  val mindepth : tree -> nat

                  val for_all : (elt -> bool) -> tree -> bool

                  val exists_ : (elt -> bool) -> tree -> bool

                  type enumeration =
                  | End
                  | More of elt * tree * enumeration

                  val cons : tree -> enumeration -> enumeration

                  val compare_more :
                    Coq_regex_as_UCT.t -> (enumeration -> comparison) ->
                    enumeration -> comparison

                  val compare_cont :
                    tree -> (enumeration -> comparison) -> enumeration ->
                    comparison

                  val compare_end : enumeration -> comparison

                  val compare : tree -> tree -> comparison

                  val equal : tree -> tree -> bool

                  val subsetl :
                    (tree -> bool) -> Coq_regex_as_UCT.t -> tree -> bool

                  val subsetr :
                    (tree -> bool) -> Coq_regex_as_UCT.t -> tree -> bool

                  val subset : tree -> tree -> bool

                  type t = tree

                  val height : t -> Z_as_Int.t

                  val singleton : Coq_regex_as_UCT.t -> tree

                  val create : t -> Coq_regex_as_UCT.t -> t -> tree

                  val assert_false : t -> Coq_regex_as_UCT.t -> t -> tree

                  val bal : t -> Coq_regex_as_UCT.t -> t -> tree

                  val add : Coq_regex_as_UCT.t -> tree -> tree

                  val join : tree -> elt -> t -> t

                  val remove_min : tree -> elt -> t -> t * elt

                  val merge : tree -> tree -> tree

                  val remove : Coq_regex_as_UCT.t -> tree -> tree

                  val concat : tree -> tree -> tree

                  type triple = { t_left : t; t_in : bool; t_right : t }

                  val t_left : triple -> t

                  val t_in : triple -> bool

                  val t_right : triple -> t

                  val split : Coq_regex_as_UCT.t -> tree -> triple

                  val inter : tree -> tree -> tree

                  val diff : tree -> tree -> tree

                  val union : tree -> tree -> tree

                  val filter : (elt -> bool) -> tree -> tree

                  val partition : (elt -> bool) -> t -> t * t

                  val ltb_tree : Coq_regex_as_UCT.t -> tree -> bool

                  val gtb_tree : Coq_regex_as_UCT.t -> tree -> bool

                  val isok : tree -> bool

                  module MX :
                   sig
                    module OrderTac :
                     sig
                      module OTF :
                       sig
                        type t = Coq_regex_as_UCT.t

                        val compare :
                          Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t ->
                          comparison

                        val eq_dec :
                          Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                       end

                      module TO :
                       sig
                        type t = Coq_regex_as_UCT.t

                        val compare :
                          Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t ->
                          comparison

                        val eq_dec :
                          Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                       end
                     end

                    val eq_dec :
                      Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                    val lt_dec :
                      Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                    val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                   end

                  type coq_R_min_elt =
                  | R_min_elt_0 of tree
                  | R_min_elt_1 of tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree
                  | R_min_elt_2 of tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * elt option * coq_R_min_elt

                  type coq_R_max_elt =
                  | R_max_elt_0 of tree
                  | R_max_elt_1 of tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree
                  | R_max_elt_2 of tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * elt option * coq_R_max_elt

                  module L :
                   sig
                    module MO :
                     sig
                      module OrderTac :
                       sig
                        module OTF :
                         sig
                          type t = Coq_regex_as_UCT.t

                          val compare :
                            Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t ->
                            comparison

                          val eq_dec :
                            Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                         end

                        module TO :
                         sig
                          type t = Coq_regex_as_UCT.t

                          val compare :
                            Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t ->
                            comparison

                          val eq_dec :
                            Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                         end
                       end

                      val eq_dec :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                      val lt_dec :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                      val eqb :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                     end
                   end

                  val flatten_e : enumeration -> elt list

                  type coq_R_bal =
                  | R_bal_0 of t * Coq_regex_as_UCT.t * t
                  | R_bal_1 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * 
                     tree * Coq_regex_as_UCT.t * tree
                  | R_bal_2 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * 
                     tree * Coq_regex_as_UCT.t * tree
                  | R_bal_3 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * 
                     tree * Coq_regex_as_UCT.t * tree * Z_as_Int.t * 
                     tree * Coq_regex_as_UCT.t * tree
                  | R_bal_4 of t * Coq_regex_as_UCT.t * t
                  | R_bal_5 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * 
                     tree * Coq_regex_as_UCT.t * tree
                  | R_bal_6 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * 
                     tree * Coq_regex_as_UCT.t * tree
                  | R_bal_7 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * 
                     tree * Coq_regex_as_UCT.t * tree * Z_as_Int.t * 
                     tree * Coq_regex_as_UCT.t * tree
                  | R_bal_8 of t * Coq_regex_as_UCT.t * t

                  type coq_R_remove_min =
                  | R_remove_min_0 of tree * elt * t
                  | R_remove_min_1 of tree * elt * t * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * (t * elt)
                     * coq_R_remove_min * t * elt

                  type coq_R_merge =
                  | R_merge_0 of tree * tree
                  | R_merge_1 of tree * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree
                  | R_merge_2 of tree * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * t * elt

                  type coq_R_concat =
                  | R_concat_0 of tree * tree
                  | R_concat_1 of tree * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree
                  | R_concat_2 of tree * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * t * elt

                  type coq_R_inter =
                  | R_inter_0 of tree * tree
                  | R_inter_1 of tree * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree
                  | R_inter_2 of tree * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * t * bool * t * tree
                     * coq_R_inter * tree * coq_R_inter
                  | R_inter_3 of tree * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * t * bool * t * tree
                     * coq_R_inter * tree * coq_R_inter

                  type coq_R_diff =
                  | R_diff_0 of tree * tree
                  | R_diff_1 of tree * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree
                  | R_diff_2 of tree * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * t * bool * t * tree
                     * coq_R_diff * tree * coq_R_diff
                  | R_diff_3 of tree * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * t * bool * t * tree
                     * coq_R_diff * tree * coq_R_diff

                  type coq_R_union =
                  | R_union_0 of tree * tree
                  | R_union_1 of tree * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree
                  | R_union_2 of tree * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * t * bool * t * tree
                     * coq_R_union * tree * coq_R_union
                 end

                module E :
                 sig
                  type t = Coq_regex_as_UCT.t

                  val compare :
                    Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> comparison

                  val eq_dec :
                    Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                 end

                type elt = Coq_regex_as_UCT.t

                type t_ =
                  Raw.t
                  (* singleton inductive, whose constructor was Mkt *)

                val this : t_ -> Raw.t

                type t = t_

                val mem : elt -> t -> bool

                val add : elt -> t -> t

                val remove : elt -> t -> t

                val singleton : elt -> t

                val union : t -> t -> t

                val inter : t -> t -> t

                val diff : t -> t -> t

                val equal : t -> t -> bool

                val subset : t -> t -> bool

                val empty : t

                val is_empty : t -> bool

                val elements : t -> elt list

                val choose : t -> elt option

                val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

                val cardinal : t -> nat

                val filter : (elt -> bool) -> t -> t

                val for_all : (elt -> bool) -> t -> bool

                val exists_ : (elt -> bool) -> t -> bool

                val partition : (elt -> bool) -> t -> t * t

                val eq_dec : t -> t -> bool

                val compare : t -> t -> comparison

                val min_elt : t -> elt option

                val max_elt : t -> elt option
               end

              type elt = Coq_regex_as_UCT.t

              type t = MSet.t

              val empty : t

              val is_empty : t -> bool

              val mem : elt -> t -> bool

              val add : elt -> t -> t

              val singleton : elt -> t

              val remove : elt -> t -> t

              val union : t -> t -> t

              val inter : t -> t -> t

              val diff : t -> t -> t

              val eq_dec : t -> t -> bool

              val equal : t -> t -> bool

              val subset : t -> t -> bool

              val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

              val for_all : (elt -> bool) -> t -> bool

              val exists_ : (elt -> bool) -> t -> bool

              val filter : (elt -> bool) -> t -> t

              val partition : (elt -> bool) -> t -> t * t

              val cardinal : t -> nat

              val elements : t -> elt list

              val choose : t -> elt option

              module MF :
               sig
                val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
               end

              val min_elt : t -> elt option

              val max_elt : t -> elt option

              val compare : t -> t -> t compare0

              module E :
               sig
                type t = Coq_regex_as_UCT.t

                val compare :
                  Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t ->
                  Coq_regex_as_UCT.t compare0

                val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
               end
             end

            module Coq_reFSF :
             sig
              val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
             end

            module Coq_reFM :
             sig
              module E :
               sig
                type t = Coq_regex_as_UCT.t

                val compare :
                  Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t ->
                  Coq_regex_as_UCT.t compare0

                val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
               end

              module Raw :
               sig
                type key = Coq_regex_as_UCT.t

                type 'elt tree =
                | Leaf
                | Node of 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t

                val tree_rect :
                  'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
                  Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

                val tree_rec :
                  'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
                  Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

                val height : 'a1 tree -> Z_as_Int.t

                val cardinal : 'a1 tree -> nat

                val empty : 'a1 tree

                val is_empty : 'a1 tree -> bool

                val mem : Coq_regex_as_UCT.t -> 'a1 tree -> bool

                val find : Coq_regex_as_UCT.t -> 'a1 tree -> 'a1 option

                val create : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

                val assert_false :
                  'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

                val bal : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

                val add : key -> 'a1 -> 'a1 tree -> 'a1 tree

                val remove_min :
                  'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree * (key * 'a1)

                val merge : 'a1 tree -> 'a1 tree -> 'a1 tree

                val remove : Coq_regex_as_UCT.t -> 'a1 tree -> 'a1 tree

                val join : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

                type 'elt triple = { t_left : 'elt tree; t_opt : 'elt option;
                                     t_right : 'elt tree }

                val t_left : 'a1 triple -> 'a1 tree

                val t_opt : 'a1 triple -> 'a1 option

                val t_right : 'a1 triple -> 'a1 tree

                val split : Coq_regex_as_UCT.t -> 'a1 tree -> 'a1 triple

                val concat : 'a1 tree -> 'a1 tree -> 'a1 tree

                val elements_aux :
                  (key * 'a1) list -> 'a1 tree -> (key * 'a1) list

                val elements : 'a1 tree -> (key * 'a1) list

                val fold :
                  (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

                type 'elt enumeration =
                | End
                | More of key * 'elt * 'elt tree * 'elt enumeration

                val enumeration_rect :
                  'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 ->
                  'a2) -> 'a1 enumeration -> 'a2

                val enumeration_rec :
                  'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 ->
                  'a2) -> 'a1 enumeration -> 'a2

                val cons : 'a1 tree -> 'a1 enumeration -> 'a1 enumeration

                val equal_more :
                  ('a1 -> 'a1 -> bool) -> Coq_regex_as_UCT.t -> 'a1 -> ('a1
                  enumeration -> bool) -> 'a1 enumeration -> bool

                val equal_cont :
                  ('a1 -> 'a1 -> bool) -> 'a1 tree -> ('a1 enumeration ->
                  bool) -> 'a1 enumeration -> bool

                val equal_end : 'a1 enumeration -> bool

                val equal :
                  ('a1 -> 'a1 -> bool) -> 'a1 tree -> 'a1 tree -> bool

                val map : ('a1 -> 'a2) -> 'a1 tree -> 'a2 tree

                val mapi : (key -> 'a1 -> 'a2) -> 'a1 tree -> 'a2 tree

                val map_option :
                  (key -> 'a1 -> 'a2 option) -> 'a1 tree -> 'a2 tree

                val map2_opt :
                  (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree ->
                  'a3 tree) -> ('a2 tree -> 'a3 tree) -> 'a1 tree -> 'a2 tree
                  -> 'a3 tree

                val map2 :
                  ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 tree -> 'a2
                  tree -> 'a3 tree

                module Proofs :
                 sig
                  module MX :
                   sig
                    module TO :
                     sig
                      type t = Coq_regex_as_UCT.t
                     end

                    module IsTO :
                     sig
                     end

                    module OrderTac :
                     sig
                     end

                    val eq_dec :
                      Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                    val lt_dec :
                      Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                    val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                   end

                  module PX :
                   sig
                    module MO :
                     sig
                      module TO :
                       sig
                        type t = Coq_regex_as_UCT.t
                       end

                      module IsTO :
                       sig
                       end

                      module OrderTac :
                       sig
                       end

                      val eq_dec :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                      val lt_dec :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                      val eqb :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                     end
                   end

                  module L :
                   sig
                    module MX :
                     sig
                      module TO :
                       sig
                        type t = Coq_regex_as_UCT.t
                       end

                      module IsTO :
                       sig
                       end

                      module OrderTac :
                       sig
                       end

                      val eq_dec :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                      val lt_dec :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                      val eqb :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                     end

                    module PX :
                     sig
                      module MO :
                       sig
                        module TO :
                         sig
                          type t = Coq_regex_as_UCT.t
                         end

                        module IsTO :
                         sig
                         end

                        module OrderTac :
                         sig
                         end

                        val eq_dec :
                          Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                        val lt_dec :
                          Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                        val eqb :
                          Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                       end
                     end

                    type key = Coq_regex_as_UCT.t

                    type 'elt t = (Coq_regex_as_UCT.t * 'elt) list

                    val empty : 'a1 t

                    val is_empty : 'a1 t -> bool

                    val mem : key -> 'a1 t -> bool

                    type 'elt coq_R_mem =
                    | R_mem_0 of 'elt t
                    | R_mem_1 of 'elt t * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list
                    | R_mem_2 of 'elt t * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list
                    | R_mem_3 of 'elt t * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list * bool
                       * 'elt coq_R_mem

                    val coq_R_mem_rect :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2
                      -> 'a2) -> 'a1 t -> bool -> 'a1 coq_R_mem -> 'a2

                    val coq_R_mem_rec :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2
                      -> 'a2) -> 'a1 t -> bool -> 'a1 coq_R_mem -> 'a2

                    val mem_rect :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val mem_rec :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val coq_R_mem_correct :
                      key -> 'a1 t -> bool -> 'a1 coq_R_mem

                    val find : key -> 'a1 t -> 'a1 option

                    type 'elt coq_R_find =
                    | R_find_0 of 'elt t
                    | R_find_1 of 'elt t * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list
                    | R_find_2 of 'elt t * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list
                    | R_find_3 of 'elt t * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list * 'elt option
                       * 'elt coq_R_find

                    val coq_R_find_rect :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find
                      -> 'a2 -> 'a2) -> 'a1 t -> 'a1 option -> 'a1 coq_R_find
                      -> 'a2

                    val coq_R_find_rec :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find
                      -> 'a2 -> 'a2) -> 'a1 t -> 'a1 option -> 'a1 coq_R_find
                      -> 'a2

                    val find_rect :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val find_rec :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val coq_R_find_correct :
                      key -> 'a1 t -> 'a1 option -> 'a1 coq_R_find

                    val add : key -> 'a1 -> 'a1 t -> 'a1 t

                    type 'elt coq_R_add =
                    | R_add_0 of 'elt t
                    | R_add_1 of 'elt t * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list
                    | R_add_2 of 'elt t * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list
                    | R_add_3 of 'elt t * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list * 'elt t
                       * 'elt coq_R_add

                    val coq_R_add_rect :
                      key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_add -> 'a2
                      -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_add -> 'a2

                    val coq_R_add_rec :
                      key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_add -> 'a2
                      -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_add -> 'a2

                    val add_rect :
                      key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val add_rec :
                      key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val coq_R_add_correct :
                      key -> 'a1 -> 'a1 t -> 'a1 t -> 'a1 coq_R_add

                    val remove : key -> 'a1 t -> 'a1 t

                    type 'elt coq_R_remove =
                    | R_remove_0 of 'elt t
                    | R_remove_1 of 'elt t * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list
                    | R_remove_2 of 'elt t * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list
                    | R_remove_3 of 'elt t * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list * 'elt t
                       * 'elt coq_R_remove

                    val coq_R_remove_rect :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_remove ->
                      'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove -> 'a2

                    val coq_R_remove_rec :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_remove ->
                      'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove -> 'a2

                    val remove_rect :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val remove_rec :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val coq_R_remove_correct :
                      key -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove

                    val elements : 'a1 t -> 'a1 t

                    val fold :
                      (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

                    type ('elt, 'a) coq_R_fold =
                    | R_fold_0 of 'elt t * 'a
                    | R_fold_1 of 'elt t * 'a * Coq_regex_as_UCT.t * 
                       'elt * (Coq_regex_as_UCT.t * 'elt) list * 'a
                       * ('elt, 'a) coq_R_fold

                    val coq_R_fold_rect :
                      (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ ->
                      'a3) -> ('a1 t -> 'a2 -> Coq_regex_as_UCT.t -> 'a1 ->
                      (Coq_regex_as_UCT.t * 'a1) list -> __ -> 'a2 -> ('a1,
                      'a2) coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a2
                      -> ('a1, 'a2) coq_R_fold -> 'a3

                    val coq_R_fold_rec :
                      (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ ->
                      'a3) -> ('a1 t -> 'a2 -> Coq_regex_as_UCT.t -> 'a1 ->
                      (Coq_regex_as_UCT.t * 'a1) list -> __ -> 'a2 -> ('a1,
                      'a2) coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a2
                      -> ('a1, 'a2) coq_R_fold -> 'a3

                    val fold_rect :
                      (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ ->
                      'a3) -> ('a1 t -> 'a2 -> Coq_regex_as_UCT.t -> 'a1 ->
                      (Coq_regex_as_UCT.t * 'a1) list -> __ -> 'a3 -> 'a3) ->
                      'a1 t -> 'a2 -> 'a3

                    val fold_rec :
                      (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ ->
                      'a3) -> ('a1 t -> 'a2 -> Coq_regex_as_UCT.t -> 'a1 ->
                      (Coq_regex_as_UCT.t * 'a1) list -> __ -> 'a3 -> 'a3) ->
                      'a1 t -> 'a2 -> 'a3

                    val coq_R_fold_correct :
                      (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2 ->
                      ('a1, 'a2) coq_R_fold

                    val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool

                    type 'elt coq_R_equal =
                    | R_equal_0 of 'elt t * 'elt t
                    | R_equal_1 of 'elt t * 'elt t * Coq_regex_as_UCT.t
                       * 'elt * (Coq_regex_as_UCT.t * 'elt) list
                       * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list * bool
                       * 'elt coq_R_equal
                    | R_equal_2 of 'elt t * 'elt t * Coq_regex_as_UCT.t
                       * 'elt * (Coq_regex_as_UCT.t * 'elt) list
                       * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list
                       * Coq_regex_as_UCT.t compare0
                    | R_equal_3 of 'elt t * 'elt t * 'elt t * 'elt t

                    val coq_R_equal_rect :
                      ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                      'a2) -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                      (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> bool -> 'a1 coq_R_equal ->
                      'a2 -> 'a2) -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t ->
                      'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> Coq_regex_as_UCT.t compare0 -> __ -> __
                      -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t ->
                      __ -> __ -> 'a2) -> 'a1 t -> 'a1 t -> bool -> 'a1
                      coq_R_equal -> 'a2

                    val coq_R_equal_rec :
                      ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                      'a2) -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                      (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> bool -> 'a1 coq_R_equal ->
                      'a2 -> 'a2) -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t ->
                      'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> Coq_regex_as_UCT.t compare0 -> __ -> __
                      -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t ->
                      __ -> __ -> 'a2) -> 'a1 t -> 'a1 t -> bool -> 'a1
                      coq_R_equal -> 'a2

                    val equal_rect :
                      ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                      'a2) -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                      (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2 -> 'a2) -> ('a1 t -> 'a1
                      t -> Coq_regex_as_UCT.t -> 'a1 ->
                      (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> Coq_regex_as_UCT.t compare0 -> __ -> __
                      -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t ->
                      __ -> __ -> 'a2) -> 'a1 t -> 'a1 t -> 'a2

                    val equal_rec :
                      ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                      'a2) -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                      (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2 -> 'a2) -> ('a1 t -> 'a1
                      t -> Coq_regex_as_UCT.t -> 'a1 ->
                      (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> Coq_regex_as_UCT.t compare0 -> __ -> __
                      -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t ->
                      __ -> __ -> 'a2) -> 'a1 t -> 'a1 t -> 'a2

                    val coq_R_equal_correct :
                      ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool -> 'a1
                      coq_R_equal

                    val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

                    val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

                    val option_cons :
                      key -> 'a1 option -> (key * 'a1) list -> (key * 'a1)
                      list

                    val map2_l :
                      ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t ->
                      'a3 t

                    val map2_r :
                      ('a1 option -> 'a2 option -> 'a3 option) -> 'a2 t ->
                      'a3 t

                    val map2 :
                      ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t ->
                      'a2 t -> 'a3 t

                    val combine :
                      'a1 t -> 'a2 t -> ('a1 option * 'a2 option) t

                    val fold_right_pair :
                      ('a1 -> 'a2 -> 'a3 -> 'a3) -> ('a1 * 'a2) list -> 'a3
                      -> 'a3

                    val map2_alt :
                      ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t ->
                      'a2 t -> (key * 'a3) list

                    val at_least_one :
                      'a1 option -> 'a2 option -> ('a1 option * 'a2 option)
                      option

                    val at_least_one_then_f :
                      ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 option
                      -> 'a2 option -> 'a3 option
                   end

                  type 'elt coq_R_mem =
                  | R_mem_0 of 'elt tree
                  | R_mem_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                     * Z_as_Int.t * bool * 'elt coq_R_mem
                  | R_mem_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                     * Z_as_Int.t
                  | R_mem_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                     * Z_as_Int.t * bool * 'elt coq_R_mem

                  val coq_R_mem_rect :
                    Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2)
                    -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 tree
                    -> bool -> 'a1 coq_R_mem -> 'a2

                  val coq_R_mem_rec :
                    Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2)
                    -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 tree
                    -> bool -> 'a1 coq_R_mem -> 'a2

                  type 'elt coq_R_find =
                  | R_find_0 of 'elt tree
                  | R_find_1 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'elt option * 'elt coq_R_find
                  | R_find_2 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t
                  | R_find_3 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'elt option * 'elt coq_R_find

                  val coq_R_find_rect :
                    Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2
                    -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
                    tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree
                    -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                    -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 ->
                    'a2) -> 'a1 tree -> 'a1 option -> 'a1 coq_R_find -> 'a2

                  val coq_R_find_rec :
                    Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2
                    -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
                    tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree
                    -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                    -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 ->
                    'a2) -> 'a1 tree -> 'a1 option -> 'a1 coq_R_find -> 'a2

                  type 'elt coq_R_bal =
                  | R_bal_0 of 'elt tree * key * 'elt * 'elt tree
                  | R_bal_1 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                     * key * 'elt * 'elt tree * Z_as_Int.t
                  | R_bal_2 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                     * key * 'elt * 'elt tree * Z_as_Int.t
                  | R_bal_3 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                     * key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t
                  | R_bal_4 of 'elt tree * key * 'elt * 'elt tree
                  | R_bal_5 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                     * key * 'elt * 'elt tree * Z_as_Int.t
                  | R_bal_6 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                     * key * 'elt * 'elt tree * Z_as_Int.t
                  | R_bal_7 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                     * key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t
                  | R_bal_8 of 'elt tree * key * 'elt * 'elt tree

                  val coq_R_bal_rect :
                    ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ ->
                    'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
                    -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                    -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1
                    tree -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree
                    -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key
                    -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
                    -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 ->
                    'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key ->
                    'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2)
                    -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __
                    -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key ->
                    'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree ->
                    key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
                    'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
                    -> __ -> __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree
                    -> 'a1 tree -> 'a1 coq_R_bal -> 'a2

                  val coq_R_bal_rec :
                    ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ ->
                    'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
                    -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                    -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1
                    tree -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree
                    -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key
                    -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
                    -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 ->
                    'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key ->
                    'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2)
                    -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __
                    -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key ->
                    'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree ->
                    key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
                    'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
                    -> __ -> __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree
                    -> 'a1 tree -> 'a1 coq_R_bal -> 'a2

                  type 'elt coq_R_add =
                  | R_add_0 of 'elt tree
                  | R_add_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                     * Z_as_Int.t * 'elt tree * 'elt coq_R_add
                  | R_add_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                     * Z_as_Int.t
                  | R_add_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                     * Z_as_Int.t * 'elt tree * 'elt coq_R_add

                  val coq_R_add_rect :
                    key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key
                    -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
                    tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 tree -> 'a1
                    tree -> 'a1 coq_R_add -> 'a2

                  val coq_R_add_rec :
                    key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key
                    -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
                    tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 tree -> 'a1
                    tree -> 'a1 coq_R_add -> 'a2

                  type 'elt coq_R_remove_min =
                  | R_remove_min_0 of 'elt tree * key * 'elt * 'elt tree
                  | R_remove_min_1 of 'elt tree * key * 'elt * 'elt tree
                     * 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t
                     * ('elt tree * (key * 'elt)) * 'elt coq_R_remove_min
                     * 'elt tree * (key * 'elt)

                  val coq_R_remove_min_rect :
                    ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1
                    tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1
                    -> 'a1 tree -> Z_as_Int.t -> __ -> ('a1
                    tree * (key * 'a1)) -> 'a1 coq_R_remove_min -> 'a2 -> 'a1
                    tree -> (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> key ->
                    'a1 -> 'a1 tree -> ('a1 tree * (key * 'a1)) -> 'a1
                    coq_R_remove_min -> 'a2

                  val coq_R_remove_min_rec :
                    ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1
                    tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1
                    -> 'a1 tree -> Z_as_Int.t -> __ -> ('a1
                    tree * (key * 'a1)) -> 'a1 coq_R_remove_min -> 'a2 -> 'a1
                    tree -> (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> key ->
                    'a1 -> 'a1 tree -> ('a1 tree * (key * 'a1)) -> 'a1
                    coq_R_remove_min -> 'a2

                  type 'elt coq_R_merge =
                  | R_merge_0 of 'elt tree * 'elt tree
                  | R_merge_1 of 'elt tree * 'elt tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t
                  | R_merge_2 of 'elt tree * 'elt tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree
                     * (key * 'elt) * key * 'elt

                  val coq_R_merge_rect :
                    ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> (key * 'a1) -> __ -> key -> 'a1 -> __ -> 'a2) -> 'a1
                    tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_merge -> 'a2

                  val coq_R_merge_rec :
                    ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> (key * 'a1) -> __ -> key -> 'a1 -> __ -> 'a2) -> 'a1
                    tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_merge -> 'a2

                  type 'elt coq_R_remove =
                  | R_remove_0 of 'elt tree
                  | R_remove_1 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'elt tree * 'elt coq_R_remove
                  | R_remove_2 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t
                  | R_remove_3 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'elt tree * 'elt coq_R_remove

                  val coq_R_remove_rect :
                    Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2
                    -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
                    tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree
                    -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                    -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 ->
                    'a2) -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_remove -> 'a2

                  val coq_R_remove_rec :
                    Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2
                    -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
                    tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree
                    -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                    -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 ->
                    'a2) -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_remove -> 'a2

                  type 'elt coq_R_concat =
                  | R_concat_0 of 'elt tree * 'elt tree
                  | R_concat_1 of 'elt tree * 'elt tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t
                  | R_concat_2 of 'elt tree * 'elt tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree
                     * (key * 'elt)

                  val coq_R_concat_rect :
                    ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> 'a1 tree ->
                    'a1 tree -> 'a1 coq_R_concat -> 'a2

                  val coq_R_concat_rec :
                    ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> 'a1 tree ->
                    'a1 tree -> 'a1 coq_R_concat -> 'a2

                  type 'elt coq_R_split =
                  | R_split_0 of 'elt tree
                  | R_split_1 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'elt triple
                     * 'elt coq_R_split * 'elt tree * 'elt option * 'elt tree
                  | R_split_2 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t
                  | R_split_3 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'elt triple
                     * 'elt coq_R_split * 'elt tree * 'elt option * 'elt tree

                  val coq_R_split_rect :
                    Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2
                    -> 'a1 tree -> 'a1 option -> 'a1 tree -> __ -> 'a2) ->
                    ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree
                    -> 'a1 option -> 'a1 tree -> __ -> 'a2) -> 'a1 tree ->
                    'a1 triple -> 'a1 coq_R_split -> 'a2

                  val coq_R_split_rec :
                    Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2
                    -> 'a1 tree -> 'a1 option -> 'a1 tree -> __ -> 'a2) ->
                    ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree
                    -> 'a1 option -> 'a1 tree -> __ -> 'a2) -> 'a1 tree ->
                    'a1 triple -> 'a1 coq_R_split -> 'a2

                  type ('elt, 'x) coq_R_map_option =
                  | R_map_option_0 of 'elt tree
                  | R_map_option_1 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'x * 'x tree
                     * ('elt, 'x) coq_R_map_option * 'x tree
                     * ('elt, 'x) coq_R_map_option
                  | R_map_option_2 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'x tree
                     * ('elt, 'x) coq_R_map_option * 'x tree
                     * ('elt, 'x) coq_R_map_option

                  val coq_R_map_option_rect :
                    (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) ->
                    ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> 'a2 -> __ -> 'a2 tree -> ('a1, 'a2)
                    coq_R_map_option -> 'a3 -> 'a2 tree -> ('a1, 'a2)
                    coq_R_map_option -> 'a3 -> 'a3) -> ('a1 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                    'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2
                    tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> 'a1
                    tree -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3

                  val coq_R_map_option_rec :
                    (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) ->
                    ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> 'a2 -> __ -> 'a2 tree -> ('a1, 'a2)
                    coq_R_map_option -> 'a3 -> 'a2 tree -> ('a1, 'a2)
                    coq_R_map_option -> 'a3 -> 'a3) -> ('a1 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                    'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2
                    tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> 'a1
                    tree -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3

                  type ('elt, 'x0, 'x) coq_R_map2_opt =
                  | R_map2_opt_0 of 'elt tree * 'x0 tree
                  | R_map2_opt_1 of 'elt tree * 'x0 tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t
                  | R_map2_opt_2 of 'elt tree * 'x0 tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t * 'x0 tree * 
                     key * 'x0 * 'x0 tree * Z_as_Int.t * 'x0 tree
                     * 'x0 option * 'x0 tree * 'x * 'x tree
                     * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
                     * ('elt, 'x0, 'x) coq_R_map2_opt
                  | R_map2_opt_3 of 'elt tree * 'x0 tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t * 'x0 tree * 
                     key * 'x0 * 'x0 tree * Z_as_Int.t * 'x0 tree
                     * 'x0 option * 'x0 tree * 'x tree
                     * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
                     * ('elt, 'x0, 'x) coq_R_map2_opt

                  val coq_R_map2_opt_rect :
                    (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree ->
                    'a3 tree) -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2
                    tree -> __ -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                    'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1
                    -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 tree -> key -> 'a2
                    -> 'a2 tree -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2 option
                    -> 'a2 tree -> __ -> 'a3 -> __ -> 'a3 tree -> ('a1, 'a2,
                    'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
                    coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree ->
                    'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    'a2 tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ ->
                    'a2 tree -> 'a2 option -> 'a2 tree -> __ -> __ -> 'a3
                    tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree
                    -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1
                    tree -> 'a2 tree -> 'a3 tree -> ('a1, 'a2, 'a3)
                    coq_R_map2_opt -> 'a4

                  val coq_R_map2_opt_rec :
                    (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree ->
                    'a3 tree) -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2
                    tree -> __ -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                    'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1
                    -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 tree -> key -> 'a2
                    -> 'a2 tree -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2 option
                    -> 'a2 tree -> __ -> 'a3 -> __ -> 'a3 tree -> ('a1, 'a2,
                    'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
                    coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree ->
                    'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    'a2 tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ ->
                    'a2 tree -> 'a2 option -> 'a2 tree -> __ -> __ -> 'a3
                    tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree
                    -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1
                    tree -> 'a2 tree -> 'a3 tree -> ('a1, 'a2, 'a3)
                    coq_R_map2_opt -> 'a4

                  val fold' :
                    (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

                  val flatten_e : 'a1 enumeration -> (key * 'a1) list
                 end
               end

              type 'elt bst =
                'elt Raw.tree
                (* singleton inductive, whose constructor was Bst *)

              val this : 'a1 bst -> 'a1 Raw.tree

              type 'elt t = 'elt bst

              type key = Coq_regex_as_UCT.t

              val empty : 'a1 t

              val is_empty : 'a1 t -> bool

              val add : key -> 'a1 -> 'a1 t -> 'a1 t

              val remove : key -> 'a1 t -> 'a1 t

              val mem : key -> 'a1 t -> bool

              val find : key -> 'a1 t -> 'a1 option

              val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

              val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

              val map2 :
                ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t ->
                'a3 t

              val elements : 'a1 t -> (key * 'a1) list

              val cardinal : 'a1 t -> nat

              val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

              val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool
             end

            module Coq_reFMF :
             sig
              val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

              val coq_In_dec : 'a1 Coq_reFM.t -> Coq_reFM.key -> bool
             end

            module MatchSpec :
             sig
             end

            module MatchSpecLemmas :
             sig
             end

            module Notations :
             sig
             end

            module Helpers :
             sig
              val coq_Plus : Regexes.regex -> Regexes.regex

              val coq_IterUnion : Regexes.regex list -> Regexes.regex

              val coq_IterApp : Regexes.regex list -> Regexes.regex

              val coq_Optional : Regexes.regex -> Regexes.regex

              val coq_REString : Strings.coq_String -> Regexes.regex
             end
           end
         end

        module TabTy :
         sig
          module DS :
           sig
            module T_as_UCT :
             sig
              type t = R.Ty.coq_Sigma

              val compare : R.Ty.coq_Sigma -> R.Ty.coq_Sigma -> comparison
             end

            module T_as_UOT :
             sig
              type t = T_as_UCT.t

              val compare : t -> t -> t compare0

              val eq_dec : t -> t -> bool
             end

            module SigFS :
             sig
              module X' :
               sig
                type t = T_as_UCT.t

                val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                val compare : T_as_UCT.t -> T_as_UCT.t -> comparison
               end

              module MSet :
               sig
                module Raw :
                 sig
                  type elt = T_as_UCT.t

                  type tree = R.Defs.SigFS.MSet.Raw.tree =
                  | Leaf
                  | Node of Z_as_Int.t * tree * T_as_UCT.t * tree

                  val empty : tree

                  val is_empty : tree -> bool

                  val mem : T_as_UCT.t -> tree -> bool

                  val min_elt : tree -> elt option

                  val max_elt : tree -> elt option

                  val choose : tree -> elt option

                  val fold : (elt -> 'a1 -> 'a1) -> tree -> 'a1 -> 'a1

                  val elements_aux :
                    T_as_UCT.t list -> tree -> T_as_UCT.t list

                  val elements : tree -> T_as_UCT.t list

                  val rev_elements_aux :
                    T_as_UCT.t list -> tree -> T_as_UCT.t list

                  val rev_elements : tree -> T_as_UCT.t list

                  val cardinal : tree -> nat

                  val maxdepth : tree -> nat

                  val mindepth : tree -> nat

                  val for_all : (elt -> bool) -> tree -> bool

                  val exists_ : (elt -> bool) -> tree -> bool

                  type enumeration = R.Defs.SigFS.MSet.Raw.enumeration =
                  | End
                  | More of elt * tree * enumeration

                  val cons : tree -> enumeration -> enumeration

                  val compare_more :
                    T_as_UCT.t -> (enumeration -> comparison) -> enumeration
                    -> comparison

                  val compare_cont :
                    tree -> (enumeration -> comparison) -> enumeration ->
                    comparison

                  val compare_end : enumeration -> comparison

                  val compare : tree -> tree -> comparison

                  val equal : tree -> tree -> bool

                  val subsetl : (tree -> bool) -> T_as_UCT.t -> tree -> bool

                  val subsetr : (tree -> bool) -> T_as_UCT.t -> tree -> bool

                  val subset : tree -> tree -> bool

                  type t = tree

                  val height : t -> Z_as_Int.t

                  val singleton : T_as_UCT.t -> tree

                  val create : t -> T_as_UCT.t -> t -> tree

                  val assert_false : t -> T_as_UCT.t -> t -> tree

                  val bal : t -> T_as_UCT.t -> t -> tree

                  val add : T_as_UCT.t -> tree -> tree

                  val join : tree -> elt -> t -> t

                  val remove_min : tree -> elt -> t -> t * elt

                  val merge : tree -> tree -> tree

                  val remove : T_as_UCT.t -> tree -> tree

                  val concat : tree -> tree -> tree

                  type triple = R.Defs.SigFS.MSet.Raw.triple = { t_left : 
                                                                 t;
                                                                 t_in : 
                                                                 bool;
                                                                 t_right : 
                                                                 t }

                  val t_left : triple -> t

                  val t_in : triple -> bool

                  val t_right : triple -> t

                  val split : T_as_UCT.t -> tree -> triple

                  val inter : tree -> tree -> tree

                  val diff : tree -> tree -> tree

                  val union : tree -> tree -> tree

                  val filter : (elt -> bool) -> tree -> tree

                  val partition : (elt -> bool) -> t -> t * t

                  val ltb_tree : T_as_UCT.t -> tree -> bool

                  val gtb_tree : T_as_UCT.t -> tree -> bool

                  val isok : tree -> bool

                  module MX :
                   sig
                    module OrderTac :
                     sig
                      module OTF :
                       sig
                        type t = T_as_UCT.t

                        val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

                        val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
                       end

                      module TO :
                       sig
                        type t = T_as_UCT.t

                        val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

                        val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
                       end
                     end

                    val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                    val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                    val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
                   end

                  type coq_R_min_elt = R.Defs.SigFS.MSet.Raw.coq_R_min_elt =
                  | R_min_elt_0 of tree
                  | R_min_elt_1 of tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree
                  | R_min_elt_2 of tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree * Z_as_Int.t * tree * T_as_UCT.t * tree
                     * elt option * coq_R_min_elt

                  type coq_R_max_elt = R.Defs.SigFS.MSet.Raw.coq_R_max_elt =
                  | R_max_elt_0 of tree
                  | R_max_elt_1 of tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree
                  | R_max_elt_2 of tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree * Z_as_Int.t * tree * T_as_UCT.t * tree
                     * elt option * coq_R_max_elt

                  module L :
                   sig
                    module MO :
                     sig
                      module OrderTac :
                       sig
                        module OTF :
                         sig
                          type t = T_as_UCT.t

                          val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

                          val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
                         end

                        module TO :
                         sig
                          type t = T_as_UCT.t

                          val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

                          val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
                         end
                       end

                      val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                      val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                      val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
                     end
                   end

                  val flatten_e : enumeration -> elt list

                  type coq_R_bal = R.Defs.SigFS.MSet.Raw.coq_R_bal =
                  | R_bal_0 of t * T_as_UCT.t * t
                  | R_bal_1 of t * T_as_UCT.t * t * Z_as_Int.t * tree
                     * T_as_UCT.t * tree
                  | R_bal_2 of t * T_as_UCT.t * t * Z_as_Int.t * tree
                     * T_as_UCT.t * tree
                  | R_bal_3 of t * T_as_UCT.t * t * Z_as_Int.t * tree
                     * T_as_UCT.t * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree
                  | R_bal_4 of t * T_as_UCT.t * t
                  | R_bal_5 of t * T_as_UCT.t * t * Z_as_Int.t * tree
                     * T_as_UCT.t * tree
                  | R_bal_6 of t * T_as_UCT.t * t * Z_as_Int.t * tree
                     * T_as_UCT.t * tree
                  | R_bal_7 of t * T_as_UCT.t * t * Z_as_Int.t * tree
                     * T_as_UCT.t * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree
                  | R_bal_8 of t * T_as_UCT.t * t

                  type coq_R_remove_min = R.Defs.SigFS.MSet.Raw.coq_R_remove_min =
                  | R_remove_min_0 of tree * elt * t
                  | R_remove_min_1 of tree * elt * t * Z_as_Int.t * tree
                     * T_as_UCT.t * tree * (t * elt) * coq_R_remove_min * 
                     t * elt

                  type coq_R_merge = R.Defs.SigFS.MSet.Raw.coq_R_merge =
                  | R_merge_0 of tree * tree
                  | R_merge_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree
                  | R_merge_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree * Z_as_Int.t * tree * T_as_UCT.t * tree * 
                     t * elt

                  type coq_R_concat = R.Defs.SigFS.MSet.Raw.coq_R_concat =
                  | R_concat_0 of tree * tree
                  | R_concat_1 of tree * tree * Z_as_Int.t * tree
                     * T_as_UCT.t * tree
                  | R_concat_2 of tree * tree * Z_as_Int.t * tree
                     * T_as_UCT.t * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree * t * elt

                  type coq_R_inter = R.Defs.SigFS.MSet.Raw.coq_R_inter =
                  | R_inter_0 of tree * tree
                  | R_inter_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree
                  | R_inter_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree * Z_as_Int.t * tree * T_as_UCT.t * tree * 
                     t * bool * t * tree * coq_R_inter * tree * coq_R_inter
                  | R_inter_3 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree * Z_as_Int.t * tree * T_as_UCT.t * tree * 
                     t * bool * t * tree * coq_R_inter * tree * coq_R_inter

                  type coq_R_diff = R.Defs.SigFS.MSet.Raw.coq_R_diff =
                  | R_diff_0 of tree * tree
                  | R_diff_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree
                  | R_diff_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree * Z_as_Int.t * tree * T_as_UCT.t * tree * 
                     t * bool * t * tree * coq_R_diff * tree * coq_R_diff
                  | R_diff_3 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree * Z_as_Int.t * tree * T_as_UCT.t * tree * 
                     t * bool * t * tree * coq_R_diff * tree * coq_R_diff

                  type coq_R_union = R.Defs.SigFS.MSet.Raw.coq_R_union =
                  | R_union_0 of tree * tree
                  | R_union_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree
                  | R_union_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree * Z_as_Int.t * tree * T_as_UCT.t * tree * 
                     t * bool * t * tree * coq_R_union * tree * coq_R_union
                 end

                module E :
                 sig
                  type t = T_as_UCT.t

                  val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

                  val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
                 end

                type elt = T_as_UCT.t

                type t_ =
                  Raw.t
                  (* singleton inductive, whose constructor was Mkt *)

                val this : t_ -> Raw.t

                type t = t_

                val mem : elt -> t -> bool

                val add : elt -> t -> t

                val remove : elt -> t -> t

                val singleton : elt -> t

                val union : t -> t -> t

                val inter : t -> t -> t

                val diff : t -> t -> t

                val equal : t -> t -> bool

                val subset : t -> t -> bool

                val empty : t

                val is_empty : t -> bool

                val elements : t -> elt list

                val choose : t -> elt option

                val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

                val cardinal : t -> nat

                val filter : (elt -> bool) -> t -> t

                val for_all : (elt -> bool) -> t -> bool

                val exists_ : (elt -> bool) -> t -> bool

                val partition : (elt -> bool) -> t -> t * t

                val eq_dec : t -> t -> bool

                val compare : t -> t -> comparison

                val min_elt : t -> elt option

                val max_elt : t -> elt option
               end

              type elt = T_as_UCT.t

              type t = MSet.t

              val empty : t

              val is_empty : t -> bool

              val mem : elt -> t -> bool

              val add : elt -> t -> t

              val singleton : elt -> t

              val remove : elt -> t -> t

              val union : t -> t -> t

              val inter : t -> t -> t

              val diff : t -> t -> t

              val eq_dec : t -> t -> bool

              val equal : t -> t -> bool

              val subset : t -> t -> bool

              val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

              val for_all : (elt -> bool) -> t -> bool

              val exists_ : (elt -> bool) -> t -> bool

              val filter : (elt -> bool) -> t -> t

              val partition : (elt -> bool) -> t -> t * t

              val cardinal : t -> nat

              val elements : t -> elt list

              val choose : t -> elt option

              module MF :
               sig
                val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
               end

              val min_elt : t -> elt option

              val max_elt : t -> elt option

              val compare : t -> t -> t compare0

              module E :
               sig
                type t = T_as_UCT.t

                val compare : T_as_UCT.t -> T_as_UCT.t -> T_as_UCT.t compare0

                val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
               end
             end

            module SigFSF :
             sig
              val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
             end

            module SigFM :
             sig
              module E :
               sig
                type t = T_as_UCT.t

                val compare : T_as_UCT.t -> T_as_UCT.t -> T_as_UCT.t compare0

                val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
               end

              module Raw :
               sig
                type key = T_as_UCT.t

                type 'elt tree = 'elt R.Defs.SigFM.Raw.tree =
                | Leaf
                | Node of 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t

                val tree_rect :
                  'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
                  Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

                val tree_rec :
                  'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
                  Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

                val height : 'a1 tree -> Z_as_Int.t

                val cardinal : 'a1 tree -> nat

                val empty : 'a1 tree

                val is_empty : 'a1 tree -> bool

                val mem : T_as_UCT.t -> 'a1 tree -> bool

                val find : T_as_UCT.t -> 'a1 tree -> 'a1 option

                val create : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

                val assert_false :
                  'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

                val bal : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

                val add : key -> 'a1 -> 'a1 tree -> 'a1 tree

                val remove_min :
                  'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree * (key * 'a1)

                val merge : 'a1 tree -> 'a1 tree -> 'a1 tree

                val remove : T_as_UCT.t -> 'a1 tree -> 'a1 tree

                val join : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

                type 'elt triple = 'elt R.Defs.SigFM.Raw.triple = { t_left : 
                                                                    'elt tree;
                                                                    t_opt : 
                                                                    'elt
                                                                    option;
                                                                    t_right : 
                                                                    'elt tree }

                val t_left : 'a1 triple -> 'a1 tree

                val t_opt : 'a1 triple -> 'a1 option

                val t_right : 'a1 triple -> 'a1 tree

                val split : T_as_UCT.t -> 'a1 tree -> 'a1 triple

                val concat : 'a1 tree -> 'a1 tree -> 'a1 tree

                val elements_aux :
                  (key * 'a1) list -> 'a1 tree -> (key * 'a1) list

                val elements : 'a1 tree -> (key * 'a1) list

                val fold :
                  (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

                type 'elt enumeration = 'elt R.Defs.SigFM.Raw.enumeration =
                | End
                | More of key * 'elt * 'elt tree * 'elt enumeration

                val enumeration_rect :
                  'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 ->
                  'a2) -> 'a1 enumeration -> 'a2

                val enumeration_rec :
                  'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 ->
                  'a2) -> 'a1 enumeration -> 'a2

                val cons : 'a1 tree -> 'a1 enumeration -> 'a1 enumeration

                val equal_more :
                  ('a1 -> 'a1 -> bool) -> T_as_UCT.t -> 'a1 -> ('a1
                  enumeration -> bool) -> 'a1 enumeration -> bool

                val equal_cont :
                  ('a1 -> 'a1 -> bool) -> 'a1 tree -> ('a1 enumeration ->
                  bool) -> 'a1 enumeration -> bool

                val equal_end : 'a1 enumeration -> bool

                val equal :
                  ('a1 -> 'a1 -> bool) -> 'a1 tree -> 'a1 tree -> bool

                val map : ('a1 -> 'a2) -> 'a1 tree -> 'a2 tree

                val mapi : (key -> 'a1 -> 'a2) -> 'a1 tree -> 'a2 tree

                val map_option :
                  (key -> 'a1 -> 'a2 option) -> 'a1 tree -> 'a2 tree

                val map2_opt :
                  (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree ->
                  'a3 tree) -> ('a2 tree -> 'a3 tree) -> 'a1 tree -> 'a2 tree
                  -> 'a3 tree

                val map2 :
                  ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 tree -> 'a2
                  tree -> 'a3 tree

                module Proofs :
                 sig
                  module MX :
                   sig
                    module TO :
                     sig
                      type t = T_as_UCT.t
                     end

                    module IsTO :
                     sig
                     end

                    module OrderTac :
                     sig
                     end

                    val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                    val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                    val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
                   end

                  module PX :
                   sig
                    module MO :
                     sig
                      module TO :
                       sig
                        type t = T_as_UCT.t
                       end

                      module IsTO :
                       sig
                       end

                      module OrderTac :
                       sig
                       end

                      val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                      val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                      val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
                     end
                   end

                  module L :
                   sig
                    module MX :
                     sig
                      module TO :
                       sig
                        type t = T_as_UCT.t
                       end

                      module IsTO :
                       sig
                       end

                      module OrderTac :
                       sig
                       end

                      val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                      val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                      val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
                     end

                    module PX :
                     sig
                      module MO :
                       sig
                        module TO :
                         sig
                          type t = T_as_UCT.t
                         end

                        module IsTO :
                         sig
                         end

                        module OrderTac :
                         sig
                         end

                        val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                        val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                        val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
                       end
                     end

                    type key = T_as_UCT.t

                    type 'elt t = (T_as_UCT.t * 'elt) list

                    val empty : 'a1 t

                    val is_empty : 'a1 t -> bool

                    val mem : key -> 'a1 t -> bool

                    type 'elt coq_R_mem = 'elt R.Defs.SigFM.Raw.Proofs.L.coq_R_mem =
                    | R_mem_0 of 'elt t
                    | R_mem_1 of 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list
                    | R_mem_2 of 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list
                    | R_mem_3 of 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list * bool * 'elt coq_R_mem

                    val coq_R_mem_rect :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                      'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                      'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 ->
                      'a2) -> 'a1 t -> bool -> 'a1 coq_R_mem -> 'a2

                    val coq_R_mem_rec :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                      'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                      'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 ->
                      'a2) -> 'a1 t -> bool -> 'a1 coq_R_mem -> 'a2

                    val mem_rect :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                      'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                      'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val mem_rec :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                      'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                      'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val coq_R_mem_correct :
                      key -> 'a1 t -> bool -> 'a1 coq_R_mem

                    val find : key -> 'a1 t -> 'a1 option

                    type 'elt coq_R_find = 'elt R.Defs.SigFM.Raw.Proofs.L.coq_R_find =
                    | R_find_0 of 'elt t
                    | R_find_1 of 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list
                    | R_find_2 of 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list
                    | R_find_3 of 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list * 'elt option
                       * 'elt coq_R_find

                    val coq_R_find_rect :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                      'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                      'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find ->
                      'a2 -> 'a2) -> 'a1 t -> 'a1 option -> 'a1 coq_R_find ->
                      'a2

                    val coq_R_find_rec :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                      'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                      'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find ->
                      'a2 -> 'a2) -> 'a1 t -> 'a1 option -> 'a1 coq_R_find ->
                      'a2

                    val find_rect :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                      'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                      'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val find_rec :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                      'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                      'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val coq_R_find_correct :
                      key -> 'a1 t -> 'a1 option -> 'a1 coq_R_find

                    val add : key -> 'a1 -> 'a1 t -> 'a1 t

                    type 'elt coq_R_add = 'elt R.Defs.SigFM.Raw.Proofs.L.coq_R_add =
                    | R_add_0 of 'elt t
                    | R_add_1 of 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list
                    | R_add_2 of 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list
                    | R_add_3 of 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list * 'elt t * 'elt coq_R_add

                    val coq_R_add_rect :
                      key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
                      __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_add -> 'a2 ->
                      'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_add -> 'a2

                    val coq_R_add_rec :
                      key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
                      __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_add -> 'a2 ->
                      'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_add -> 'a2

                    val add_rect :
                      key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
                      __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val add_rec :
                      key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
                      __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val coq_R_add_correct :
                      key -> 'a1 -> 'a1 t -> 'a1 t -> 'a1 coq_R_add

                    val remove : key -> 'a1 t -> 'a1 t

                    type 'elt coq_R_remove = 'elt R.Defs.SigFM.Raw.Proofs.L.coq_R_remove =
                    | R_remove_0 of 'elt t
                    | R_remove_1 of 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list
                    | R_remove_2 of 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list
                    | R_remove_3 of 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list * 'elt t * 'elt coq_R_remove

                    val coq_R_remove_rect :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                      'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                      'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_remove -> 'a2
                      -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove -> 'a2

                    val coq_R_remove_rec :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                      'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                      'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_remove -> 'a2
                      -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove -> 'a2

                    val remove_rect :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                      'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                      'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val remove_rec :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                      'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                      'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val coq_R_remove_correct :
                      key -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove

                    val elements : 'a1 t -> 'a1 t

                    val fold :
                      (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

                    type ('elt, 'a) coq_R_fold = ('elt, 'a) R.Defs.SigFM.Raw.Proofs.L.coq_R_fold =
                    | R_fold_0 of 'elt t * 'a
                    | R_fold_1 of 'elt t * 'a * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list * 'a * ('elt, 'a) coq_R_fold

                    val coq_R_fold_rect :
                      (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ ->
                      'a3) -> ('a1 t -> 'a2 -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> 'a2 -> ('a1, 'a2)
                      coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a2 ->
                      ('a1, 'a2) coq_R_fold -> 'a3

                    val coq_R_fold_rec :
                      (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ ->
                      'a3) -> ('a1 t -> 'a2 -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> 'a2 -> ('a1, 'a2)
                      coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a2 ->
                      ('a1, 'a2) coq_R_fold -> 'a3

                    val fold_rect :
                      (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ ->
                      'a3) -> ('a1 t -> 'a2 -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> 'a3 -> 'a3) -> 'a1 t
                      -> 'a2 -> 'a3

                    val fold_rec :
                      (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ ->
                      'a3) -> ('a1 t -> 'a2 -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> 'a3 -> 'a3) -> 'a1 t
                      -> 'a2 -> 'a3

                    val coq_R_fold_correct :
                      (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2 ->
                      ('a1, 'a2) coq_R_fold

                    val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool

                    type 'elt coq_R_equal = 'elt R.Defs.SigFM.Raw.Proofs.L.coq_R_equal =
                    | R_equal_0 of 'elt t * 'elt t
                    | R_equal_1 of 'elt t * 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list * bool * 'elt coq_R_equal
                    | R_equal_2 of 'elt t * 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list * T_as_UCT.t compare0
                    | R_equal_3 of 'elt t * 'elt t * 'elt t * 'elt t

                    val coq_R_equal_rect :
                      ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                      'a2) -> ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> bool ->
                      'a1 coq_R_equal -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t ->
                      T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
                      T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
                      T_as_UCT.t compare0 -> __ -> __ -> 'a2) -> ('a1 t ->
                      'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2) ->
                      'a1 t -> 'a1 t -> bool -> 'a1 coq_R_equal -> 'a2

                    val coq_R_equal_rec :
                      ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                      'a2) -> ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> bool ->
                      'a1 coq_R_equal -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t ->
                      T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
                      T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
                      T_as_UCT.t compare0 -> __ -> __ -> 'a2) -> ('a1 t ->
                      'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2) ->
                      'a1 t -> 'a1 t -> bool -> 'a1 coq_R_equal -> 'a2

                    val equal_rect :
                      ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                      'a2) -> ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
                      'a2) -> ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t compare0 ->
                      __ -> __ -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ ->
                      'a1 t -> __ -> __ -> 'a2) -> 'a1 t -> 'a1 t -> 'a2

                    val equal_rec :
                      ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                      'a2) -> ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
                      'a2) -> ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t compare0 ->
                      __ -> __ -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ ->
                      'a1 t -> __ -> __ -> 'a2) -> 'a1 t -> 'a1 t -> 'a2

                    val coq_R_equal_correct :
                      ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool -> 'a1
                      coq_R_equal

                    val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

                    val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

                    val option_cons :
                      key -> 'a1 option -> (key * 'a1) list -> (key * 'a1)
                      list

                    val map2_l :
                      ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t ->
                      'a3 t

                    val map2_r :
                      ('a1 option -> 'a2 option -> 'a3 option) -> 'a2 t ->
                      'a3 t

                    val map2 :
                      ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t ->
                      'a2 t -> 'a3 t

                    val combine :
                      'a1 t -> 'a2 t -> ('a1 option * 'a2 option) t

                    val fold_right_pair :
                      ('a1 -> 'a2 -> 'a3 -> 'a3) -> ('a1 * 'a2) list -> 'a3
                      -> 'a3

                    val map2_alt :
                      ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t ->
                      'a2 t -> (key * 'a3) list

                    val at_least_one :
                      'a1 option -> 'a2 option -> ('a1 option * 'a2 option)
                      option

                    val at_least_one_then_f :
                      ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 option
                      -> 'a2 option -> 'a3 option
                   end

                  type 'elt coq_R_mem = 'elt R.Defs.SigFM.Raw.Proofs.coq_R_mem =
                  | R_mem_0 of 'elt tree
                  | R_mem_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                     * Z_as_Int.t * bool * 'elt coq_R_mem
                  | R_mem_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                     * Z_as_Int.t
                  | R_mem_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                     * Z_as_Int.t * bool * 'elt coq_R_mem

                  val coq_R_mem_rect :
                    T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key
                    -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
                    bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 tree -> bool
                    -> 'a1 coq_R_mem -> 'a2

                  val coq_R_mem_rec :
                    T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key
                    -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
                    bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 tree -> bool
                    -> 'a1 coq_R_mem -> 'a2

                  type 'elt coq_R_find = 'elt R.Defs.SigFM.Raw.Proofs.coq_R_find =
                  | R_find_0 of 'elt tree
                  | R_find_1 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'elt option * 'elt coq_R_find
                  | R_find_2 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t
                  | R_find_3 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'elt option * 'elt coq_R_find

                  val coq_R_find_rect :
                    T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) ->
                    ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) ->
                    'a1 tree -> 'a1 option -> 'a1 coq_R_find -> 'a2

                  val coq_R_find_rec :
                    T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) ->
                    ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) ->
                    'a1 tree -> 'a1 option -> 'a1 coq_R_find -> 'a2

                  type 'elt coq_R_bal = 'elt R.Defs.SigFM.Raw.Proofs.coq_R_bal =
                  | R_bal_0 of 'elt tree * key * 'elt * 'elt tree
                  | R_bal_1 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                     * key * 'elt * 'elt tree * Z_as_Int.t
                  | R_bal_2 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                     * key * 'elt * 'elt tree * Z_as_Int.t
                  | R_bal_3 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                     * key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t
                  | R_bal_4 of 'elt tree * key * 'elt * 'elt tree
                  | R_bal_5 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                     * key * 'elt * 'elt tree * Z_as_Int.t
                  | R_bal_6 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                     * key * 'elt * 'elt tree * Z_as_Int.t
                  | R_bal_7 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                     * key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t
                  | R_bal_8 of 'elt tree * key * 'elt * 'elt tree

                  val coq_R_bal_rect :
                    ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ ->
                    'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
                    -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                    -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1
                    tree -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree
                    -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key
                    -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
                    -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 ->
                    'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key ->
                    'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2)
                    -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __
                    -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key ->
                    'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree ->
                    key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
                    'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
                    -> __ -> __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree
                    -> 'a1 tree -> 'a1 coq_R_bal -> 'a2

                  val coq_R_bal_rec :
                    ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ ->
                    'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
                    -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                    -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1
                    tree -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree
                    -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key
                    -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
                    -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 ->
                    'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key ->
                    'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2)
                    -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __
                    -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key ->
                    'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree ->
                    key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
                    'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
                    -> __ -> __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree
                    -> 'a1 tree -> 'a1 coq_R_bal -> 'a2

                  type 'elt coq_R_add = 'elt R.Defs.SigFM.Raw.Proofs.coq_R_add =
                  | R_add_0 of 'elt tree
                  | R_add_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                     * Z_as_Int.t * 'elt tree * 'elt coq_R_add
                  | R_add_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                     * Z_as_Int.t
                  | R_add_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                     * Z_as_Int.t * 'elt tree * 'elt coq_R_add

                  val coq_R_add_rect :
                    key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key
                    -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
                    tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 tree -> 'a1
                    tree -> 'a1 coq_R_add -> 'a2

                  val coq_R_add_rec :
                    key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key
                    -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
                    tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 tree -> 'a1
                    tree -> 'a1 coq_R_add -> 'a2

                  type 'elt coq_R_remove_min = 'elt R.Defs.SigFM.Raw.Proofs.coq_R_remove_min =
                  | R_remove_min_0 of 'elt tree * key * 'elt * 'elt tree
                  | R_remove_min_1 of 'elt tree * key * 'elt * 'elt tree
                     * 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t
                     * ('elt tree * (key * 'elt)) * 'elt coq_R_remove_min
                     * 'elt tree * (key * 'elt)

                  val coq_R_remove_min_rect :
                    ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1
                    tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1
                    -> 'a1 tree -> Z_as_Int.t -> __ -> ('a1
                    tree * (key * 'a1)) -> 'a1 coq_R_remove_min -> 'a2 -> 'a1
                    tree -> (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> key ->
                    'a1 -> 'a1 tree -> ('a1 tree * (key * 'a1)) -> 'a1
                    coq_R_remove_min -> 'a2

                  val coq_R_remove_min_rec :
                    ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1
                    tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1
                    -> 'a1 tree -> Z_as_Int.t -> __ -> ('a1
                    tree * (key * 'a1)) -> 'a1 coq_R_remove_min -> 'a2 -> 'a1
                    tree -> (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> key ->
                    'a1 -> 'a1 tree -> ('a1 tree * (key * 'a1)) -> 'a1
                    coq_R_remove_min -> 'a2

                  type 'elt coq_R_merge = 'elt R.Defs.SigFM.Raw.Proofs.coq_R_merge =
                  | R_merge_0 of 'elt tree * 'elt tree
                  | R_merge_1 of 'elt tree * 'elt tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t
                  | R_merge_2 of 'elt tree * 'elt tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree
                     * (key * 'elt) * key * 'elt

                  val coq_R_merge_rect :
                    ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> (key * 'a1) -> __ -> key -> 'a1 -> __ -> 'a2) -> 'a1
                    tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_merge -> 'a2

                  val coq_R_merge_rec :
                    ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> (key * 'a1) -> __ -> key -> 'a1 -> __ -> 'a2) -> 'a1
                    tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_merge -> 'a2

                  type 'elt coq_R_remove = 'elt R.Defs.SigFM.Raw.Proofs.coq_R_remove =
                  | R_remove_0 of 'elt tree
                  | R_remove_1 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'elt tree * 'elt coq_R_remove
                  | R_remove_2 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t
                  | R_remove_3 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'elt tree * 'elt coq_R_remove

                  val coq_R_remove_rect :
                    T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) ->
                    ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) ->
                    'a1 tree -> 'a1 tree -> 'a1 coq_R_remove -> 'a2

                  val coq_R_remove_rec :
                    T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) ->
                    ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) ->
                    'a1 tree -> 'a1 tree -> 'a1 coq_R_remove -> 'a2

                  type 'elt coq_R_concat = 'elt R.Defs.SigFM.Raw.Proofs.coq_R_concat =
                  | R_concat_0 of 'elt tree * 'elt tree
                  | R_concat_1 of 'elt tree * 'elt tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t
                  | R_concat_2 of 'elt tree * 'elt tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree
                     * (key * 'elt)

                  val coq_R_concat_rect :
                    ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> 'a1 tree ->
                    'a1 tree -> 'a1 coq_R_concat -> 'a2

                  val coq_R_concat_rec :
                    ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> 'a1 tree ->
                    'a1 tree -> 'a1 coq_R_concat -> 'a2

                  type 'elt coq_R_split = 'elt R.Defs.SigFM.Raw.Proofs.coq_R_split =
                  | R_split_0 of 'elt tree
                  | R_split_1 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'elt triple
                     * 'elt coq_R_split * 'elt tree * 'elt option * 'elt tree
                  | R_split_2 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t
                  | R_split_3 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'elt triple
                     * 'elt coq_R_split * 'elt tree * 'elt option * 'elt tree

                  val coq_R_split_rect :
                    T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree
                    -> 'a1 option -> 'a1 tree -> __ -> 'a2) -> ('a1 tree ->
                    'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
                    -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 triple
                    -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option ->
                    'a1 tree -> __ -> 'a2) -> 'a1 tree -> 'a1 triple -> 'a1
                    coq_R_split -> 'a2

                  val coq_R_split_rec :
                    T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree
                    -> 'a1 option -> 'a1 tree -> __ -> 'a2) -> ('a1 tree ->
                    'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
                    -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 triple
                    -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option ->
                    'a1 tree -> __ -> 'a2) -> 'a1 tree -> 'a1 triple -> 'a1
                    coq_R_split -> 'a2

                  type ('elt, 'x) coq_R_map_option = ('elt, 'x) R.Defs.SigFM.Raw.Proofs.coq_R_map_option =
                  | R_map_option_0 of 'elt tree
                  | R_map_option_1 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'x * 'x tree
                     * ('elt, 'x) coq_R_map_option * 'x tree
                     * ('elt, 'x) coq_R_map_option
                  | R_map_option_2 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'x tree
                     * ('elt, 'x) coq_R_map_option * 'x tree
                     * ('elt, 'x) coq_R_map_option

                  val coq_R_map_option_rect :
                    (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) ->
                    ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> 'a2 -> __ -> 'a2 tree -> ('a1, 'a2)
                    coq_R_map_option -> 'a3 -> 'a2 tree -> ('a1, 'a2)
                    coq_R_map_option -> 'a3 -> 'a3) -> ('a1 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                    'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2
                    tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> 'a1
                    tree -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3

                  val coq_R_map_option_rec :
                    (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) ->
                    ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> 'a2 -> __ -> 'a2 tree -> ('a1, 'a2)
                    coq_R_map_option -> 'a3 -> 'a2 tree -> ('a1, 'a2)
                    coq_R_map_option -> 'a3 -> 'a3) -> ('a1 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                    'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2
                    tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> 'a1
                    tree -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3

                  type ('elt, 'x0, 'x) coq_R_map2_opt = ('elt, 'x0, 'x) R.Defs.SigFM.Raw.Proofs.coq_R_map2_opt =
                  | R_map2_opt_0 of 'elt tree * 'x0 tree
                  | R_map2_opt_1 of 'elt tree * 'x0 tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t
                  | R_map2_opt_2 of 'elt tree * 'x0 tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t * 'x0 tree * 
                     key * 'x0 * 'x0 tree * Z_as_Int.t * 'x0 tree
                     * 'x0 option * 'x0 tree * 'x * 'x tree
                     * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
                     * ('elt, 'x0, 'x) coq_R_map2_opt
                  | R_map2_opt_3 of 'elt tree * 'x0 tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t * 'x0 tree * 
                     key * 'x0 * 'x0 tree * Z_as_Int.t * 'x0 tree
                     * 'x0 option * 'x0 tree * 'x tree
                     * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
                     * ('elt, 'x0, 'x) coq_R_map2_opt

                  val coq_R_map2_opt_rect :
                    (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree ->
                    'a3 tree) -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2
                    tree -> __ -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                    'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1
                    -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 tree -> key -> 'a2
                    -> 'a2 tree -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2 option
                    -> 'a2 tree -> __ -> 'a3 -> __ -> 'a3 tree -> ('a1, 'a2,
                    'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
                    coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree ->
                    'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    'a2 tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ ->
                    'a2 tree -> 'a2 option -> 'a2 tree -> __ -> __ -> 'a3
                    tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree
                    -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1
                    tree -> 'a2 tree -> 'a3 tree -> ('a1, 'a2, 'a3)
                    coq_R_map2_opt -> 'a4

                  val coq_R_map2_opt_rec :
                    (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree ->
                    'a3 tree) -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2
                    tree -> __ -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                    'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1
                    -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 tree -> key -> 'a2
                    -> 'a2 tree -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2 option
                    -> 'a2 tree -> __ -> 'a3 -> __ -> 'a3 tree -> ('a1, 'a2,
                    'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
                    coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree ->
                    'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    'a2 tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ ->
                    'a2 tree -> 'a2 option -> 'a2 tree -> __ -> __ -> 'a3
                    tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree
                    -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1
                    tree -> 'a2 tree -> 'a3 tree -> ('a1, 'a2, 'a3)
                    coq_R_map2_opt -> 'a4

                  val fold' :
                    (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

                  val flatten_e : 'a1 enumeration -> (key * 'a1) list
                 end
               end

              type 'elt bst =
                'elt Raw.tree
                (* singleton inductive, whose constructor was Bst *)

              val this : 'a1 bst -> 'a1 Raw.tree

              type 'elt t = 'elt bst

              type key = T_as_UCT.t

              val empty : 'a1 t

              val is_empty : 'a1 t -> bool

              val add : key -> 'a1 -> 'a1 t -> 'a1 t

              val remove : key -> 'a1 t -> 'a1 t

              val mem : key -> 'a1 t -> bool

              val find : key -> 'a1 t -> 'a1 option

              val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

              val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

              val map2 :
                ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t ->
                'a3 t

              val elements : 'a1 t -> (key * 'a1) list

              val cardinal : 'a1 t -> nat

              val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

              val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool
             end

            module SigFMF :
             sig
              val eqb : T_as_UCT.t -> T_as_UCT.t -> bool

              val coq_In_dec : 'a1 SigFM.t -> SigFM.key -> bool
             end

            module Strings :
             sig
              type coq_String = R.Ty.coq_Sigma list

              val coq_String_dec : coq_String -> coq_String -> bool

              val rm_empty : coq_String list -> R.Ty.coq_Sigma list list
             end

            module Regexes :
             sig
              type regex = R.Defs.Regexes.regex =
              | EmptySet
              | EmptyStr
              | Char of R.Ty.coq_Sigma
              | App of regex * regex
              | Union of regex * regex
              | Star of regex

              val regex_rect :
                'a1 -> 'a1 -> (R.Ty.coq_Sigma -> 'a1) -> (regex -> 'a1 ->
                regex -> 'a1 -> 'a1) -> (regex -> 'a1 -> regex -> 'a1 -> 'a1)
                -> (regex -> 'a1 -> 'a1) -> regex -> 'a1

              val regex_rec :
                'a1 -> 'a1 -> (R.Ty.coq_Sigma -> 'a1) -> (regex -> 'a1 ->
                regex -> 'a1 -> 'a1) -> (regex -> 'a1 -> regex -> 'a1 -> 'a1)
                -> (regex -> 'a1 -> 'a1) -> regex -> 'a1

              val regex_dec : regex -> regex -> bool

              val regex_eq : regex -> regex -> bool

              val nullable' : regex -> bool

              val nullable : regex -> bool

              val derivative : R.Ty.coq_Sigma -> regex -> regex

              val derivative_list : R.Ty.coq_Sigma list -> regex -> regex

              val re_compare : regex -> regex -> comparison
             end

            module Coq_regex_as_UCT :
             sig
              type t = Regexes.regex

              val compare : Regexes.regex -> Regexes.regex -> comparison
             end

            module Coq_regex_as_UOT :
             sig
              type t = Coq_regex_as_UCT.t

              val compare : t -> t -> t compare0

              val eq_dec : t -> t -> bool
             end

            module Coq_reFS :
             sig
              module X' :
               sig
                type t = Coq_regex_as_UCT.t

                val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                val compare :
                  Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> comparison
               end

              module MSet :
               sig
                module Raw :
                 sig
                  type elt = Coq_regex_as_UCT.t

                  type tree = R.Defs.Coq_reFS.MSet.Raw.tree =
                  | Leaf
                  | Node of Z_as_Int.t * tree * Coq_regex_as_UCT.t * tree

                  val empty : tree

                  val is_empty : tree -> bool

                  val mem : Coq_regex_as_UCT.t -> tree -> bool

                  val min_elt : tree -> elt option

                  val max_elt : tree -> elt option

                  val choose : tree -> elt option

                  val fold : (elt -> 'a1 -> 'a1) -> tree -> 'a1 -> 'a1

                  val elements_aux :
                    Coq_regex_as_UCT.t list -> tree -> Coq_regex_as_UCT.t list

                  val elements : tree -> Coq_regex_as_UCT.t list

                  val rev_elements_aux :
                    Coq_regex_as_UCT.t list -> tree -> Coq_regex_as_UCT.t list

                  val rev_elements : tree -> Coq_regex_as_UCT.t list

                  val cardinal : tree -> nat

                  val maxdepth : tree -> nat

                  val mindepth : tree -> nat

                  val for_all : (elt -> bool) -> tree -> bool

                  val exists_ : (elt -> bool) -> tree -> bool

                  type enumeration = R.Defs.Coq_reFS.MSet.Raw.enumeration =
                  | End
                  | More of elt * tree * enumeration

                  val cons : tree -> enumeration -> enumeration

                  val compare_more :
                    Coq_regex_as_UCT.t -> (enumeration -> comparison) ->
                    enumeration -> comparison

                  val compare_cont :
                    tree -> (enumeration -> comparison) -> enumeration ->
                    comparison

                  val compare_end : enumeration -> comparison

                  val compare : tree -> tree -> comparison

                  val equal : tree -> tree -> bool

                  val subsetl :
                    (tree -> bool) -> Coq_regex_as_UCT.t -> tree -> bool

                  val subsetr :
                    (tree -> bool) -> Coq_regex_as_UCT.t -> tree -> bool

                  val subset : tree -> tree -> bool

                  type t = tree

                  val height : t -> Z_as_Int.t

                  val singleton : Coq_regex_as_UCT.t -> tree

                  val create : t -> Coq_regex_as_UCT.t -> t -> tree

                  val assert_false : t -> Coq_regex_as_UCT.t -> t -> tree

                  val bal : t -> Coq_regex_as_UCT.t -> t -> tree

                  val add : Coq_regex_as_UCT.t -> tree -> tree

                  val join : tree -> elt -> t -> t

                  val remove_min : tree -> elt -> t -> t * elt

                  val merge : tree -> tree -> tree

                  val remove : Coq_regex_as_UCT.t -> tree -> tree

                  val concat : tree -> tree -> tree

                  type triple = R.Defs.Coq_reFS.MSet.Raw.triple = { t_left : 
                                                                    t;
                                                                    t_in : 
                                                                    bool;
                                                                    t_right : 
                                                                    t }

                  val t_left : triple -> t

                  val t_in : triple -> bool

                  val t_right : triple -> t

                  val split : Coq_regex_as_UCT.t -> tree -> triple

                  val inter : tree -> tree -> tree

                  val diff : tree -> tree -> tree

                  val union : tree -> tree -> tree

                  val filter : (elt -> bool) -> tree -> tree

                  val partition : (elt -> bool) -> t -> t * t

                  val ltb_tree : Coq_regex_as_UCT.t -> tree -> bool

                  val gtb_tree : Coq_regex_as_UCT.t -> tree -> bool

                  val isok : tree -> bool

                  module MX :
                   sig
                    module OrderTac :
                     sig
                      module OTF :
                       sig
                        type t = Coq_regex_as_UCT.t

                        val compare :
                          Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t ->
                          comparison

                        val eq_dec :
                          Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                       end

                      module TO :
                       sig
                        type t = Coq_regex_as_UCT.t

                        val compare :
                          Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t ->
                          comparison

                        val eq_dec :
                          Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                       end
                     end

                    val eq_dec :
                      Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                    val lt_dec :
                      Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                    val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                   end

                  type coq_R_min_elt = R.Defs.Coq_reFS.MSet.Raw.coq_R_min_elt =
                  | R_min_elt_0 of tree
                  | R_min_elt_1 of tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree
                  | R_min_elt_2 of tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * elt option * coq_R_min_elt

                  type coq_R_max_elt = R.Defs.Coq_reFS.MSet.Raw.coq_R_max_elt =
                  | R_max_elt_0 of tree
                  | R_max_elt_1 of tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree
                  | R_max_elt_2 of tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * elt option * coq_R_max_elt

                  module L :
                   sig
                    module MO :
                     sig
                      module OrderTac :
                       sig
                        module OTF :
                         sig
                          type t = Coq_regex_as_UCT.t

                          val compare :
                            Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t ->
                            comparison

                          val eq_dec :
                            Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                         end

                        module TO :
                         sig
                          type t = Coq_regex_as_UCT.t

                          val compare :
                            Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t ->
                            comparison

                          val eq_dec :
                            Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                         end
                       end

                      val eq_dec :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                      val lt_dec :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                      val eqb :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                     end
                   end

                  val flatten_e : enumeration -> elt list

                  type coq_R_bal = R.Defs.Coq_reFS.MSet.Raw.coq_R_bal =
                  | R_bal_0 of t * Coq_regex_as_UCT.t * t
                  | R_bal_1 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * 
                     tree * Coq_regex_as_UCT.t * tree
                  | R_bal_2 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * 
                     tree * Coq_regex_as_UCT.t * tree
                  | R_bal_3 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * 
                     tree * Coq_regex_as_UCT.t * tree * Z_as_Int.t * 
                     tree * Coq_regex_as_UCT.t * tree
                  | R_bal_4 of t * Coq_regex_as_UCT.t * t
                  | R_bal_5 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * 
                     tree * Coq_regex_as_UCT.t * tree
                  | R_bal_6 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * 
                     tree * Coq_regex_as_UCT.t * tree
                  | R_bal_7 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * 
                     tree * Coq_regex_as_UCT.t * tree * Z_as_Int.t * 
                     tree * Coq_regex_as_UCT.t * tree
                  | R_bal_8 of t * Coq_regex_as_UCT.t * t

                  type coq_R_remove_min = R.Defs.Coq_reFS.MSet.Raw.coq_R_remove_min =
                  | R_remove_min_0 of tree * elt * t
                  | R_remove_min_1 of tree * elt * t * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * (t * elt)
                     * coq_R_remove_min * t * elt

                  type coq_R_merge = R.Defs.Coq_reFS.MSet.Raw.coq_R_merge =
                  | R_merge_0 of tree * tree
                  | R_merge_1 of tree * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree
                  | R_merge_2 of tree * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * t * elt

                  type coq_R_concat = R.Defs.Coq_reFS.MSet.Raw.coq_R_concat =
                  | R_concat_0 of tree * tree
                  | R_concat_1 of tree * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree
                  | R_concat_2 of tree * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * t * elt

                  type coq_R_inter = R.Defs.Coq_reFS.MSet.Raw.coq_R_inter =
                  | R_inter_0 of tree * tree
                  | R_inter_1 of tree * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree
                  | R_inter_2 of tree * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * t * bool * t * tree
                     * coq_R_inter * tree * coq_R_inter
                  | R_inter_3 of tree * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * t * bool * t * tree
                     * coq_R_inter * tree * coq_R_inter

                  type coq_R_diff = R.Defs.Coq_reFS.MSet.Raw.coq_R_diff =
                  | R_diff_0 of tree * tree
                  | R_diff_1 of tree * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree
                  | R_diff_2 of tree * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * t * bool * t * tree
                     * coq_R_diff * tree * coq_R_diff
                  | R_diff_3 of tree * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * t * bool * t * tree
                     * coq_R_diff * tree * coq_R_diff

                  type coq_R_union = R.Defs.Coq_reFS.MSet.Raw.coq_R_union =
                  | R_union_0 of tree * tree
                  | R_union_1 of tree * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree
                  | R_union_2 of tree * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * t * bool * t * tree
                     * coq_R_union * tree * coq_R_union
                 end

                module E :
                 sig
                  type t = Coq_regex_as_UCT.t

                  val compare :
                    Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> comparison

                  val eq_dec :
                    Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                 end

                type elt = Coq_regex_as_UCT.t

                type t_ =
                  Raw.t
                  (* singleton inductive, whose constructor was Mkt *)

                val this : t_ -> Raw.t

                type t = t_

                val mem : elt -> t -> bool

                val add : elt -> t -> t

                val remove : elt -> t -> t

                val singleton : elt -> t

                val union : t -> t -> t

                val inter : t -> t -> t

                val diff : t -> t -> t

                val equal : t -> t -> bool

                val subset : t -> t -> bool

                val empty : t

                val is_empty : t -> bool

                val elements : t -> elt list

                val choose : t -> elt option

                val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

                val cardinal : t -> nat

                val filter : (elt -> bool) -> t -> t

                val for_all : (elt -> bool) -> t -> bool

                val exists_ : (elt -> bool) -> t -> bool

                val partition : (elt -> bool) -> t -> t * t

                val eq_dec : t -> t -> bool

                val compare : t -> t -> comparison

                val min_elt : t -> elt option

                val max_elt : t -> elt option
               end

              type elt = Coq_regex_as_UCT.t

              type t = MSet.t

              val empty : t

              val is_empty : t -> bool

              val mem : elt -> t -> bool

              val add : elt -> t -> t

              val singleton : elt -> t

              val remove : elt -> t -> t

              val union : t -> t -> t

              val inter : t -> t -> t

              val diff : t -> t -> t

              val eq_dec : t -> t -> bool

              val equal : t -> t -> bool

              val subset : t -> t -> bool

              val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

              val for_all : (elt -> bool) -> t -> bool

              val exists_ : (elt -> bool) -> t -> bool

              val filter : (elt -> bool) -> t -> t

              val partition : (elt -> bool) -> t -> t * t

              val cardinal : t -> nat

              val elements : t -> elt list

              val choose : t -> elt option

              module MF :
               sig
                val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
               end

              val min_elt : t -> elt option

              val max_elt : t -> elt option

              val compare : t -> t -> t compare0

              module E :
               sig
                type t = Coq_regex_as_UCT.t

                val compare :
                  Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t ->
                  Coq_regex_as_UCT.t compare0

                val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
               end
             end

            module Coq_reFSF :
             sig
              val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
             end

            module Coq_reFM :
             sig
              module E :
               sig
                type t = Coq_regex_as_UCT.t

                val compare :
                  Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t ->
                  Coq_regex_as_UCT.t compare0

                val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
               end

              module Raw :
               sig
                type key = Coq_regex_as_UCT.t

                type 'elt tree = 'elt R.Defs.Coq_reFM.Raw.tree =
                | Leaf
                | Node of 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t

                val tree_rect :
                  'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
                  Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

                val tree_rec :
                  'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
                  Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

                val height : 'a1 tree -> Z_as_Int.t

                val cardinal : 'a1 tree -> nat

                val empty : 'a1 tree

                val is_empty : 'a1 tree -> bool

                val mem : Coq_regex_as_UCT.t -> 'a1 tree -> bool

                val find : Coq_regex_as_UCT.t -> 'a1 tree -> 'a1 option

                val create : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

                val assert_false :
                  'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

                val bal : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

                val add : key -> 'a1 -> 'a1 tree -> 'a1 tree

                val remove_min :
                  'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree * (key * 'a1)

                val merge : 'a1 tree -> 'a1 tree -> 'a1 tree

                val remove : Coq_regex_as_UCT.t -> 'a1 tree -> 'a1 tree

                val join : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

                type 'elt triple = 'elt R.Defs.Coq_reFM.Raw.triple = { 
                t_left : 'elt tree; t_opt : 'elt option; t_right : 'elt tree }

                val t_left : 'a1 triple -> 'a1 tree

                val t_opt : 'a1 triple -> 'a1 option

                val t_right : 'a1 triple -> 'a1 tree

                val split : Coq_regex_as_UCT.t -> 'a1 tree -> 'a1 triple

                val concat : 'a1 tree -> 'a1 tree -> 'a1 tree

                val elements_aux :
                  (key * 'a1) list -> 'a1 tree -> (key * 'a1) list

                val elements : 'a1 tree -> (key * 'a1) list

                val fold :
                  (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

                type 'elt enumeration = 'elt R.Defs.Coq_reFM.Raw.enumeration =
                | End
                | More of key * 'elt * 'elt tree * 'elt enumeration

                val enumeration_rect :
                  'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 ->
                  'a2) -> 'a1 enumeration -> 'a2

                val enumeration_rec :
                  'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 ->
                  'a2) -> 'a1 enumeration -> 'a2

                val cons : 'a1 tree -> 'a1 enumeration -> 'a1 enumeration

                val equal_more :
                  ('a1 -> 'a1 -> bool) -> Coq_regex_as_UCT.t -> 'a1 -> ('a1
                  enumeration -> bool) -> 'a1 enumeration -> bool

                val equal_cont :
                  ('a1 -> 'a1 -> bool) -> 'a1 tree -> ('a1 enumeration ->
                  bool) -> 'a1 enumeration -> bool

                val equal_end : 'a1 enumeration -> bool

                val equal :
                  ('a1 -> 'a1 -> bool) -> 'a1 tree -> 'a1 tree -> bool

                val map : ('a1 -> 'a2) -> 'a1 tree -> 'a2 tree

                val mapi : (key -> 'a1 -> 'a2) -> 'a1 tree -> 'a2 tree

                val map_option :
                  (key -> 'a1 -> 'a2 option) -> 'a1 tree -> 'a2 tree

                val map2_opt :
                  (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree ->
                  'a3 tree) -> ('a2 tree -> 'a3 tree) -> 'a1 tree -> 'a2 tree
                  -> 'a3 tree

                val map2 :
                  ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 tree -> 'a2
                  tree -> 'a3 tree

                module Proofs :
                 sig
                  module MX :
                   sig
                    module TO :
                     sig
                      type t = Coq_regex_as_UCT.t
                     end

                    module IsTO :
                     sig
                     end

                    module OrderTac :
                     sig
                     end

                    val eq_dec :
                      Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                    val lt_dec :
                      Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                    val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                   end

                  module PX :
                   sig
                    module MO :
                     sig
                      module TO :
                       sig
                        type t = Coq_regex_as_UCT.t
                       end

                      module IsTO :
                       sig
                       end

                      module OrderTac :
                       sig
                       end

                      val eq_dec :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                      val lt_dec :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                      val eqb :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                     end
                   end

                  module L :
                   sig
                    module MX :
                     sig
                      module TO :
                       sig
                        type t = Coq_regex_as_UCT.t
                       end

                      module IsTO :
                       sig
                       end

                      module OrderTac :
                       sig
                       end

                      val eq_dec :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                      val lt_dec :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                      val eqb :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                     end

                    module PX :
                     sig
                      module MO :
                       sig
                        module TO :
                         sig
                          type t = Coq_regex_as_UCT.t
                         end

                        module IsTO :
                         sig
                         end

                        module OrderTac :
                         sig
                         end

                        val eq_dec :
                          Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                        val lt_dec :
                          Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                        val eqb :
                          Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                       end
                     end

                    type key = Coq_regex_as_UCT.t

                    type 'elt t = (Coq_regex_as_UCT.t * 'elt) list

                    val empty : 'a1 t

                    val is_empty : 'a1 t -> bool

                    val mem : key -> 'a1 t -> bool

                    type 'elt coq_R_mem = 'elt R.Defs.Coq_reFM.Raw.Proofs.L.coq_R_mem =
                    | R_mem_0 of 'elt t
                    | R_mem_1 of 'elt t * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list
                    | R_mem_2 of 'elt t * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list
                    | R_mem_3 of 'elt t * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list * bool
                       * 'elt coq_R_mem

                    val coq_R_mem_rect :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2
                      -> 'a2) -> 'a1 t -> bool -> 'a1 coq_R_mem -> 'a2

                    val coq_R_mem_rec :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2
                      -> 'a2) -> 'a1 t -> bool -> 'a1 coq_R_mem -> 'a2

                    val mem_rect :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val mem_rec :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val coq_R_mem_correct :
                      key -> 'a1 t -> bool -> 'a1 coq_R_mem

                    val find : key -> 'a1 t -> 'a1 option

                    type 'elt coq_R_find = 'elt R.Defs.Coq_reFM.Raw.Proofs.L.coq_R_find =
                    | R_find_0 of 'elt t
                    | R_find_1 of 'elt t * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list
                    | R_find_2 of 'elt t * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list
                    | R_find_3 of 'elt t * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list * 'elt option
                       * 'elt coq_R_find

                    val coq_R_find_rect :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find
                      -> 'a2 -> 'a2) -> 'a1 t -> 'a1 option -> 'a1 coq_R_find
                      -> 'a2

                    val coq_R_find_rec :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find
                      -> 'a2 -> 'a2) -> 'a1 t -> 'a1 option -> 'a1 coq_R_find
                      -> 'a2

                    val find_rect :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val find_rec :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val coq_R_find_correct :
                      key -> 'a1 t -> 'a1 option -> 'a1 coq_R_find

                    val add : key -> 'a1 -> 'a1 t -> 'a1 t

                    type 'elt coq_R_add = 'elt R.Defs.Coq_reFM.Raw.Proofs.L.coq_R_add =
                    | R_add_0 of 'elt t
                    | R_add_1 of 'elt t * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list
                    | R_add_2 of 'elt t * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list
                    | R_add_3 of 'elt t * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list * 'elt t
                       * 'elt coq_R_add

                    val coq_R_add_rect :
                      key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_add -> 'a2
                      -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_add -> 'a2

                    val coq_R_add_rec :
                      key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_add -> 'a2
                      -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_add -> 'a2

                    val add_rect :
                      key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val add_rec :
                      key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val coq_R_add_correct :
                      key -> 'a1 -> 'a1 t -> 'a1 t -> 'a1 coq_R_add

                    val remove : key -> 'a1 t -> 'a1 t

                    type 'elt coq_R_remove = 'elt R.Defs.Coq_reFM.Raw.Proofs.L.coq_R_remove =
                    | R_remove_0 of 'elt t
                    | R_remove_1 of 'elt t * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list
                    | R_remove_2 of 'elt t * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list
                    | R_remove_3 of 'elt t * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list * 'elt t
                       * 'elt coq_R_remove

                    val coq_R_remove_rect :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_remove ->
                      'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove -> 'a2

                    val coq_R_remove_rec :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_remove ->
                      'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove -> 'a2

                    val remove_rect :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val remove_rec :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val coq_R_remove_correct :
                      key -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove

                    val elements : 'a1 t -> 'a1 t

                    val fold :
                      (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

                    type ('elt, 'a) coq_R_fold = ('elt, 'a) R.Defs.Coq_reFM.Raw.Proofs.L.coq_R_fold =
                    | R_fold_0 of 'elt t * 'a
                    | R_fold_1 of 'elt t * 'a * Coq_regex_as_UCT.t * 
                       'elt * (Coq_regex_as_UCT.t * 'elt) list * 'a
                       * ('elt, 'a) coq_R_fold

                    val coq_R_fold_rect :
                      (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ ->
                      'a3) -> ('a1 t -> 'a2 -> Coq_regex_as_UCT.t -> 'a1 ->
                      (Coq_regex_as_UCT.t * 'a1) list -> __ -> 'a2 -> ('a1,
                      'a2) coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a2
                      -> ('a1, 'a2) coq_R_fold -> 'a3

                    val coq_R_fold_rec :
                      (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ ->
                      'a3) -> ('a1 t -> 'a2 -> Coq_regex_as_UCT.t -> 'a1 ->
                      (Coq_regex_as_UCT.t * 'a1) list -> __ -> 'a2 -> ('a1,
                      'a2) coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a2
                      -> ('a1, 'a2) coq_R_fold -> 'a3

                    val fold_rect :
                      (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ ->
                      'a3) -> ('a1 t -> 'a2 -> Coq_regex_as_UCT.t -> 'a1 ->
                      (Coq_regex_as_UCT.t * 'a1) list -> __ -> 'a3 -> 'a3) ->
                      'a1 t -> 'a2 -> 'a3

                    val fold_rec :
                      (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ ->
                      'a3) -> ('a1 t -> 'a2 -> Coq_regex_as_UCT.t -> 'a1 ->
                      (Coq_regex_as_UCT.t * 'a1) list -> __ -> 'a3 -> 'a3) ->
                      'a1 t -> 'a2 -> 'a3

                    val coq_R_fold_correct :
                      (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2 ->
                      ('a1, 'a2) coq_R_fold

                    val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool

                    type 'elt coq_R_equal = 'elt R.Defs.Coq_reFM.Raw.Proofs.L.coq_R_equal =
                    | R_equal_0 of 'elt t * 'elt t
                    | R_equal_1 of 'elt t * 'elt t * Coq_regex_as_UCT.t
                       * 'elt * (Coq_regex_as_UCT.t * 'elt) list
                       * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list * bool
                       * 'elt coq_R_equal
                    | R_equal_2 of 'elt t * 'elt t * Coq_regex_as_UCT.t
                       * 'elt * (Coq_regex_as_UCT.t * 'elt) list
                       * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list
                       * Coq_regex_as_UCT.t compare0
                    | R_equal_3 of 'elt t * 'elt t * 'elt t * 'elt t

                    val coq_R_equal_rect :
                      ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                      'a2) -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                      (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> bool -> 'a1 coq_R_equal ->
                      'a2 -> 'a2) -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t ->
                      'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> Coq_regex_as_UCT.t compare0 -> __ -> __
                      -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t ->
                      __ -> __ -> 'a2) -> 'a1 t -> 'a1 t -> bool -> 'a1
                      coq_R_equal -> 'a2

                    val coq_R_equal_rec :
                      ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                      'a2) -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                      (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> bool -> 'a1 coq_R_equal ->
                      'a2 -> 'a2) -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t ->
                      'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> Coq_regex_as_UCT.t compare0 -> __ -> __
                      -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t ->
                      __ -> __ -> 'a2) -> 'a1 t -> 'a1 t -> bool -> 'a1
                      coq_R_equal -> 'a2

                    val equal_rect :
                      ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                      'a2) -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                      (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2 -> 'a2) -> ('a1 t -> 'a1
                      t -> Coq_regex_as_UCT.t -> 'a1 ->
                      (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> Coq_regex_as_UCT.t compare0 -> __ -> __
                      -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t ->
                      __ -> __ -> 'a2) -> 'a1 t -> 'a1 t -> 'a2

                    val equal_rec :
                      ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                      'a2) -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                      (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2 -> 'a2) -> ('a1 t -> 'a1
                      t -> Coq_regex_as_UCT.t -> 'a1 ->
                      (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> Coq_regex_as_UCT.t compare0 -> __ -> __
                      -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t ->
                      __ -> __ -> 'a2) -> 'a1 t -> 'a1 t -> 'a2

                    val coq_R_equal_correct :
                      ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool -> 'a1
                      coq_R_equal

                    val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

                    val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

                    val option_cons :
                      key -> 'a1 option -> (key * 'a1) list -> (key * 'a1)
                      list

                    val map2_l :
                      ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t ->
                      'a3 t

                    val map2_r :
                      ('a1 option -> 'a2 option -> 'a3 option) -> 'a2 t ->
                      'a3 t

                    val map2 :
                      ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t ->
                      'a2 t -> 'a3 t

                    val combine :
                      'a1 t -> 'a2 t -> ('a1 option * 'a2 option) t

                    val fold_right_pair :
                      ('a1 -> 'a2 -> 'a3 -> 'a3) -> ('a1 * 'a2) list -> 'a3
                      -> 'a3

                    val map2_alt :
                      ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t ->
                      'a2 t -> (key * 'a3) list

                    val at_least_one :
                      'a1 option -> 'a2 option -> ('a1 option * 'a2 option)
                      option

                    val at_least_one_then_f :
                      ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 option
                      -> 'a2 option -> 'a3 option
                   end

                  type 'elt coq_R_mem = 'elt R.Defs.Coq_reFM.Raw.Proofs.coq_R_mem =
                  | R_mem_0 of 'elt tree
                  | R_mem_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                     * Z_as_Int.t * bool * 'elt coq_R_mem
                  | R_mem_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                     * Z_as_Int.t
                  | R_mem_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                     * Z_as_Int.t * bool * 'elt coq_R_mem

                  val coq_R_mem_rect :
                    Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2)
                    -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 tree
                    -> bool -> 'a1 coq_R_mem -> 'a2

                  val coq_R_mem_rec :
                    Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2)
                    -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 tree
                    -> bool -> 'a1 coq_R_mem -> 'a2

                  type 'elt coq_R_find = 'elt R.Defs.Coq_reFM.Raw.Proofs.coq_R_find =
                  | R_find_0 of 'elt tree
                  | R_find_1 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'elt option * 'elt coq_R_find
                  | R_find_2 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t
                  | R_find_3 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'elt option * 'elt coq_R_find

                  val coq_R_find_rect :
                    Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2
                    -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
                    tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree
                    -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                    -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 ->
                    'a2) -> 'a1 tree -> 'a1 option -> 'a1 coq_R_find -> 'a2

                  val coq_R_find_rec :
                    Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2
                    -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
                    tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree
                    -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                    -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 ->
                    'a2) -> 'a1 tree -> 'a1 option -> 'a1 coq_R_find -> 'a2

                  type 'elt coq_R_bal = 'elt R.Defs.Coq_reFM.Raw.Proofs.coq_R_bal =
                  | R_bal_0 of 'elt tree * key * 'elt * 'elt tree
                  | R_bal_1 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                     * key * 'elt * 'elt tree * Z_as_Int.t
                  | R_bal_2 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                     * key * 'elt * 'elt tree * Z_as_Int.t
                  | R_bal_3 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                     * key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t
                  | R_bal_4 of 'elt tree * key * 'elt * 'elt tree
                  | R_bal_5 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                     * key * 'elt * 'elt tree * Z_as_Int.t
                  | R_bal_6 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                     * key * 'elt * 'elt tree * Z_as_Int.t
                  | R_bal_7 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                     * key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t
                  | R_bal_8 of 'elt tree * key * 'elt * 'elt tree

                  val coq_R_bal_rect :
                    ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ ->
                    'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
                    -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                    -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1
                    tree -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree
                    -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key
                    -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
                    -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 ->
                    'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key ->
                    'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2)
                    -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __
                    -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key ->
                    'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree ->
                    key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
                    'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
                    -> __ -> __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree
                    -> 'a1 tree -> 'a1 coq_R_bal -> 'a2

                  val coq_R_bal_rec :
                    ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ ->
                    'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
                    -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                    -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1
                    tree -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree
                    -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key
                    -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
                    -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 ->
                    'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key ->
                    'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2)
                    -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __
                    -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key ->
                    'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree ->
                    key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
                    'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
                    -> __ -> __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree
                    -> 'a1 tree -> 'a1 coq_R_bal -> 'a2

                  type 'elt coq_R_add = 'elt R.Defs.Coq_reFM.Raw.Proofs.coq_R_add =
                  | R_add_0 of 'elt tree
                  | R_add_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                     * Z_as_Int.t * 'elt tree * 'elt coq_R_add
                  | R_add_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                     * Z_as_Int.t
                  | R_add_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                     * Z_as_Int.t * 'elt tree * 'elt coq_R_add

                  val coq_R_add_rect :
                    key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key
                    -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
                    tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 tree -> 'a1
                    tree -> 'a1 coq_R_add -> 'a2

                  val coq_R_add_rec :
                    key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key
                    -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
                    tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 tree -> 'a1
                    tree -> 'a1 coq_R_add -> 'a2

                  type 'elt coq_R_remove_min = 'elt R.Defs.Coq_reFM.Raw.Proofs.coq_R_remove_min =
                  | R_remove_min_0 of 'elt tree * key * 'elt * 'elt tree
                  | R_remove_min_1 of 'elt tree * key * 'elt * 'elt tree
                     * 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t
                     * ('elt tree * (key * 'elt)) * 'elt coq_R_remove_min
                     * 'elt tree * (key * 'elt)

                  val coq_R_remove_min_rect :
                    ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1
                    tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1
                    -> 'a1 tree -> Z_as_Int.t -> __ -> ('a1
                    tree * (key * 'a1)) -> 'a1 coq_R_remove_min -> 'a2 -> 'a1
                    tree -> (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> key ->
                    'a1 -> 'a1 tree -> ('a1 tree * (key * 'a1)) -> 'a1
                    coq_R_remove_min -> 'a2

                  val coq_R_remove_min_rec :
                    ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1
                    tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1
                    -> 'a1 tree -> Z_as_Int.t -> __ -> ('a1
                    tree * (key * 'a1)) -> 'a1 coq_R_remove_min -> 'a2 -> 'a1
                    tree -> (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> key ->
                    'a1 -> 'a1 tree -> ('a1 tree * (key * 'a1)) -> 'a1
                    coq_R_remove_min -> 'a2

                  type 'elt coq_R_merge = 'elt R.Defs.Coq_reFM.Raw.Proofs.coq_R_merge =
                  | R_merge_0 of 'elt tree * 'elt tree
                  | R_merge_1 of 'elt tree * 'elt tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t
                  | R_merge_2 of 'elt tree * 'elt tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree
                     * (key * 'elt) * key * 'elt

                  val coq_R_merge_rect :
                    ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> (key * 'a1) -> __ -> key -> 'a1 -> __ -> 'a2) -> 'a1
                    tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_merge -> 'a2

                  val coq_R_merge_rec :
                    ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> (key * 'a1) -> __ -> key -> 'a1 -> __ -> 'a2) -> 'a1
                    tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_merge -> 'a2

                  type 'elt coq_R_remove = 'elt R.Defs.Coq_reFM.Raw.Proofs.coq_R_remove =
                  | R_remove_0 of 'elt tree
                  | R_remove_1 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'elt tree * 'elt coq_R_remove
                  | R_remove_2 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t
                  | R_remove_3 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'elt tree * 'elt coq_R_remove

                  val coq_R_remove_rect :
                    Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2
                    -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
                    tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree
                    -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                    -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 ->
                    'a2) -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_remove -> 'a2

                  val coq_R_remove_rec :
                    Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2
                    -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
                    tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree
                    -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                    -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 ->
                    'a2) -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_remove -> 'a2

                  type 'elt coq_R_concat = 'elt R.Defs.Coq_reFM.Raw.Proofs.coq_R_concat =
                  | R_concat_0 of 'elt tree * 'elt tree
                  | R_concat_1 of 'elt tree * 'elt tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t
                  | R_concat_2 of 'elt tree * 'elt tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree
                     * (key * 'elt)

                  val coq_R_concat_rect :
                    ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> 'a1 tree ->
                    'a1 tree -> 'a1 coq_R_concat -> 'a2

                  val coq_R_concat_rec :
                    ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> 'a1 tree ->
                    'a1 tree -> 'a1 coq_R_concat -> 'a2

                  type 'elt coq_R_split = 'elt R.Defs.Coq_reFM.Raw.Proofs.coq_R_split =
                  | R_split_0 of 'elt tree
                  | R_split_1 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'elt triple
                     * 'elt coq_R_split * 'elt tree * 'elt option * 'elt tree
                  | R_split_2 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t
                  | R_split_3 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'elt triple
                     * 'elt coq_R_split * 'elt tree * 'elt option * 'elt tree

                  val coq_R_split_rect :
                    Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2
                    -> 'a1 tree -> 'a1 option -> 'a1 tree -> __ -> 'a2) ->
                    ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree
                    -> 'a1 option -> 'a1 tree -> __ -> 'a2) -> 'a1 tree ->
                    'a1 triple -> 'a1 coq_R_split -> 'a2

                  val coq_R_split_rec :
                    Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2
                    -> 'a1 tree -> 'a1 option -> 'a1 tree -> __ -> 'a2) ->
                    ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree
                    -> 'a1 option -> 'a1 tree -> __ -> 'a2) -> 'a1 tree ->
                    'a1 triple -> 'a1 coq_R_split -> 'a2

                  type ('elt, 'x) coq_R_map_option = ('elt, 'x) R.Defs.Coq_reFM.Raw.Proofs.coq_R_map_option =
                  | R_map_option_0 of 'elt tree
                  | R_map_option_1 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'x * 'x tree
                     * ('elt, 'x) coq_R_map_option * 'x tree
                     * ('elt, 'x) coq_R_map_option
                  | R_map_option_2 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'x tree
                     * ('elt, 'x) coq_R_map_option * 'x tree
                     * ('elt, 'x) coq_R_map_option

                  val coq_R_map_option_rect :
                    (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) ->
                    ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> 'a2 -> __ -> 'a2 tree -> ('a1, 'a2)
                    coq_R_map_option -> 'a3 -> 'a2 tree -> ('a1, 'a2)
                    coq_R_map_option -> 'a3 -> 'a3) -> ('a1 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                    'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2
                    tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> 'a1
                    tree -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3

                  val coq_R_map_option_rec :
                    (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) ->
                    ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> 'a2 -> __ -> 'a2 tree -> ('a1, 'a2)
                    coq_R_map_option -> 'a3 -> 'a2 tree -> ('a1, 'a2)
                    coq_R_map_option -> 'a3 -> 'a3) -> ('a1 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                    'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2
                    tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> 'a1
                    tree -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3

                  type ('elt, 'x0, 'x) coq_R_map2_opt = ('elt, 'x0, 'x) R.Defs.Coq_reFM.Raw.Proofs.coq_R_map2_opt =
                  | R_map2_opt_0 of 'elt tree * 'x0 tree
                  | R_map2_opt_1 of 'elt tree * 'x0 tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t
                  | R_map2_opt_2 of 'elt tree * 'x0 tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t * 'x0 tree * 
                     key * 'x0 * 'x0 tree * Z_as_Int.t * 'x0 tree
                     * 'x0 option * 'x0 tree * 'x * 'x tree
                     * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
                     * ('elt, 'x0, 'x) coq_R_map2_opt
                  | R_map2_opt_3 of 'elt tree * 'x0 tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t * 'x0 tree * 
                     key * 'x0 * 'x0 tree * Z_as_Int.t * 'x0 tree
                     * 'x0 option * 'x0 tree * 'x tree
                     * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
                     * ('elt, 'x0, 'x) coq_R_map2_opt

                  val coq_R_map2_opt_rect :
                    (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree ->
                    'a3 tree) -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2
                    tree -> __ -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                    'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1
                    -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 tree -> key -> 'a2
                    -> 'a2 tree -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2 option
                    -> 'a2 tree -> __ -> 'a3 -> __ -> 'a3 tree -> ('a1, 'a2,
                    'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
                    coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree ->
                    'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    'a2 tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ ->
                    'a2 tree -> 'a2 option -> 'a2 tree -> __ -> __ -> 'a3
                    tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree
                    -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1
                    tree -> 'a2 tree -> 'a3 tree -> ('a1, 'a2, 'a3)
                    coq_R_map2_opt -> 'a4

                  val coq_R_map2_opt_rec :
                    (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree ->
                    'a3 tree) -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2
                    tree -> __ -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                    'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1
                    -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 tree -> key -> 'a2
                    -> 'a2 tree -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2 option
                    -> 'a2 tree -> __ -> 'a3 -> __ -> 'a3 tree -> ('a1, 'a2,
                    'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
                    coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree ->
                    'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    'a2 tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ ->
                    'a2 tree -> 'a2 option -> 'a2 tree -> __ -> __ -> 'a3
                    tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree
                    -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1
                    tree -> 'a2 tree -> 'a3 tree -> ('a1, 'a2, 'a3)
                    coq_R_map2_opt -> 'a4

                  val fold' :
                    (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

                  val flatten_e : 'a1 enumeration -> (key * 'a1) list
                 end
               end

              type 'elt bst =
                'elt Raw.tree
                (* singleton inductive, whose constructor was Bst *)

              val this : 'a1 bst -> 'a1 Raw.tree

              type 'elt t = 'elt bst

              type key = Coq_regex_as_UCT.t

              val empty : 'a1 t

              val is_empty : 'a1 t -> bool

              val add : key -> 'a1 -> 'a1 t -> 'a1 t

              val remove : key -> 'a1 t -> 'a1 t

              val mem : key -> 'a1 t -> bool

              val find : key -> 'a1 t -> 'a1 option

              val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

              val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

              val map2 :
                ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t ->
                'a3 t

              val elements : 'a1 t -> (key * 'a1) list

              val cardinal : 'a1 t -> nat

              val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

              val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool
             end

            module Coq_reFMF :
             sig
              val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

              val coq_In_dec : 'a1 Coq_reFM.t -> Coq_reFM.key -> bool
             end

            module MatchSpec :
             sig
             end

            module MatchSpecLemmas :
             sig
             end

            module Notations :
             sig
             end

            module Helpers :
             sig
              val coq_Plus : Regexes.regex -> Regexes.regex

              val coq_IterUnion : Regexes.regex list -> Regexes.regex

              val coq_IterApp : Regexes.regex list -> Regexes.regex

              val coq_Optional : Regexes.regex -> Regexes.regex

              val coq_REString : Strings.coq_String -> Regexes.regex
             end
           end

          module Sigma_as_UOT :
           sig
            type t = R.Defs.T_as_UCT.t

            val compare : t -> t -> t compare0

            val eq_dec : t -> t -> bool
           end

          module Coq_regex_as_UOT :
           sig
            type t = R.Defs.Coq_regex_as_UCT.t

            val compare : t -> t -> t compare0

            val eq_dec : t -> t -> bool
           end

          module Coq_pair_as_UOT :
           sig
            module FA :
             sig
             end

            module FB :
             sig
             end

            type t = R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t

            val compare :
              t -> t -> (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t)
              compare0

            val eq_dec : t -> t -> bool
           end

          module FM :
           sig
            module E :
             sig
              type t = R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t

              val compare :
                (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
                (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
                (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) compare0

              val eq_dec :
                (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
                (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> bool
             end

            module Raw :
             sig
              type key = R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t

              type 'elt tree =
              | Leaf
              | Node of 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t

              val tree_rect :
                'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
                Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

              val tree_rec :
                'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
                Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

              val height : 'a1 tree -> Z_as_Int.t

              val cardinal : 'a1 tree -> nat

              val empty : 'a1 tree

              val is_empty : 'a1 tree -> bool

              val mem :
                (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 tree
                -> bool

              val find :
                (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 tree
                -> 'a1 option

              val create : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

              val assert_false :
                'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

              val bal : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

              val add : key -> 'a1 -> 'a1 tree -> 'a1 tree

              val remove_min :
                'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree * (key * 'a1)

              val merge : 'a1 tree -> 'a1 tree -> 'a1 tree

              val remove :
                (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 tree
                -> 'a1 tree

              val join : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

              type 'elt triple = { t_left : 'elt tree; t_opt : 'elt option;
                                   t_right : 'elt tree }

              val t_left : 'a1 triple -> 'a1 tree

              val t_opt : 'a1 triple -> 'a1 option

              val t_right : 'a1 triple -> 'a1 tree

              val split :
                (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 tree
                -> 'a1 triple

              val concat : 'a1 tree -> 'a1 tree -> 'a1 tree

              val elements_aux :
                (key * 'a1) list -> 'a1 tree -> (key * 'a1) list

              val elements : 'a1 tree -> (key * 'a1) list

              val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

              type 'elt enumeration =
              | End
              | More of key * 'elt * 'elt tree * 'elt enumeration

              val enumeration_rect :
                'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 ->
                'a2) -> 'a1 enumeration -> 'a2

              val enumeration_rec :
                'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 ->
                'a2) -> 'a1 enumeration -> 'a2

              val cons : 'a1 tree -> 'a1 enumeration -> 'a1 enumeration

              val equal_more :
                ('a1 -> 'a1 -> bool) ->
                (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                ('a1 enumeration -> bool) -> 'a1 enumeration -> bool

              val equal_cont :
                ('a1 -> 'a1 -> bool) -> 'a1 tree -> ('a1 enumeration -> bool)
                -> 'a1 enumeration -> bool

              val equal_end : 'a1 enumeration -> bool

              val equal : ('a1 -> 'a1 -> bool) -> 'a1 tree -> 'a1 tree -> bool

              val map : ('a1 -> 'a2) -> 'a1 tree -> 'a2 tree

              val mapi : (key -> 'a1 -> 'a2) -> 'a1 tree -> 'a2 tree

              val map_option :
                (key -> 'a1 -> 'a2 option) -> 'a1 tree -> 'a2 tree

              val map2_opt :
                (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3
                tree) -> ('a2 tree -> 'a3 tree) -> 'a1 tree -> 'a2 tree ->
                'a3 tree

              val map2 :
                ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 tree -> 'a2
                tree -> 'a3 tree

              module Proofs :
               sig
                module MX :
                 sig
                  module TO :
                   sig
                    type t = R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t
                   end

                  module IsTO :
                   sig
                   end

                  module OrderTac :
                   sig
                   end

                  val eq_dec :
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> bool

                  val lt_dec :
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> bool

                  val eqb :
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> bool
                 end

                module PX :
                 sig
                  module MO :
                   sig
                    module TO :
                     sig
                      type t = R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t
                     end

                    module IsTO :
                     sig
                     end

                    module OrderTac :
                     sig
                     end

                    val eq_dec :
                      (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
                      (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> bool

                    val lt_dec :
                      (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
                      (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> bool

                    val eqb :
                      (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
                      (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> bool
                   end
                 end

                module L :
                 sig
                  module MX :
                   sig
                    module TO :
                     sig
                      type t = R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t
                     end

                    module IsTO :
                     sig
                     end

                    module OrderTac :
                     sig
                     end

                    val eq_dec :
                      (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
                      (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> bool

                    val lt_dec :
                      (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
                      (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> bool

                    val eqb :
                      (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
                      (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> bool
                   end

                  module PX :
                   sig
                    module MO :
                     sig
                      module TO :
                       sig
                        type t = R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t
                       end

                      module IsTO :
                       sig
                       end

                      module OrderTac :
                       sig
                       end

                      val eq_dec :
                        (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
                        (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
                        bool

                      val lt_dec :
                        (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
                        (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
                        bool

                      val eqb :
                        (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
                        (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
                        bool
                     end
                   end

                  type key = R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t

                  type 'elt t =
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt)
                    list

                  val empty : 'a1 t

                  val is_empty : 'a1 t -> bool

                  val mem : key -> 'a1 t -> bool

                  type 'elt coq_R_mem =
                  | R_mem_0 of 'elt t
                  | R_mem_1 of 'elt t
                     * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 
                     'elt
                     * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt)
                       list
                  | R_mem_2 of 'elt t
                     * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 
                     'elt
                     * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt)
                       list
                  | R_mem_3 of 'elt t
                     * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 
                     'elt
                     * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt)
                       list * bool * 'elt coq_R_mem

                  val coq_R_mem_rect :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 ->
                    'a2) -> 'a1 t -> bool -> 'a1 coq_R_mem -> 'a2

                  val coq_R_mem_rec :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 ->
                    'a2) -> 'a1 t -> bool -> 'a1 coq_R_mem -> 'a2

                  val mem_rect :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                  val mem_rec :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                  val coq_R_mem_correct :
                    key -> 'a1 t -> bool -> 'a1 coq_R_mem

                  val find : key -> 'a1 t -> 'a1 option

                  type 'elt coq_R_find =
                  | R_find_0 of 'elt t
                  | R_find_1 of 'elt t
                     * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 
                     'elt
                     * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt)
                       list
                  | R_find_2 of 'elt t
                     * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 
                     'elt
                     * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt)
                       list
                  | R_find_3 of 'elt t
                     * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 
                     'elt
                     * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt)
                       list * 'elt option * 'elt coq_R_find

                  val coq_R_find_rect :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find ->
                    'a2 -> 'a2) -> 'a1 t -> 'a1 option -> 'a1 coq_R_find ->
                    'a2

                  val coq_R_find_rec :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find ->
                    'a2 -> 'a2) -> 'a1 t -> 'a1 option -> 'a1 coq_R_find ->
                    'a2

                  val find_rect :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                  val find_rec :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                  val coq_R_find_correct :
                    key -> 'a1 t -> 'a1 option -> 'a1 coq_R_find

                  val add : key -> 'a1 -> 'a1 t -> 'a1 t

                  type 'elt coq_R_add =
                  | R_add_0 of 'elt t
                  | R_add_1 of 'elt t
                     * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 
                     'elt
                     * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt)
                       list
                  | R_add_2 of 'elt t
                     * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 
                     'elt
                     * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt)
                       list
                  | R_add_3 of 'elt t
                     * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 
                     'elt
                     * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt)
                       list * 'elt t * 'elt coq_R_add

                  val coq_R_add_rect :
                    key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_add -> 'a2
                    -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_add -> 'a2

                  val coq_R_add_rec :
                    key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_add -> 'a2
                    -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_add -> 'a2

                  val add_rect :
                    key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                  val add_rec :
                    key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                  val coq_R_add_correct :
                    key -> 'a1 -> 'a1 t -> 'a1 t -> 'a1 coq_R_add

                  val remove : key -> 'a1 t -> 'a1 t

                  type 'elt coq_R_remove =
                  | R_remove_0 of 'elt t
                  | R_remove_1 of 'elt t
                     * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 
                     'elt
                     * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt)
                       list
                  | R_remove_2 of 'elt t
                     * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 
                     'elt
                     * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt)
                       list
                  | R_remove_3 of 'elt t
                     * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 
                     'elt
                     * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt)
                       list * 'elt t * 'elt coq_R_remove

                  val coq_R_remove_rect :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_remove ->
                    'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove -> 'a2

                  val coq_R_remove_rec :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_remove ->
                    'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove -> 'a2

                  val remove_rect :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                  val remove_rec :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                  val coq_R_remove_correct :
                    key -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove

                  val elements : 'a1 t -> 'a1 t

                  val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

                  type ('elt, 'a) coq_R_fold =
                  | R_fold_0 of 'elt t * 'a
                  | R_fold_1 of 'elt t * 'a
                     * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 
                     'elt
                     * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt)
                       list * 'a * ('elt, 'a) coq_R_fold

                  val coq_R_fold_rect :
                    (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3)
                    -> ('a1 t -> 'a2 ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> 'a2 -> ('a1, 'a2) coq_R_fold -> 'a3 -> 'a3)
                    -> 'a1 t -> 'a2 -> 'a2 -> ('a1, 'a2) coq_R_fold -> 'a3

                  val coq_R_fold_rec :
                    (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3)
                    -> ('a1 t -> 'a2 ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> 'a2 -> ('a1, 'a2) coq_R_fold -> 'a3 -> 'a3)
                    -> 'a1 t -> 'a2 -> 'a2 -> ('a1, 'a2) coq_R_fold -> 'a3

                  val fold_rect :
                    (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3)
                    -> ('a1 t -> 'a2 ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a3

                  val fold_rec :
                    (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3)
                    -> ('a1 t -> 'a2 ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a3

                  val coq_R_fold_correct :
                    (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2 ->
                    ('a1, 'a2) coq_R_fold

                  val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool

                  type 'elt coq_R_equal =
                  | R_equal_0 of 'elt t * 'elt t
                  | R_equal_1 of 'elt t * 'elt t
                     * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 
                     'elt
                     * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt)
                       list * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t)
                     * 'elt
                     * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt)
                       list * bool * 'elt coq_R_equal
                  | R_equal_2 of 'elt t * 'elt t
                     * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 
                     'elt
                     * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt)
                       list * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t)
                     * 'elt
                     * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt)
                       list
                     * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t)
                       compare0
                  | R_equal_3 of 'elt t * 'elt t * 'elt t * 'elt t

                  val coq_R_equal_rect :
                    ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                    'a2) -> ('a1 t -> 'a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> bool -> 'a1 coq_R_equal -> 'a2
                    -> 'a2) -> ('a1 t -> 'a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) compare0
                    -> __ -> __ -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ ->
                    'a1 t -> __ -> __ -> 'a2) -> 'a1 t -> 'a1 t -> bool ->
                    'a1 coq_R_equal -> 'a2

                  val coq_R_equal_rec :
                    ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                    'a2) -> ('a1 t -> 'a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> bool -> 'a1 coq_R_equal -> 'a2
                    -> 'a2) -> ('a1 t -> 'a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) compare0
                    -> __ -> __ -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ ->
                    'a1 t -> __ -> __ -> 'a2) -> 'a1 t -> 'a1 t -> bool ->
                    'a1 coq_R_equal -> 'a2

                  val equal_rect :
                    ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                    'a2) -> ('a1 t -> 'a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t
                    -> (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1
                    ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) compare0
                    -> __ -> __ -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ ->
                    'a1 t -> __ -> __ -> 'a2) -> 'a1 t -> 'a1 t -> 'a2

                  val equal_rec :
                    ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                    'a2) -> ('a1 t -> 'a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t
                    -> (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1
                    ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) compare0
                    -> __ -> __ -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ ->
                    'a1 t -> __ -> __ -> 'a2) -> 'a1 t -> 'a1 t -> 'a2

                  val coq_R_equal_correct :
                    ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool -> 'a1
                    coq_R_equal

                  val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

                  val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

                  val option_cons :
                    key -> 'a1 option -> (key * 'a1) list -> (key * 'a1) list

                  val map2_l :
                    ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a3 t

                  val map2_r :
                    ('a1 option -> 'a2 option -> 'a3 option) -> 'a2 t -> 'a3 t

                  val map2 :
                    ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2
                    t -> 'a3 t

                  val combine : 'a1 t -> 'a2 t -> ('a1 option * 'a2 option) t

                  val fold_right_pair :
                    ('a1 -> 'a2 -> 'a3 -> 'a3) -> ('a1 * 'a2) list -> 'a3 ->
                    'a3

                  val map2_alt :
                    ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2
                    t -> (key * 'a3) list

                  val at_least_one :
                    'a1 option -> 'a2 option -> ('a1 option * 'a2 option)
                    option

                  val at_least_one_then_f :
                    ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 option ->
                    'a2 option -> 'a3 option
                 end

                type 'elt coq_R_mem =
                | R_mem_0 of 'elt tree
                | R_mem_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t * bool * 'elt coq_R_mem
                | R_mem_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t
                | R_mem_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t * bool * 'elt coq_R_mem

                val coq_R_mem_rect :
                  (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> ('a1
                  tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
                  -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> bool -> 'a1
                  coq_R_mem -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree -> key ->
                  'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) ->
                  ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem ->
                  'a2 -> 'a2) -> 'a1 tree -> bool -> 'a1 coq_R_mem -> 'a2

                val coq_R_mem_rec :
                  (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> ('a1
                  tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
                  -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> bool -> 'a1
                  coq_R_mem -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree -> key ->
                  'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) ->
                  ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem ->
                  'a2 -> 'a2) -> 'a1 tree -> bool -> 'a1 coq_R_mem -> 'a2

                type 'elt coq_R_find =
                | R_find_0 of 'elt tree
                | R_find_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t * 'elt option * 'elt coq_R_find
                | R_find_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t
                | R_find_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t * 'elt option * 'elt coq_R_find

                val coq_R_find_rect :
                  (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> ('a1
                  tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
                  -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 option
                  -> 'a1 coq_R_find -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree
                  -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __
                  -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree
                  -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 option -> 'a1
                  coq_R_find -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 option -> 'a1
                  coq_R_find -> 'a2

                val coq_R_find_rec :
                  (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> ('a1
                  tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
                  -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 option
                  -> 'a1 coq_R_find -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree
                  -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __
                  -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree
                  -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 option -> 'a1
                  coq_R_find -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 option -> 'a1
                  coq_R_find -> 'a2

                type 'elt coq_R_bal =
                | R_bal_0 of 'elt tree * key * 'elt * 'elt tree
                | R_bal_1 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                   * key * 'elt * 'elt tree * Z_as_Int.t
                | R_bal_2 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                   * key * 'elt * 'elt tree * Z_as_Int.t
                | R_bal_3 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                   * key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * 
                   key * 'elt * 'elt tree * Z_as_Int.t
                | R_bal_4 of 'elt tree * key * 'elt * 'elt tree
                | R_bal_5 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                   * key * 'elt * 'elt tree * Z_as_Int.t
                | R_bal_6 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                   * key * 'elt * 'elt tree * Z_as_Int.t
                | R_bal_7 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                   * key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * 
                   key * 'elt * 'elt tree * Z_as_Int.t
                | R_bal_8 of 'elt tree * key * 'elt * 'elt tree

                val coq_R_bal_rect :
                  ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ ->
                  'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ ->
                  'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                  __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree ->
                  __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree ->
                  key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key ->
                  'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree
                  -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2) ->
                  ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __
                  -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __
                  -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key ->
                  'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key
                  -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> __ ->
                  'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ ->
                  __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 ->
                  'a1 tree -> Z_as_Int.t -> __ -> 'a2) -> ('a1 tree -> key ->
                  'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a2) -> 'a1 tree
                  -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_bal ->
                  'a2

                val coq_R_bal_rec :
                  ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ ->
                  'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ ->
                  'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                  __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree ->
                  __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree ->
                  key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key ->
                  'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree
                  -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2) ->
                  ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __
                  -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __
                  -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key ->
                  'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key
                  -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> __ ->
                  'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ ->
                  __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 ->
                  'a1 tree -> Z_as_Int.t -> __ -> 'a2) -> ('a1 tree -> key ->
                  'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a2) -> 'a1 tree
                  -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_bal ->
                  'a2

                type 'elt coq_R_add =
                | R_add_0 of 'elt tree
                | R_add_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t * 'elt tree * 'elt coq_R_add
                | R_add_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t
                | R_add_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t * 'elt tree * 'elt coq_R_add

                val coq_R_add_rect :
                  key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                  __ -> 'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1 tree
                  -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                  -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
                  -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree ->
                  'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1
                  coq_R_add -> 'a2

                val coq_R_add_rec :
                  key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                  __ -> 'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1 tree
                  -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                  -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
                  -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree ->
                  'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1
                  coq_R_add -> 'a2

                type 'elt coq_R_remove_min =
                | R_remove_min_0 of 'elt tree * key * 'elt * 'elt tree
                | R_remove_min_1 of 'elt tree * key * 'elt * 'elt tree
                   * 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t
                   * ('elt tree * (key * 'elt)) * 'elt coq_R_remove_min
                   * 'elt tree * (key * 'elt)

                val coq_R_remove_min_rect :
                  ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1
                  tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1 ->
                  'a1 tree -> Z_as_Int.t -> __ -> ('a1 tree * (key * 'a1)) ->
                  'a1 coq_R_remove_min -> 'a2 -> 'a1 tree -> (key * 'a1) ->
                  __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> ('a1
                  tree * (key * 'a1)) -> 'a1 coq_R_remove_min -> 'a2

                val coq_R_remove_min_rec :
                  ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1
                  tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1 ->
                  'a1 tree -> Z_as_Int.t -> __ -> ('a1 tree * (key * 'a1)) ->
                  'a1 coq_R_remove_min -> 'a2 -> 'a1 tree -> (key * 'a1) ->
                  __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> ('a1
                  tree * (key * 'a1)) -> 'a1 coq_R_remove_min -> 'a2

                type 'elt coq_R_merge =
                | R_merge_0 of 'elt tree * 'elt tree
                | R_merge_1 of 'elt tree * 'elt tree * 'elt tree * key * 
                   'elt * 'elt tree * Z_as_Int.t
                | R_merge_2 of 'elt tree * 'elt tree * 'elt tree * key * 
                   'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 
                   'elt * 'elt tree * Z_as_Int.t * 'elt tree * (key * 'elt)
                   * key * 'elt

                val coq_R_merge_rect :
                  ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
                  __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree ->
                  (key * 'a1) -> __ -> key -> 'a1 -> __ -> 'a2) -> 'a1 tree
                  -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_merge -> 'a2

                val coq_R_merge_rec :
                  ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
                  __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree ->
                  (key * 'a1) -> __ -> key -> 'a1 -> __ -> 'a2) -> 'a1 tree
                  -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_merge -> 'a2

                type 'elt coq_R_remove =
                | R_remove_0 of 'elt tree
                | R_remove_1 of 'elt tree * 'elt tree * key * 'elt
                   * 'elt tree * Z_as_Int.t * 'elt tree * 'elt coq_R_remove
                | R_remove_2 of 'elt tree * 'elt tree * key * 'elt
                   * 'elt tree * Z_as_Int.t
                | R_remove_3 of 'elt tree * 'elt tree * key * 'elt
                   * 'elt tree * Z_as_Int.t * 'elt tree * 'elt coq_R_remove

                val coq_R_remove_rect :
                  (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> ('a1
                  tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
                  -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree ->
                  'a1 coq_R_remove -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
                  'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> 'a1
                  coq_R_remove -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1
                  coq_R_remove -> 'a2

                val coq_R_remove_rec :
                  (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> ('a1
                  tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
                  -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree ->
                  'a1 coq_R_remove -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
                  'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> 'a1
                  coq_R_remove -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1
                  coq_R_remove -> 'a2

                type 'elt coq_R_concat =
                | R_concat_0 of 'elt tree * 'elt tree
                | R_concat_1 of 'elt tree * 'elt tree * 'elt tree * key
                   * 'elt * 'elt tree * Z_as_Int.t
                | R_concat_2 of 'elt tree * 'elt tree * 'elt tree * key
                   * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 
                   'elt * 'elt tree * Z_as_Int.t * 'elt tree * (key * 'elt)

                val coq_R_concat_rect :
                  ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
                  __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree ->
                  (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1
                  tree -> 'a1 coq_R_concat -> 'a2

                val coq_R_concat_rec :
                  ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
                  __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree ->
                  (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1
                  tree -> 'a1 coq_R_concat -> 'a2

                type 'elt coq_R_split =
                | R_split_0 of 'elt tree
                | R_split_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t * 'elt triple * 'elt coq_R_split * 'elt tree
                   * 'elt option * 'elt tree
                | R_split_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t
                | R_split_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t * 'elt triple * 'elt coq_R_split * 'elt tree
                   * 'elt option * 'elt tree

                val coq_R_split_rect :
                  (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> ('a1
                  tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
                  -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 triple
                  -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option -> 'a1
                  tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
                  -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1
                  tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
                  __ -> __ -> __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 ->
                  'a1 tree -> 'a1 option -> 'a1 tree -> __ -> 'a2) -> 'a1
                  tree -> 'a1 triple -> 'a1 coq_R_split -> 'a2

                val coq_R_split_rec :
                  (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> ('a1
                  tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
                  -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 triple
                  -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option -> 'a1
                  tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
                  -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1
                  tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
                  __ -> __ -> __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 ->
                  'a1 tree -> 'a1 option -> 'a1 tree -> __ -> 'a2) -> 'a1
                  tree -> 'a1 triple -> 'a1 coq_R_split -> 'a2

                type ('elt, 'x) coq_R_map_option =
                | R_map_option_0 of 'elt tree
                | R_map_option_1 of 'elt tree * 'elt tree * key * 'elt
                   * 'elt tree * Z_as_Int.t * 'x * 'x tree
                   * ('elt, 'x) coq_R_map_option * 'x tree
                   * ('elt, 'x) coq_R_map_option
                | R_map_option_2 of 'elt tree * 'elt tree * key * 'elt
                   * 'elt tree * Z_as_Int.t * 'x tree
                   * ('elt, 'x) coq_R_map_option * 'x tree
                   * ('elt, 'x) coq_R_map_option

                val coq_R_map_option_rect :
                  (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) ->
                  ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> 'a2 -> __ -> 'a2 tree -> ('a1, 'a2)
                  coq_R_map_option -> 'a3 -> 'a2 tree -> ('a1, 'a2)
                  coq_R_map_option -> 'a3 -> 'a3) -> ('a1 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a2
                  tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2 tree ->
                  ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> 'a1 tree ->
                  'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3

                val coq_R_map_option_rec :
                  (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) ->
                  ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> 'a2 -> __ -> 'a2 tree -> ('a1, 'a2)
                  coq_R_map_option -> 'a3 -> 'a2 tree -> ('a1, 'a2)
                  coq_R_map_option -> 'a3 -> 'a3) -> ('a1 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a2
                  tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2 tree ->
                  ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> 'a1 tree ->
                  'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3

                type ('elt, 'x0, 'x) coq_R_map2_opt =
                | R_map2_opt_0 of 'elt tree * 'x0 tree
                | R_map2_opt_1 of 'elt tree * 'x0 tree * 'elt tree * 
                   key * 'elt * 'elt tree * Z_as_Int.t
                | R_map2_opt_2 of 'elt tree * 'x0 tree * 'elt tree * 
                   key * 'elt * 'elt tree * Z_as_Int.t * 'x0 tree * key * 
                   'x0 * 'x0 tree * Z_as_Int.t * 'x0 tree * 'x0 option
                   * 'x0 tree * 'x * 'x tree * ('elt, 'x0, 'x) coq_R_map2_opt
                   * 'x tree * ('elt, 'x0, 'x) coq_R_map2_opt
                | R_map2_opt_3 of 'elt tree * 'x0 tree * 'elt tree * 
                   key * 'elt * 'elt tree * Z_as_Int.t * 'x0 tree * key * 
                   'x0 * 'x0 tree * Z_as_Int.t * 'x0 tree * 'x0 option
                   * 'x0 tree * 'x tree * ('elt, 'x0, 'x) coq_R_map2_opt
                   * 'x tree * ('elt, 'x0, 'x) coq_R_map2_opt

                val coq_R_map2_opt_rect :
                  (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree ->
                  'a3 tree) -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2
                  tree -> __ -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a4) ->
                  ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree
                  -> Z_as_Int.t -> __ -> 'a2 tree -> key -> 'a2 -> 'a2 tree
                  -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2 option -> 'a2 tree
                  -> __ -> 'a3 -> __ -> 'a3 tree -> ('a1, 'a2, 'a3)
                  coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
                  coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree ->
                  'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                  'a2 tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ ->
                  'a2 tree -> 'a2 option -> 'a2 tree -> __ -> __ -> 'a3 tree
                  -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree ->
                  ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1 tree
                  -> 'a2 tree -> 'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt
                  -> 'a4

                val coq_R_map2_opt_rec :
                  (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree ->
                  'a3 tree) -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2
                  tree -> __ -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a4) ->
                  ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree
                  -> Z_as_Int.t -> __ -> 'a2 tree -> key -> 'a2 -> 'a2 tree
                  -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2 option -> 'a2 tree
                  -> __ -> 'a3 -> __ -> 'a3 tree -> ('a1, 'a2, 'a3)
                  coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
                  coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree ->
                  'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                  'a2 tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ ->
                  'a2 tree -> 'a2 option -> 'a2 tree -> __ -> __ -> 'a3 tree
                  -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree ->
                  ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1 tree
                  -> 'a2 tree -> 'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt
                  -> 'a4

                val fold' :
                  (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

                val flatten_e : 'a1 enumeration -> (key * 'a1) list
               end
             end

            type 'elt bst =
              'elt Raw.tree
              (* singleton inductive, whose constructor was Bst *)

            val this : 'a1 bst -> 'a1 Raw.tree

            type 'elt t = 'elt bst

            type key = R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t

            val empty : 'a1 t

            val is_empty : 'a1 t -> bool

            val add : key -> 'a1 -> 'a1 t -> 'a1 t

            val remove : key -> 'a1 t -> 'a1 t

            val mem : key -> 'a1 t -> bool

            val find : key -> 'a1 t -> 'a1 option

            val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

            val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

            val map2 :
              ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t ->
              'a3 t

            val elements : 'a1 t -> (key * 'a1) list

            val cardinal : 'a1 t -> nat

            val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

            val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool
           end

          module FMF :
           sig
            val eqb :
              (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
              (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> bool

            val coq_In_dec : 'a1 FM.t -> FM.key -> bool
           end

          module Coq_reFS :
           sig
            module X' :
             sig
              type t = R.Defs.Coq_regex_as_UCT.t

              val eq_dec :
                R.Defs.Coq_regex_as_UCT.t -> R.Defs.Coq_regex_as_UCT.t -> bool

              val compare :
                R.Defs.Coq_regex_as_UCT.t -> R.Defs.Coq_regex_as_UCT.t ->
                comparison
             end

            module MSet :
             sig
              module Raw :
               sig
                type elt = R.Defs.Coq_regex_as_UCT.t

                type tree = R.Defs.Coq_reFS.MSet.Raw.tree =
                | Leaf
                | Node of Z_as_Int.t * tree * R.Defs.Coq_regex_as_UCT.t * tree

                val empty : tree

                val is_empty : tree -> bool

                val mem : R.Defs.Coq_regex_as_UCT.t -> tree -> bool

                val min_elt : tree -> elt option

                val max_elt : tree -> elt option

                val choose : tree -> elt option

                val fold : (elt -> 'a1 -> 'a1) -> tree -> 'a1 -> 'a1

                val elements_aux :
                  R.Defs.Coq_regex_as_UCT.t list -> tree ->
                  R.Defs.Coq_regex_as_UCT.t list

                val elements : tree -> R.Defs.Coq_regex_as_UCT.t list

                val rev_elements_aux :
                  R.Defs.Coq_regex_as_UCT.t list -> tree ->
                  R.Defs.Coq_regex_as_UCT.t list

                val rev_elements : tree -> R.Defs.Coq_regex_as_UCT.t list

                val cardinal : tree -> nat

                val maxdepth : tree -> nat

                val mindepth : tree -> nat

                val for_all : (elt -> bool) -> tree -> bool

                val exists_ : (elt -> bool) -> tree -> bool

                type enumeration = R.Defs.Coq_reFS.MSet.Raw.enumeration =
                | End
                | More of elt * tree * enumeration

                val cons : tree -> enumeration -> enumeration

                val compare_more :
                  R.Defs.Coq_regex_as_UCT.t -> (enumeration -> comparison) ->
                  enumeration -> comparison

                val compare_cont :
                  tree -> (enumeration -> comparison) -> enumeration ->
                  comparison

                val compare_end : enumeration -> comparison

                val compare : tree -> tree -> comparison

                val equal : tree -> tree -> bool

                val subsetl :
                  (tree -> bool) -> R.Defs.Coq_regex_as_UCT.t -> tree -> bool

                val subsetr :
                  (tree -> bool) -> R.Defs.Coq_regex_as_UCT.t -> tree -> bool

                val subset : tree -> tree -> bool

                type t = tree

                val height : t -> Z_as_Int.t

                val singleton : R.Defs.Coq_regex_as_UCT.t -> tree

                val create : t -> R.Defs.Coq_regex_as_UCT.t -> t -> tree

                val assert_false : t -> R.Defs.Coq_regex_as_UCT.t -> t -> tree

                val bal : t -> R.Defs.Coq_regex_as_UCT.t -> t -> tree

                val add : R.Defs.Coq_regex_as_UCT.t -> tree -> tree

                val join : tree -> elt -> t -> t

                val remove_min : tree -> elt -> t -> t * elt

                val merge : tree -> tree -> tree

                val remove : R.Defs.Coq_regex_as_UCT.t -> tree -> tree

                val concat : tree -> tree -> tree

                type triple = R.Defs.Coq_reFS.MSet.Raw.triple = { t_left : 
                                                                  t;
                                                                  t_in : 
                                                                  bool;
                                                                  t_right : 
                                                                  t }

                val t_left : triple -> t

                val t_in : triple -> bool

                val t_right : triple -> t

                val split : R.Defs.Coq_regex_as_UCT.t -> tree -> triple

                val inter : tree -> tree -> tree

                val diff : tree -> tree -> tree

                val union : tree -> tree -> tree

                val filter : (elt -> bool) -> tree -> tree

                val partition : (elt -> bool) -> t -> t * t

                val ltb_tree : R.Defs.Coq_regex_as_UCT.t -> tree -> bool

                val gtb_tree : R.Defs.Coq_regex_as_UCT.t -> tree -> bool

                val isok : tree -> bool

                module MX :
                 sig
                  module OrderTac :
                   sig
                    module OTF :
                     sig
                      type t = R.Defs.Coq_regex_as_UCT.t

                      val compare :
                        R.Defs.Coq_regex_as_UCT.t ->
                        R.Defs.Coq_regex_as_UCT.t -> comparison

                      val eq_dec :
                        R.Defs.Coq_regex_as_UCT.t ->
                        R.Defs.Coq_regex_as_UCT.t -> bool
                     end

                    module TO :
                     sig
                      type t = R.Defs.Coq_regex_as_UCT.t

                      val compare :
                        R.Defs.Coq_regex_as_UCT.t ->
                        R.Defs.Coq_regex_as_UCT.t -> comparison

                      val eq_dec :
                        R.Defs.Coq_regex_as_UCT.t ->
                        R.Defs.Coq_regex_as_UCT.t -> bool
                     end
                   end

                  val eq_dec :
                    R.Defs.Coq_regex_as_UCT.t -> R.Defs.Coq_regex_as_UCT.t ->
                    bool

                  val lt_dec :
                    R.Defs.Coq_regex_as_UCT.t -> R.Defs.Coq_regex_as_UCT.t ->
                    bool

                  val eqb :
                    R.Defs.Coq_regex_as_UCT.t -> R.Defs.Coq_regex_as_UCT.t ->
                    bool
                 end

                type coq_R_min_elt = R.Defs.Coq_reFS.MSet.Raw.coq_R_min_elt =
                | R_min_elt_0 of tree
                | R_min_elt_1 of tree * Z_as_Int.t * tree
                   * R.Defs.Coq_regex_as_UCT.t * tree
                | R_min_elt_2 of tree * Z_as_Int.t * tree
                   * R.Defs.Coq_regex_as_UCT.t * tree * Z_as_Int.t * 
                   tree * R.Defs.Coq_regex_as_UCT.t * tree * elt option
                   * coq_R_min_elt

                type coq_R_max_elt = R.Defs.Coq_reFS.MSet.Raw.coq_R_max_elt =
                | R_max_elt_0 of tree
                | R_max_elt_1 of tree * Z_as_Int.t * tree
                   * R.Defs.Coq_regex_as_UCT.t * tree
                | R_max_elt_2 of tree * Z_as_Int.t * tree
                   * R.Defs.Coq_regex_as_UCT.t * tree * Z_as_Int.t * 
                   tree * R.Defs.Coq_regex_as_UCT.t * tree * elt option
                   * coq_R_max_elt

                module L :
                 sig
                  module MO :
                   sig
                    module OrderTac :
                     sig
                      module OTF :
                       sig
                        type t = R.Defs.Coq_regex_as_UCT.t

                        val compare :
                          R.Defs.Coq_regex_as_UCT.t ->
                          R.Defs.Coq_regex_as_UCT.t -> comparison

                        val eq_dec :
                          R.Defs.Coq_regex_as_UCT.t ->
                          R.Defs.Coq_regex_as_UCT.t -> bool
                       end

                      module TO :
                       sig
                        type t = R.Defs.Coq_regex_as_UCT.t

                        val compare :
                          R.Defs.Coq_regex_as_UCT.t ->
                          R.Defs.Coq_regex_as_UCT.t -> comparison

                        val eq_dec :
                          R.Defs.Coq_regex_as_UCT.t ->
                          R.Defs.Coq_regex_as_UCT.t -> bool
                       end
                     end

                    val eq_dec :
                      R.Defs.Coq_regex_as_UCT.t -> R.Defs.Coq_regex_as_UCT.t
                      -> bool

                    val lt_dec :
                      R.Defs.Coq_regex_as_UCT.t -> R.Defs.Coq_regex_as_UCT.t
                      -> bool

                    val eqb :
                      R.Defs.Coq_regex_as_UCT.t -> R.Defs.Coq_regex_as_UCT.t
                      -> bool
                   end
                 end

                val flatten_e : enumeration -> elt list

                type coq_R_bal = R.Defs.Coq_reFS.MSet.Raw.coq_R_bal =
                | R_bal_0 of t * R.Defs.Coq_regex_as_UCT.t * t
                | R_bal_1 of t * R.Defs.Coq_regex_as_UCT.t * t * Z_as_Int.t
                   * tree * R.Defs.Coq_regex_as_UCT.t * tree
                | R_bal_2 of t * R.Defs.Coq_regex_as_UCT.t * t * Z_as_Int.t
                   * tree * R.Defs.Coq_regex_as_UCT.t * tree
                | R_bal_3 of t * R.Defs.Coq_regex_as_UCT.t * t * Z_as_Int.t
                   * tree * R.Defs.Coq_regex_as_UCT.t * tree * Z_as_Int.t
                   * tree * R.Defs.Coq_regex_as_UCT.t * tree
                | R_bal_4 of t * R.Defs.Coq_regex_as_UCT.t * t
                | R_bal_5 of t * R.Defs.Coq_regex_as_UCT.t * t * Z_as_Int.t
                   * tree * R.Defs.Coq_regex_as_UCT.t * tree
                | R_bal_6 of t * R.Defs.Coq_regex_as_UCT.t * t * Z_as_Int.t
                   * tree * R.Defs.Coq_regex_as_UCT.t * tree
                | R_bal_7 of t * R.Defs.Coq_regex_as_UCT.t * t * Z_as_Int.t
                   * tree * R.Defs.Coq_regex_as_UCT.t * tree * Z_as_Int.t
                   * tree * R.Defs.Coq_regex_as_UCT.t * tree
                | R_bal_8 of t * R.Defs.Coq_regex_as_UCT.t * t

                type coq_R_remove_min = R.Defs.Coq_reFS.MSet.Raw.coq_R_remove_min =
                | R_remove_min_0 of tree * elt * t
                | R_remove_min_1 of tree * elt * t * Z_as_Int.t * tree
                   * R.Defs.Coq_regex_as_UCT.t * tree * (t * elt)
                   * coq_R_remove_min * t * elt

                type coq_R_merge = R.Defs.Coq_reFS.MSet.Raw.coq_R_merge =
                | R_merge_0 of tree * tree
                | R_merge_1 of tree * tree * Z_as_Int.t * tree
                   * R.Defs.Coq_regex_as_UCT.t * tree
                | R_merge_2 of tree * tree * Z_as_Int.t * tree
                   * R.Defs.Coq_regex_as_UCT.t * tree * Z_as_Int.t * 
                   tree * R.Defs.Coq_regex_as_UCT.t * tree * t * elt

                type coq_R_concat = R.Defs.Coq_reFS.MSet.Raw.coq_R_concat =
                | R_concat_0 of tree * tree
                | R_concat_1 of tree * tree * Z_as_Int.t * tree
                   * R.Defs.Coq_regex_as_UCT.t * tree
                | R_concat_2 of tree * tree * Z_as_Int.t * tree
                   * R.Defs.Coq_regex_as_UCT.t * tree * Z_as_Int.t * 
                   tree * R.Defs.Coq_regex_as_UCT.t * tree * t * elt

                type coq_R_inter = R.Defs.Coq_reFS.MSet.Raw.coq_R_inter =
                | R_inter_0 of tree * tree
                | R_inter_1 of tree * tree * Z_as_Int.t * tree
                   * R.Defs.Coq_regex_as_UCT.t * tree
                | R_inter_2 of tree * tree * Z_as_Int.t * tree
                   * R.Defs.Coq_regex_as_UCT.t * tree * Z_as_Int.t * 
                   tree * R.Defs.Coq_regex_as_UCT.t * tree * t * bool * 
                   t * tree * coq_R_inter * tree * coq_R_inter
                | R_inter_3 of tree * tree * Z_as_Int.t * tree
                   * R.Defs.Coq_regex_as_UCT.t * tree * Z_as_Int.t * 
                   tree * R.Defs.Coq_regex_as_UCT.t * tree * t * bool * 
                   t * tree * coq_R_inter * tree * coq_R_inter

                type coq_R_diff = R.Defs.Coq_reFS.MSet.Raw.coq_R_diff =
                | R_diff_0 of tree * tree
                | R_diff_1 of tree * tree * Z_as_Int.t * tree
                   * R.Defs.Coq_regex_as_UCT.t * tree
                | R_diff_2 of tree * tree * Z_as_Int.t * tree
                   * R.Defs.Coq_regex_as_UCT.t * tree * Z_as_Int.t * 
                   tree * R.Defs.Coq_regex_as_UCT.t * tree * t * bool * 
                   t * tree * coq_R_diff * tree * coq_R_diff
                | R_diff_3 of tree * tree * Z_as_Int.t * tree
                   * R.Defs.Coq_regex_as_UCT.t * tree * Z_as_Int.t * 
                   tree * R.Defs.Coq_regex_as_UCT.t * tree * t * bool * 
                   t * tree * coq_R_diff * tree * coq_R_diff

                type coq_R_union = R.Defs.Coq_reFS.MSet.Raw.coq_R_union =
                | R_union_0 of tree * tree
                | R_union_1 of tree * tree * Z_as_Int.t * tree
                   * R.Defs.Coq_regex_as_UCT.t * tree
                | R_union_2 of tree * tree * Z_as_Int.t * tree
                   * R.Defs.Coq_regex_as_UCT.t * tree * Z_as_Int.t * 
                   tree * R.Defs.Coq_regex_as_UCT.t * tree * t * bool * 
                   t * tree * coq_R_union * tree * coq_R_union
               end

              module E :
               sig
                type t = R.Defs.Coq_regex_as_UCT.t

                val compare :
                  R.Defs.Coq_regex_as_UCT.t -> R.Defs.Coq_regex_as_UCT.t ->
                  comparison

                val eq_dec :
                  R.Defs.Coq_regex_as_UCT.t -> R.Defs.Coq_regex_as_UCT.t ->
                  bool
               end

              type elt = R.Defs.Coq_regex_as_UCT.t

              type t_ =
                Raw.t
                (* singleton inductive, whose constructor was Mkt *)

              val this : t_ -> Raw.t

              type t = t_

              val mem : elt -> t -> bool

              val add : elt -> t -> t

              val remove : elt -> t -> t

              val singleton : elt -> t

              val union : t -> t -> t

              val inter : t -> t -> t

              val diff : t -> t -> t

              val equal : t -> t -> bool

              val subset : t -> t -> bool

              val empty : t

              val is_empty : t -> bool

              val elements : t -> elt list

              val choose : t -> elt option

              val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

              val cardinal : t -> nat

              val filter : (elt -> bool) -> t -> t

              val for_all : (elt -> bool) -> t -> bool

              val exists_ : (elt -> bool) -> t -> bool

              val partition : (elt -> bool) -> t -> t * t

              val eq_dec : t -> t -> bool

              val compare : t -> t -> comparison

              val min_elt : t -> elt option

              val max_elt : t -> elt option
             end

            type elt = R.Defs.Coq_regex_as_UCT.t

            type t = MSet.t

            val empty : t

            val is_empty : t -> bool

            val mem : elt -> t -> bool

            val add : elt -> t -> t

            val singleton : elt -> t

            val remove : elt -> t -> t

            val union : t -> t -> t

            val inter : t -> t -> t

            val diff : t -> t -> t

            val eq_dec : t -> t -> bool

            val equal : t -> t -> bool

            val subset : t -> t -> bool

            val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

            val for_all : (elt -> bool) -> t -> bool

            val exists_ : (elt -> bool) -> t -> bool

            val filter : (elt -> bool) -> t -> t

            val partition : (elt -> bool) -> t -> t * t

            val cardinal : t -> nat

            val elements : t -> elt list

            val choose : t -> elt option

            module MF :
             sig
              val eqb :
                R.Defs.Coq_regex_as_UCT.t -> R.Defs.Coq_regex_as_UCT.t -> bool
             end

            val min_elt : t -> elt option

            val max_elt : t -> elt option

            val compare : t -> t -> t compare0

            module E :
             sig
              type t = R.Defs.Coq_regex_as_UCT.t

              val compare :
                R.Defs.Coq_regex_as_UCT.t -> R.Defs.Coq_regex_as_UCT.t ->
                R.Defs.Coq_regex_as_UCT.t compare0

              val eq_dec :
                R.Defs.Coq_regex_as_UCT.t -> R.Defs.Coq_regex_as_UCT.t -> bool
             end
           end

          type coq_Table = R.Defs.Regexes.regex FM.t * Coq_reFS.t

          val emptyTable : coq_Table

          val set_Table :
            coq_Table -> R.Defs.Regexes.regex -> R.Ty.coq_Sigma ->
            R.Defs.Regexes.regex -> coq_Table

          val get_Table :
            coq_Table -> R.Defs.Regexes.regex -> R.Ty.coq_Sigma ->
            R.Defs.Regexes.regex option

          val add_state : coq_Table -> R.Defs.Regexes.regex -> coq_Table

          val get_states : coq_Table -> Coq_reFS.t

          val get_eq :
            coq_Table -> R.Defs.Regexes.regex -> R.Defs.Regexes.regex option
         end

        module Defs :
         sig
          module FillTable :
           sig
            val mkIterUnion' :
              R.Defs.Regexes.regex -> R.Defs.Regexes.regex list

            val merge' :
              R.Defs.Regexes.regex list -> R.Defs.Regexes.regex list ->
              R.Defs.Regexes.regex list

            val merge'' :
              R.Defs.Regexes.regex list -> R.Defs.Regexes.regex list ->
              R.Defs.Regexes.regex list

            val merge :
              R.Defs.Regexes.regex list -> R.Defs.Regexes.regex list ->
              R.Defs.Regexes.regex list

            val mkIterApp' : R.Defs.Regexes.regex -> R.Defs.Regexes.regex list

            val canon : R.Defs.Regexes.regex -> R.Defs.Regexes.regex

            val fill_Table_all'' :
              TabTy.coq_Table -> R.Defs.Regexes.regex -> R.Ty.coq_Sigma list
              -> nat -> TabTy.coq_Table

            val fill_Table_all' :
              TabTy.coq_Table -> R.Defs.Regexes.regex -> R.Ty.coq_Sigma list
              -> nat -> TabTy.coq_Table

            val fill_Table_all :
              TabTy.coq_Table -> R.Defs.Regexes.regex -> R.Ty.coq_Sigma list
              -> nat -> TabTy.coq_Table

            val traverse_pos' : positive -> positive

            val traverse_pos : positive -> positive

            val fill_Table_all'_bin :
              TabTy.coq_Table -> R.Defs.Regexes.regex -> R.Ty.coq_Sigma list
              -> positive -> TabTy.coq_Table

            val fill_Table_all_bin :
              TabTy.coq_Table -> R.Defs.Regexes.regex -> R.Ty.coq_Sigma list
              -> positive -> TabTy.coq_Table
           end

          module Spec :
           sig
           end

          module Correct :
           sig
           end

          module Coq_binary :
           sig
           end
         end
       end

      module R :
       sig
        module Ty :
         sig
          type coq_Sigma = ALPHABET__0.coq_Sigma

          val coq_SigmaEnum : coq_Sigma list

          val coq_Sigma_dec : coq_Sigma -> coq_Sigma -> bool

          val compareT : coq_Sigma -> coq_Sigma -> comparison

          val ascii2Sigma : char -> coq_Sigma
         end

        module Defs :
         sig
          module T_as_UCT :
           sig
            type t = Ty.coq_Sigma

            val compare : Ty.coq_Sigma -> Ty.coq_Sigma -> comparison
           end

          module T_as_UOT :
           sig
            type t = T_as_UCT.t

            val compare : t -> t -> t compare0

            val eq_dec : t -> t -> bool
           end

          module SigFS :
           sig
            module X' :
             sig
              type t = T_as_UCT.t

              val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

              val compare : T_as_UCT.t -> T_as_UCT.t -> comparison
             end

            module MSet :
             sig
              module Raw :
               sig
                type elt = T_as_UCT.t

                type tree = TabT.R.Defs.SigFS.MSet.Raw.tree =
                | Leaf
                | Node of Z_as_Int.t * tree * T_as_UCT.t * tree

                val empty : tree

                val is_empty : tree -> bool

                val mem : T_as_UCT.t -> tree -> bool

                val min_elt : tree -> elt option

                val max_elt : tree -> elt option

                val choose : tree -> elt option

                val fold : (elt -> 'a1 -> 'a1) -> tree -> 'a1 -> 'a1

                val elements_aux : T_as_UCT.t list -> tree -> T_as_UCT.t list

                val elements : tree -> T_as_UCT.t list

                val rev_elements_aux :
                  T_as_UCT.t list -> tree -> T_as_UCT.t list

                val rev_elements : tree -> T_as_UCT.t list

                val cardinal : tree -> nat

                val maxdepth : tree -> nat

                val mindepth : tree -> nat

                val for_all : (elt -> bool) -> tree -> bool

                val exists_ : (elt -> bool) -> tree -> bool

                type enumeration = TabT.R.Defs.SigFS.MSet.Raw.enumeration =
                | End
                | More of elt * tree * enumeration

                val cons : tree -> enumeration -> enumeration

                val compare_more :
                  T_as_UCT.t -> (enumeration -> comparison) -> enumeration ->
                  comparison

                val compare_cont :
                  tree -> (enumeration -> comparison) -> enumeration ->
                  comparison

                val compare_end : enumeration -> comparison

                val compare : tree -> tree -> comparison

                val equal : tree -> tree -> bool

                val subsetl : (tree -> bool) -> T_as_UCT.t -> tree -> bool

                val subsetr : (tree -> bool) -> T_as_UCT.t -> tree -> bool

                val subset : tree -> tree -> bool

                type t = tree

                val height : t -> Z_as_Int.t

                val singleton : T_as_UCT.t -> tree

                val create : t -> T_as_UCT.t -> t -> tree

                val assert_false : t -> T_as_UCT.t -> t -> tree

                val bal : t -> T_as_UCT.t -> t -> tree

                val add : T_as_UCT.t -> tree -> tree

                val join : tree -> elt -> t -> t

                val remove_min : tree -> elt -> t -> t * elt

                val merge : tree -> tree -> tree

                val remove : T_as_UCT.t -> tree -> tree

                val concat : tree -> tree -> tree

                type triple = TabT.R.Defs.SigFS.MSet.Raw.triple = { t_left : 
                                                                    t;
                                                                    t_in : 
                                                                    bool;
                                                                    t_right : 
                                                                    t }

                val t_left : triple -> t

                val t_in : triple -> bool

                val t_right : triple -> t

                val split : T_as_UCT.t -> tree -> triple

                val inter : tree -> tree -> tree

                val diff : tree -> tree -> tree

                val union : tree -> tree -> tree

                val filter : (elt -> bool) -> tree -> tree

                val partition : (elt -> bool) -> t -> t * t

                val ltb_tree : T_as_UCT.t -> tree -> bool

                val gtb_tree : T_as_UCT.t -> tree -> bool

                val isok : tree -> bool

                module MX :
                 sig
                  module OrderTac :
                   sig
                    module OTF :
                     sig
                      type t = T_as_UCT.t

                      val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

                      val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
                     end

                    module TO :
                     sig
                      type t = T_as_UCT.t

                      val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

                      val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
                     end
                   end

                  val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                  val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                  val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
                 end

                type coq_R_min_elt = TabT.R.Defs.SigFS.MSet.Raw.coq_R_min_elt =
                | R_min_elt_0 of tree
                | R_min_elt_1 of tree * Z_as_Int.t * tree * T_as_UCT.t * tree
                | R_min_elt_2 of tree * Z_as_Int.t * tree * T_as_UCT.t * 
                   tree * Z_as_Int.t * tree * T_as_UCT.t * tree * elt option
                   * coq_R_min_elt

                type coq_R_max_elt = TabT.R.Defs.SigFS.MSet.Raw.coq_R_max_elt =
                | R_max_elt_0 of tree
                | R_max_elt_1 of tree * Z_as_Int.t * tree * T_as_UCT.t * tree
                | R_max_elt_2 of tree * Z_as_Int.t * tree * T_as_UCT.t * 
                   tree * Z_as_Int.t * tree * T_as_UCT.t * tree * elt option
                   * coq_R_max_elt

                module L :
                 sig
                  module MO :
                   sig
                    module OrderTac :
                     sig
                      module OTF :
                       sig
                        type t = T_as_UCT.t

                        val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

                        val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
                       end

                      module TO :
                       sig
                        type t = T_as_UCT.t

                        val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

                        val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
                       end
                     end

                    val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                    val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                    val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
                   end
                 end

                val flatten_e : enumeration -> elt list

                type coq_R_bal = TabT.R.Defs.SigFS.MSet.Raw.coq_R_bal =
                | R_bal_0 of t * T_as_UCT.t * t
                | R_bal_1 of t * T_as_UCT.t * t * Z_as_Int.t * tree
                   * T_as_UCT.t * tree
                | R_bal_2 of t * T_as_UCT.t * t * Z_as_Int.t * tree
                   * T_as_UCT.t * tree
                | R_bal_3 of t * T_as_UCT.t * t * Z_as_Int.t * tree
                   * T_as_UCT.t * tree * Z_as_Int.t * tree * T_as_UCT.t * 
                   tree
                | R_bal_4 of t * T_as_UCT.t * t
                | R_bal_5 of t * T_as_UCT.t * t * Z_as_Int.t * tree
                   * T_as_UCT.t * tree
                | R_bal_6 of t * T_as_UCT.t * t * Z_as_Int.t * tree
                   * T_as_UCT.t * tree
                | R_bal_7 of t * T_as_UCT.t * t * Z_as_Int.t * tree
                   * T_as_UCT.t * tree * Z_as_Int.t * tree * T_as_UCT.t * 
                   tree
                | R_bal_8 of t * T_as_UCT.t * t

                type coq_R_remove_min = TabT.R.Defs.SigFS.MSet.Raw.coq_R_remove_min =
                | R_remove_min_0 of tree * elt * t
                | R_remove_min_1 of tree * elt * t * Z_as_Int.t * tree
                   * T_as_UCT.t * tree * (t * elt) * coq_R_remove_min * 
                   t * elt

                type coq_R_merge = TabT.R.Defs.SigFS.MSet.Raw.coq_R_merge =
                | R_merge_0 of tree * tree
                | R_merge_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                   * tree
                | R_merge_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                   * tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * 
                   elt

                type coq_R_concat = TabT.R.Defs.SigFS.MSet.Raw.coq_R_concat =
                | R_concat_0 of tree * tree
                | R_concat_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                   * tree
                | R_concat_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                   * tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * 
                   elt

                type coq_R_inter = TabT.R.Defs.SigFS.MSet.Raw.coq_R_inter =
                | R_inter_0 of tree * tree
                | R_inter_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                   * tree
                | R_inter_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                   * tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * 
                   bool * t * tree * coq_R_inter * tree * coq_R_inter
                | R_inter_3 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                   * tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * 
                   bool * t * tree * coq_R_inter * tree * coq_R_inter

                type coq_R_diff = TabT.R.Defs.SigFS.MSet.Raw.coq_R_diff =
                | R_diff_0 of tree * tree
                | R_diff_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                   * tree
                | R_diff_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                   * tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * 
                   bool * t * tree * coq_R_diff * tree * coq_R_diff
                | R_diff_3 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                   * tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * 
                   bool * t * tree * coq_R_diff * tree * coq_R_diff

                type coq_R_union = TabT.R.Defs.SigFS.MSet.Raw.coq_R_union =
                | R_union_0 of tree * tree
                | R_union_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                   * tree
                | R_union_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                   * tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * 
                   bool * t * tree * coq_R_union * tree * coq_R_union
               end

              module E :
               sig
                type t = T_as_UCT.t

                val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

                val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
               end

              type elt = T_as_UCT.t

              type t_ =
                Raw.t
                (* singleton inductive, whose constructor was Mkt *)

              val this : t_ -> Raw.t

              type t = t_

              val mem : elt -> t -> bool

              val add : elt -> t -> t

              val remove : elt -> t -> t

              val singleton : elt -> t

              val union : t -> t -> t

              val inter : t -> t -> t

              val diff : t -> t -> t

              val equal : t -> t -> bool

              val subset : t -> t -> bool

              val empty : t

              val is_empty : t -> bool

              val elements : t -> elt list

              val choose : t -> elt option

              val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

              val cardinal : t -> nat

              val filter : (elt -> bool) -> t -> t

              val for_all : (elt -> bool) -> t -> bool

              val exists_ : (elt -> bool) -> t -> bool

              val partition : (elt -> bool) -> t -> t * t

              val eq_dec : t -> t -> bool

              val compare : t -> t -> comparison

              val min_elt : t -> elt option

              val max_elt : t -> elt option
             end

            type elt = T_as_UCT.t

            type t = MSet.t

            val empty : t

            val is_empty : t -> bool

            val mem : elt -> t -> bool

            val add : elt -> t -> t

            val singleton : elt -> t

            val remove : elt -> t -> t

            val union : t -> t -> t

            val inter : t -> t -> t

            val diff : t -> t -> t

            val eq_dec : t -> t -> bool

            val equal : t -> t -> bool

            val subset : t -> t -> bool

            val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

            val for_all : (elt -> bool) -> t -> bool

            val exists_ : (elt -> bool) -> t -> bool

            val filter : (elt -> bool) -> t -> t

            val partition : (elt -> bool) -> t -> t * t

            val cardinal : t -> nat

            val elements : t -> elt list

            val choose : t -> elt option

            module MF :
             sig
              val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
             end

            val min_elt : t -> elt option

            val max_elt : t -> elt option

            val compare : t -> t -> t compare0

            module E :
             sig
              type t = T_as_UCT.t

              val compare : T_as_UCT.t -> T_as_UCT.t -> T_as_UCT.t compare0

              val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
             end
           end

          module SigFSF :
           sig
            val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
           end

          module SigFM :
           sig
            module E :
             sig
              type t = T_as_UCT.t

              val compare : T_as_UCT.t -> T_as_UCT.t -> T_as_UCT.t compare0

              val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
             end

            module Raw :
             sig
              type key = T_as_UCT.t

              type 'elt tree = 'elt TabT.R.Defs.SigFM.Raw.tree =
              | Leaf
              | Node of 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t

              val tree_rect :
                'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
                Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

              val tree_rec :
                'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
                Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

              val height : 'a1 tree -> Z_as_Int.t

              val cardinal : 'a1 tree -> nat

              val empty : 'a1 tree

              val is_empty : 'a1 tree -> bool

              val mem : T_as_UCT.t -> 'a1 tree -> bool

              val find : T_as_UCT.t -> 'a1 tree -> 'a1 option

              val create : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

              val assert_false :
                'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

              val bal : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

              val add : key -> 'a1 -> 'a1 tree -> 'a1 tree

              val remove_min :
                'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree * (key * 'a1)

              val merge : 'a1 tree -> 'a1 tree -> 'a1 tree

              val remove : T_as_UCT.t -> 'a1 tree -> 'a1 tree

              val join : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

              type 'elt triple = 'elt TabT.R.Defs.SigFM.Raw.triple = { 
              t_left : 'elt tree; t_opt : 'elt option; t_right : 'elt tree }

              val t_left : 'a1 triple -> 'a1 tree

              val t_opt : 'a1 triple -> 'a1 option

              val t_right : 'a1 triple -> 'a1 tree

              val split : T_as_UCT.t -> 'a1 tree -> 'a1 triple

              val concat : 'a1 tree -> 'a1 tree -> 'a1 tree

              val elements_aux :
                (key * 'a1) list -> 'a1 tree -> (key * 'a1) list

              val elements : 'a1 tree -> (key * 'a1) list

              val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

              type 'elt enumeration = 'elt TabT.R.Defs.SigFM.Raw.enumeration =
              | End
              | More of key * 'elt * 'elt tree * 'elt enumeration

              val enumeration_rect :
                'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 ->
                'a2) -> 'a1 enumeration -> 'a2

              val enumeration_rec :
                'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 ->
                'a2) -> 'a1 enumeration -> 'a2

              val cons : 'a1 tree -> 'a1 enumeration -> 'a1 enumeration

              val equal_more :
                ('a1 -> 'a1 -> bool) -> T_as_UCT.t -> 'a1 -> ('a1 enumeration
                -> bool) -> 'a1 enumeration -> bool

              val equal_cont :
                ('a1 -> 'a1 -> bool) -> 'a1 tree -> ('a1 enumeration -> bool)
                -> 'a1 enumeration -> bool

              val equal_end : 'a1 enumeration -> bool

              val equal : ('a1 -> 'a1 -> bool) -> 'a1 tree -> 'a1 tree -> bool

              val map : ('a1 -> 'a2) -> 'a1 tree -> 'a2 tree

              val mapi : (key -> 'a1 -> 'a2) -> 'a1 tree -> 'a2 tree

              val map_option :
                (key -> 'a1 -> 'a2 option) -> 'a1 tree -> 'a2 tree

              val map2_opt :
                (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3
                tree) -> ('a2 tree -> 'a3 tree) -> 'a1 tree -> 'a2 tree ->
                'a3 tree

              val map2 :
                ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 tree -> 'a2
                tree -> 'a3 tree

              module Proofs :
               sig
                module MX :
                 sig
                  module TO :
                   sig
                    type t = T_as_UCT.t
                   end

                  module IsTO :
                   sig
                   end

                  module OrderTac :
                   sig
                   end

                  val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                  val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                  val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
                 end

                module PX :
                 sig
                  module MO :
                   sig
                    module TO :
                     sig
                      type t = T_as_UCT.t
                     end

                    module IsTO :
                     sig
                     end

                    module OrderTac :
                     sig
                     end

                    val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                    val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                    val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
                   end
                 end

                module L :
                 sig
                  module MX :
                   sig
                    module TO :
                     sig
                      type t = T_as_UCT.t
                     end

                    module IsTO :
                     sig
                     end

                    module OrderTac :
                     sig
                     end

                    val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                    val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                    val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
                   end

                  module PX :
                   sig
                    module MO :
                     sig
                      module TO :
                       sig
                        type t = T_as_UCT.t
                       end

                      module IsTO :
                       sig
                       end

                      module OrderTac :
                       sig
                       end

                      val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                      val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                      val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
                     end
                   end

                  type key = T_as_UCT.t

                  type 'elt t = (T_as_UCT.t * 'elt) list

                  val empty : 'a1 t

                  val is_empty : 'a1 t -> bool

                  val mem : key -> 'a1 t -> bool

                  type 'elt coq_R_mem = 'elt TabT.R.Defs.SigFM.Raw.Proofs.L.coq_R_mem =
                  | R_mem_0 of 'elt t
                  | R_mem_1 of 'elt t * T_as_UCT.t * 'elt
                     * (T_as_UCT.t * 'elt) list
                  | R_mem_2 of 'elt t * T_as_UCT.t * 'elt
                     * (T_as_UCT.t * 'elt) list
                  | R_mem_3 of 'elt t * T_as_UCT.t * 'elt
                     * (T_as_UCT.t * 'elt) list * bool * 'elt coq_R_mem

                  val coq_R_mem_rect :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                    'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
                    -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                    -> __ -> __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1
                    -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> bool ->
                    'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 t -> bool -> 'a1
                    coq_R_mem -> 'a2

                  val coq_R_mem_rec :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                    'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
                    -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                    -> __ -> __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1
                    -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> bool ->
                    'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 t -> bool -> 'a1
                    coq_R_mem -> 'a2

                  val mem_rect :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                    'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
                    -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                    -> __ -> __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1
                    -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
                    'a2) -> 'a1 t -> 'a2

                  val mem_rec :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                    'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
                    -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                    -> __ -> __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1
                    -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
                    'a2) -> 'a1 t -> 'a2

                  val coq_R_mem_correct :
                    key -> 'a1 t -> bool -> 'a1 coq_R_mem

                  val find : key -> 'a1 t -> 'a1 option

                  type 'elt coq_R_find = 'elt TabT.R.Defs.SigFM.Raw.Proofs.L.coq_R_find =
                  | R_find_0 of 'elt t
                  | R_find_1 of 'elt t * T_as_UCT.t * 'elt
                     * (T_as_UCT.t * 'elt) list
                  | R_find_2 of 'elt t * T_as_UCT.t * 'elt
                     * (T_as_UCT.t * 'elt) list
                  | R_find_3 of 'elt t * T_as_UCT.t * 'elt
                     * (T_as_UCT.t * 'elt) list * 'elt option
                     * 'elt coq_R_find

                  val coq_R_find_rect :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                    'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
                    -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                    -> __ -> __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1
                    -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1
                    option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> 'a1 t -> 'a1
                    option -> 'a1 coq_R_find -> 'a2

                  val coq_R_find_rec :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                    'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
                    -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                    -> __ -> __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1
                    -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1
                    option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> 'a1 t -> 'a1
                    option -> 'a1 coq_R_find -> 'a2

                  val find_rect :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                    'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
                    -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                    -> __ -> __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1
                    -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
                    'a2) -> 'a1 t -> 'a2

                  val find_rec :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                    'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
                    -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                    -> __ -> __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1
                    -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
                    'a2) -> 'a1 t -> 'a2

                  val coq_R_find_correct :
                    key -> 'a1 t -> 'a1 option -> 'a1 coq_R_find

                  val add : key -> 'a1 -> 'a1 t -> 'a1 t

                  type 'elt coq_R_add = 'elt TabT.R.Defs.SigFM.Raw.Proofs.L.coq_R_add =
                  | R_add_0 of 'elt t
                  | R_add_1 of 'elt t * T_as_UCT.t * 'elt
                     * (T_as_UCT.t * 'elt) list
                  | R_add_2 of 'elt t * T_as_UCT.t * 'elt
                     * (T_as_UCT.t * 'elt) list
                  | R_add_3 of 'elt t * T_as_UCT.t * 'elt
                     * (T_as_UCT.t * 'elt) list * 'elt t * 'elt coq_R_add

                  val coq_R_add_rect :
                    key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __
                    -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                    (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1
                    t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __
                    -> __ -> __ -> 'a1 t -> 'a1 coq_R_add -> 'a2 -> 'a2) ->
                    'a1 t -> 'a1 t -> 'a1 coq_R_add -> 'a2

                  val coq_R_add_rec :
                    key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __
                    -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                    (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1
                    t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __
                    -> __ -> __ -> 'a1 t -> 'a1 coq_R_add -> 'a2 -> 'a2) ->
                    'a1 t -> 'a1 t -> 'a1 coq_R_add -> 'a2

                  val add_rect :
                    key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __
                    -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                    (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1
                    t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __
                    -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                  val add_rec :
                    key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __
                    -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                    (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1
                    t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __
                    -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                  val coq_R_add_correct :
                    key -> 'a1 -> 'a1 t -> 'a1 t -> 'a1 coq_R_add

                  val remove : key -> 'a1 t -> 'a1 t

                  type 'elt coq_R_remove = 'elt TabT.R.Defs.SigFM.Raw.Proofs.L.coq_R_remove =
                  | R_remove_0 of 'elt t
                  | R_remove_1 of 'elt t * T_as_UCT.t * 'elt
                     * (T_as_UCT.t * 'elt) list
                  | R_remove_2 of 'elt t * T_as_UCT.t * 'elt
                     * (T_as_UCT.t * 'elt) list
                  | R_remove_3 of 'elt t * T_as_UCT.t * 'elt
                     * (T_as_UCT.t * 'elt) list * 'elt t * 'elt coq_R_remove

                  val coq_R_remove_rect :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                    'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
                    -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                    -> __ -> __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1
                    -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1 t ->
                    'a1 coq_R_remove -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1
                    coq_R_remove -> 'a2

                  val coq_R_remove_rec :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                    'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
                    -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                    -> __ -> __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1
                    -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1 t ->
                    'a1 coq_R_remove -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1
                    coq_R_remove -> 'a2

                  val remove_rect :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                    'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
                    -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                    -> __ -> __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1
                    -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
                    'a2) -> 'a1 t -> 'a2

                  val remove_rec :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                    'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
                    -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                    -> __ -> __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1
                    -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
                    'a2) -> 'a1 t -> 'a2

                  val coq_R_remove_correct :
                    key -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove

                  val elements : 'a1 t -> 'a1 t

                  val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

                  type ('elt, 'a) coq_R_fold = ('elt, 'a) TabT.R.Defs.SigFM.Raw.Proofs.L.coq_R_fold =
                  | R_fold_0 of 'elt t * 'a
                  | R_fold_1 of 'elt t * 'a * T_as_UCT.t * 'elt
                     * (T_as_UCT.t * 'elt) list * 'a * ('elt, 'a) coq_R_fold

                  val coq_R_fold_rect :
                    (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3)
                    -> ('a1 t -> 'a2 -> T_as_UCT.t -> 'a1 ->
                    (T_as_UCT.t * 'a1) list -> __ -> 'a2 -> ('a1, 'a2)
                    coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a2 -> ('a1,
                    'a2) coq_R_fold -> 'a3

                  val coq_R_fold_rec :
                    (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3)
                    -> ('a1 t -> 'a2 -> T_as_UCT.t -> 'a1 ->
                    (T_as_UCT.t * 'a1) list -> __ -> 'a2 -> ('a1, 'a2)
                    coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a2 -> ('a1,
                    'a2) coq_R_fold -> 'a3

                  val fold_rect :
                    (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3)
                    -> ('a1 t -> 'a2 -> T_as_UCT.t -> 'a1 ->
                    (T_as_UCT.t * 'a1) list -> __ -> 'a3 -> 'a3) -> 'a1 t ->
                    'a2 -> 'a3

                  val fold_rec :
                    (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3)
                    -> ('a1 t -> 'a2 -> T_as_UCT.t -> 'a1 ->
                    (T_as_UCT.t * 'a1) list -> __ -> 'a3 -> 'a3) -> 'a1 t ->
                    'a2 -> 'a3

                  val coq_R_fold_correct :
                    (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2 ->
                    ('a1, 'a2) coq_R_fold

                  val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool

                  type 'elt coq_R_equal = 'elt TabT.R.Defs.SigFM.Raw.Proofs.L.coq_R_equal =
                  | R_equal_0 of 'elt t * 'elt t
                  | R_equal_1 of 'elt t * 'elt t * T_as_UCT.t * 'elt
                     * (T_as_UCT.t * 'elt) list * T_as_UCT.t * 'elt
                     * (T_as_UCT.t * 'elt) list * bool * 'elt coq_R_equal
                  | R_equal_2 of 'elt t * 'elt t * T_as_UCT.t * 'elt
                     * (T_as_UCT.t * 'elt) list * T_as_UCT.t * 'elt
                     * (T_as_UCT.t * 'elt) list * T_as_UCT.t compare0
                  | R_equal_3 of 'elt t * 'elt t * 'elt t * 'elt t

                  val coq_R_equal_rect :
                    ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                    'a2) -> ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 ->
                    (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t -> 'a1 ->
                    (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> bool -> 'a1
                    coq_R_equal -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t ->
                    T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
                    T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
                    T_as_UCT.t compare0 -> __ -> __ -> 'a2) -> ('a1 t -> 'a1
                    t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2) -> 'a1 t ->
                    'a1 t -> bool -> 'a1 coq_R_equal -> 'a2

                  val coq_R_equal_rec :
                    ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                    'a2) -> ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 ->
                    (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t -> 'a1 ->
                    (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> bool -> 'a1
                    coq_R_equal -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t ->
                    T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
                    T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
                    T_as_UCT.t compare0 -> __ -> __ -> 'a2) -> ('a1 t -> 'a1
                    t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2) -> 'a1 t ->
                    'a1 t -> bool -> 'a1 coq_R_equal -> 'a2

                  val equal_rect :
                    ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                    'a2) -> ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 ->
                    (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t -> 'a1 ->
                    (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 -> 'a2)
                    -> ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 ->
                    (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t -> 'a1 ->
                    (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t compare0 ->
                    __ -> __ -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1
                    t -> __ -> __ -> 'a2) -> 'a1 t -> 'a1 t -> 'a2

                  val equal_rec :
                    ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                    'a2) -> ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 ->
                    (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t -> 'a1 ->
                    (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 -> 'a2)
                    -> ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 ->
                    (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t -> 'a1 ->
                    (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t compare0 ->
                    __ -> __ -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1
                    t -> __ -> __ -> 'a2) -> 'a1 t -> 'a1 t -> 'a2

                  val coq_R_equal_correct :
                    ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool -> 'a1
                    coq_R_equal

                  val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

                  val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

                  val option_cons :
                    key -> 'a1 option -> (key * 'a1) list -> (key * 'a1) list

                  val map2_l :
                    ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a3 t

                  val map2_r :
                    ('a1 option -> 'a2 option -> 'a3 option) -> 'a2 t -> 'a3 t

                  val map2 :
                    ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2
                    t -> 'a3 t

                  val combine : 'a1 t -> 'a2 t -> ('a1 option * 'a2 option) t

                  val fold_right_pair :
                    ('a1 -> 'a2 -> 'a3 -> 'a3) -> ('a1 * 'a2) list -> 'a3 ->
                    'a3

                  val map2_alt :
                    ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2
                    t -> (key * 'a3) list

                  val at_least_one :
                    'a1 option -> 'a2 option -> ('a1 option * 'a2 option)
                    option

                  val at_least_one_then_f :
                    ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 option ->
                    'a2 option -> 'a3 option
                 end

                type 'elt coq_R_mem = 'elt TabT.R.Defs.SigFM.Raw.Proofs.coq_R_mem =
                | R_mem_0 of 'elt tree
                | R_mem_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t * bool * 'elt coq_R_mem
                | R_mem_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t
                | R_mem_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t * bool * 'elt coq_R_mem

                val coq_R_mem_rect :
                  T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                  __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> ('a1 tree ->
                  'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                  __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 ->
                  'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> bool -> 'a1
                  coq_R_mem -> 'a2 -> 'a2) -> 'a1 tree -> bool -> 'a1
                  coq_R_mem -> 'a2

                val coq_R_mem_rec :
                  T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                  __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> ('a1 tree ->
                  'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                  __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 ->
                  'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> bool -> 'a1
                  coq_R_mem -> 'a2 -> 'a2) -> 'a1 tree -> bool -> 'a1
                  coq_R_mem -> 'a2

                type 'elt coq_R_find = 'elt TabT.R.Defs.SigFM.Raw.Proofs.coq_R_find =
                | R_find_0 of 'elt tree
                | R_find_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t * 'elt option * 'elt coq_R_find
                | R_find_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t
                | R_find_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t * 'elt option * 'elt coq_R_find

                val coq_R_find_rect :
                  T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                  __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> ('a1
                  tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
                  __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key ->
                  'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
                  option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> 'a1 tree -> 'a1
                  option -> 'a1 coq_R_find -> 'a2

                val coq_R_find_rec :
                  T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                  __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> ('a1
                  tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
                  __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key ->
                  'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
                  option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> 'a1 tree -> 'a1
                  option -> 'a1 coq_R_find -> 'a2

                type 'elt coq_R_bal = 'elt TabT.R.Defs.SigFM.Raw.Proofs.coq_R_bal =
                | R_bal_0 of 'elt tree * key * 'elt * 'elt tree
                | R_bal_1 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                   * key * 'elt * 'elt tree * Z_as_Int.t
                | R_bal_2 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                   * key * 'elt * 'elt tree * Z_as_Int.t
                | R_bal_3 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                   * key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * 
                   key * 'elt * 'elt tree * Z_as_Int.t
                | R_bal_4 of 'elt tree * key * 'elt * 'elt tree
                | R_bal_5 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                   * key * 'elt * 'elt tree * Z_as_Int.t
                | R_bal_6 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                   * key * 'elt * 'elt tree * Z_as_Int.t
                | R_bal_7 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                   * key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * 
                   key * 'elt * 'elt tree * Z_as_Int.t
                | R_bal_8 of 'elt tree * key * 'elt * 'elt tree

                val coq_R_bal_rect :
                  ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ ->
                  'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ ->
                  'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                  __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree ->
                  __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree ->
                  key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key ->
                  'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree
                  -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2) ->
                  ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __
                  -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __
                  -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key ->
                  'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key
                  -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> __ ->
                  'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ ->
                  __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 ->
                  'a1 tree -> Z_as_Int.t -> __ -> 'a2) -> ('a1 tree -> key ->
                  'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a2) -> 'a1 tree
                  -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_bal ->
                  'a2

                val coq_R_bal_rec :
                  ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ ->
                  'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ ->
                  'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                  __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree ->
                  __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree ->
                  key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key ->
                  'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree
                  -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2) ->
                  ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __
                  -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __
                  -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key ->
                  'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key
                  -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> __ ->
                  'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ ->
                  __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 ->
                  'a1 tree -> Z_as_Int.t -> __ -> 'a2) -> ('a1 tree -> key ->
                  'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a2) -> 'a1 tree
                  -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_bal ->
                  'a2

                type 'elt coq_R_add = 'elt TabT.R.Defs.SigFM.Raw.Proofs.coq_R_add =
                | R_add_0 of 'elt tree
                | R_add_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t * 'elt tree * 'elt coq_R_add
                | R_add_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t
                | R_add_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t * 'elt tree * 'elt coq_R_add

                val coq_R_add_rect :
                  key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                  __ -> 'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1 tree
                  -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                  -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
                  -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree ->
                  'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1
                  coq_R_add -> 'a2

                val coq_R_add_rec :
                  key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                  __ -> 'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1 tree
                  -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                  -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
                  -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree ->
                  'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1
                  coq_R_add -> 'a2

                type 'elt coq_R_remove_min = 'elt TabT.R.Defs.SigFM.Raw.Proofs.coq_R_remove_min =
                | R_remove_min_0 of 'elt tree * key * 'elt * 'elt tree
                | R_remove_min_1 of 'elt tree * key * 'elt * 'elt tree
                   * 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t
                   * ('elt tree * (key * 'elt)) * 'elt coq_R_remove_min
                   * 'elt tree * (key * 'elt)

                val coq_R_remove_min_rect :
                  ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1
                  tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1 ->
                  'a1 tree -> Z_as_Int.t -> __ -> ('a1 tree * (key * 'a1)) ->
                  'a1 coq_R_remove_min -> 'a2 -> 'a1 tree -> (key * 'a1) ->
                  __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> ('a1
                  tree * (key * 'a1)) -> 'a1 coq_R_remove_min -> 'a2

                val coq_R_remove_min_rec :
                  ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1
                  tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1 ->
                  'a1 tree -> Z_as_Int.t -> __ -> ('a1 tree * (key * 'a1)) ->
                  'a1 coq_R_remove_min -> 'a2 -> 'a1 tree -> (key * 'a1) ->
                  __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> ('a1
                  tree * (key * 'a1)) -> 'a1 coq_R_remove_min -> 'a2

                type 'elt coq_R_merge = 'elt TabT.R.Defs.SigFM.Raw.Proofs.coq_R_merge =
                | R_merge_0 of 'elt tree * 'elt tree
                | R_merge_1 of 'elt tree * 'elt tree * 'elt tree * key * 
                   'elt * 'elt tree * Z_as_Int.t
                | R_merge_2 of 'elt tree * 'elt tree * 'elt tree * key * 
                   'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 
                   'elt * 'elt tree * Z_as_Int.t * 'elt tree * (key * 'elt)
                   * key * 'elt

                val coq_R_merge_rect :
                  ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
                  __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree ->
                  (key * 'a1) -> __ -> key -> 'a1 -> __ -> 'a2) -> 'a1 tree
                  -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_merge -> 'a2

                val coq_R_merge_rec :
                  ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
                  __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree ->
                  (key * 'a1) -> __ -> key -> 'a1 -> __ -> 'a2) -> 'a1 tree
                  -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_merge -> 'a2

                type 'elt coq_R_remove = 'elt TabT.R.Defs.SigFM.Raw.Proofs.coq_R_remove =
                | R_remove_0 of 'elt tree
                | R_remove_1 of 'elt tree * 'elt tree * key * 'elt
                   * 'elt tree * Z_as_Int.t * 'elt tree * 'elt coq_R_remove
                | R_remove_2 of 'elt tree * 'elt tree * key * 'elt
                   * 'elt tree * Z_as_Int.t
                | R_remove_3 of 'elt tree * 'elt tree * key * 'elt
                   * 'elt tree * Z_as_Int.t * 'elt tree * 'elt coq_R_remove

                val coq_R_remove_rect :
                  T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                  __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> ('a1
                  tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
                  __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key ->
                  'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree
                  -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 tree
                  -> 'a1 coq_R_remove -> 'a2

                val coq_R_remove_rec :
                  T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                  __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> ('a1
                  tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
                  __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key ->
                  'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree
                  -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 tree
                  -> 'a1 coq_R_remove -> 'a2

                type 'elt coq_R_concat = 'elt TabT.R.Defs.SigFM.Raw.Proofs.coq_R_concat =
                | R_concat_0 of 'elt tree * 'elt tree
                | R_concat_1 of 'elt tree * 'elt tree * 'elt tree * key
                   * 'elt * 'elt tree * Z_as_Int.t
                | R_concat_2 of 'elt tree * 'elt tree * 'elt tree * key
                   * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 
                   'elt * 'elt tree * Z_as_Int.t * 'elt tree * (key * 'elt)

                val coq_R_concat_rect :
                  ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
                  __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree ->
                  (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1
                  tree -> 'a1 coq_R_concat -> 'a2

                val coq_R_concat_rec :
                  ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
                  __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree ->
                  (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1
                  tree -> 'a1 coq_R_concat -> 'a2

                type 'elt coq_R_split = 'elt TabT.R.Defs.SigFM.Raw.Proofs.coq_R_split =
                | R_split_0 of 'elt tree
                | R_split_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t * 'elt triple * 'elt coq_R_split * 'elt tree
                   * 'elt option * 'elt tree
                | R_split_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t
                | R_split_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t * 'elt triple * 'elt coq_R_split * 'elt tree
                   * 'elt option * 'elt tree

                val coq_R_split_rect :
                  T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                  __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree ->
                  'a1 option -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                  __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
                  tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 triple -> 'a1
                  coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option -> 'a1 tree ->
                  __ -> 'a2) -> 'a1 tree -> 'a1 triple -> 'a1 coq_R_split ->
                  'a2

                val coq_R_split_rec :
                  T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                  __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree ->
                  'a1 option -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                  __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
                  tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 triple -> 'a1
                  coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option -> 'a1 tree ->
                  __ -> 'a2) -> 'a1 tree -> 'a1 triple -> 'a1 coq_R_split ->
                  'a2

                type ('elt, 'x) coq_R_map_option = ('elt, 'x) TabT.R.Defs.SigFM.Raw.Proofs.coq_R_map_option =
                | R_map_option_0 of 'elt tree
                | R_map_option_1 of 'elt tree * 'elt tree * key * 'elt
                   * 'elt tree * Z_as_Int.t * 'x * 'x tree
                   * ('elt, 'x) coq_R_map_option * 'x tree
                   * ('elt, 'x) coq_R_map_option
                | R_map_option_2 of 'elt tree * 'elt tree * key * 'elt
                   * 'elt tree * Z_as_Int.t * 'x tree
                   * ('elt, 'x) coq_R_map_option * 'x tree
                   * ('elt, 'x) coq_R_map_option

                val coq_R_map_option_rect :
                  (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) ->
                  ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> 'a2 -> __ -> 'a2 tree -> ('a1, 'a2)
                  coq_R_map_option -> 'a3 -> 'a2 tree -> ('a1, 'a2)
                  coq_R_map_option -> 'a3 -> 'a3) -> ('a1 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a2
                  tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2 tree ->
                  ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> 'a1 tree ->
                  'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3

                val coq_R_map_option_rec :
                  (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) ->
                  ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> 'a2 -> __ -> 'a2 tree -> ('a1, 'a2)
                  coq_R_map_option -> 'a3 -> 'a2 tree -> ('a1, 'a2)
                  coq_R_map_option -> 'a3 -> 'a3) -> ('a1 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a2
                  tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2 tree ->
                  ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> 'a1 tree ->
                  'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3

                type ('elt, 'x0, 'x) coq_R_map2_opt = ('elt, 'x0, 'x) TabT.R.Defs.SigFM.Raw.Proofs.coq_R_map2_opt =
                | R_map2_opt_0 of 'elt tree * 'x0 tree
                | R_map2_opt_1 of 'elt tree * 'x0 tree * 'elt tree * 
                   key * 'elt * 'elt tree * Z_as_Int.t
                | R_map2_opt_2 of 'elt tree * 'x0 tree * 'elt tree * 
                   key * 'elt * 'elt tree * Z_as_Int.t * 'x0 tree * key * 
                   'x0 * 'x0 tree * Z_as_Int.t * 'x0 tree * 'x0 option
                   * 'x0 tree * 'x * 'x tree * ('elt, 'x0, 'x) coq_R_map2_opt
                   * 'x tree * ('elt, 'x0, 'x) coq_R_map2_opt
                | R_map2_opt_3 of 'elt tree * 'x0 tree * 'elt tree * 
                   key * 'elt * 'elt tree * Z_as_Int.t * 'x0 tree * key * 
                   'x0 * 'x0 tree * Z_as_Int.t * 'x0 tree * 'x0 option
                   * 'x0 tree * 'x tree * ('elt, 'x0, 'x) coq_R_map2_opt
                   * 'x tree * ('elt, 'x0, 'x) coq_R_map2_opt

                val coq_R_map2_opt_rect :
                  (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree ->
                  'a3 tree) -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2
                  tree -> __ -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a4) ->
                  ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree
                  -> Z_as_Int.t -> __ -> 'a2 tree -> key -> 'a2 -> 'a2 tree
                  -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2 option -> 'a2 tree
                  -> __ -> 'a3 -> __ -> 'a3 tree -> ('a1, 'a2, 'a3)
                  coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
                  coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree ->
                  'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                  'a2 tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ ->
                  'a2 tree -> 'a2 option -> 'a2 tree -> __ -> __ -> 'a3 tree
                  -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree ->
                  ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1 tree
                  -> 'a2 tree -> 'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt
                  -> 'a4

                val coq_R_map2_opt_rec :
                  (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree ->
                  'a3 tree) -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2
                  tree -> __ -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a4) ->
                  ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree
                  -> Z_as_Int.t -> __ -> 'a2 tree -> key -> 'a2 -> 'a2 tree
                  -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2 option -> 'a2 tree
                  -> __ -> 'a3 -> __ -> 'a3 tree -> ('a1, 'a2, 'a3)
                  coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
                  coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree ->
                  'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                  'a2 tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ ->
                  'a2 tree -> 'a2 option -> 'a2 tree -> __ -> __ -> 'a3 tree
                  -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree ->
                  ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1 tree
                  -> 'a2 tree -> 'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt
                  -> 'a4

                val fold' :
                  (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

                val flatten_e : 'a1 enumeration -> (key * 'a1) list
               end
             end

            type 'elt bst =
              'elt Raw.tree
              (* singleton inductive, whose constructor was Bst *)

            val this : 'a1 bst -> 'a1 Raw.tree

            type 'elt t = 'elt bst

            type key = T_as_UCT.t

            val empty : 'a1 t

            val is_empty : 'a1 t -> bool

            val add : key -> 'a1 -> 'a1 t -> 'a1 t

            val remove : key -> 'a1 t -> 'a1 t

            val mem : key -> 'a1 t -> bool

            val find : key -> 'a1 t -> 'a1 option

            val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

            val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

            val map2 :
              ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t ->
              'a3 t

            val elements : 'a1 t -> (key * 'a1) list

            val cardinal : 'a1 t -> nat

            val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

            val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool
           end

          module SigFMF :
           sig
            val eqb : T_as_UCT.t -> T_as_UCT.t -> bool

            val coq_In_dec : 'a1 SigFM.t -> SigFM.key -> bool
           end

          module Strings :
           sig
            type coq_String = Ty.coq_Sigma list

            val coq_String_dec : coq_String -> coq_String -> bool

            val rm_empty : coq_String list -> Ty.coq_Sigma list list
           end

          module Regexes :
           sig
            type regex = TabT.R.Defs.Regexes.regex =
            | EmptySet
            | EmptyStr
            | Char of Ty.coq_Sigma
            | App of regex * regex
            | Union of regex * regex
            | Star of regex

            val regex_rect :
              'a1 -> 'a1 -> (Ty.coq_Sigma -> 'a1) -> (regex -> 'a1 -> regex
              -> 'a1 -> 'a1) -> (regex -> 'a1 -> regex -> 'a1 -> 'a1) ->
              (regex -> 'a1 -> 'a1) -> regex -> 'a1

            val regex_rec :
              'a1 -> 'a1 -> (Ty.coq_Sigma -> 'a1) -> (regex -> 'a1 -> regex
              -> 'a1 -> 'a1) -> (regex -> 'a1 -> regex -> 'a1 -> 'a1) ->
              (regex -> 'a1 -> 'a1) -> regex -> 'a1

            val regex_dec : regex -> regex -> bool

            val regex_eq : regex -> regex -> bool

            val nullable' : regex -> bool

            val nullable : regex -> bool

            val derivative : Ty.coq_Sigma -> regex -> regex

            val derivative_list : Ty.coq_Sigma list -> regex -> regex

            val re_compare : regex -> regex -> comparison
           end

          module Coq_regex_as_UCT :
           sig
            type t = Regexes.regex

            val compare : Regexes.regex -> Regexes.regex -> comparison
           end

          module Coq_regex_as_UOT :
           sig
            type t = Coq_regex_as_UCT.t

            val compare : t -> t -> t compare0

            val eq_dec : t -> t -> bool
           end

          module Coq_reFS :
           sig
            module X' :
             sig
              type t = Coq_regex_as_UCT.t

              val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

              val compare :
                Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> comparison
             end

            module MSet :
             sig
              module Raw :
               sig
                type elt = Coq_regex_as_UCT.t

                type tree = TabT.R.Defs.Coq_reFS.MSet.Raw.tree =
                | Leaf
                | Node of Z_as_Int.t * tree * Coq_regex_as_UCT.t * tree

                val empty : tree

                val is_empty : tree -> bool

                val mem : Coq_regex_as_UCT.t -> tree -> bool

                val min_elt : tree -> elt option

                val max_elt : tree -> elt option

                val choose : tree -> elt option

                val fold : (elt -> 'a1 -> 'a1) -> tree -> 'a1 -> 'a1

                val elements_aux :
                  Coq_regex_as_UCT.t list -> tree -> Coq_regex_as_UCT.t list

                val elements : tree -> Coq_regex_as_UCT.t list

                val rev_elements_aux :
                  Coq_regex_as_UCT.t list -> tree -> Coq_regex_as_UCT.t list

                val rev_elements : tree -> Coq_regex_as_UCT.t list

                val cardinal : tree -> nat

                val maxdepth : tree -> nat

                val mindepth : tree -> nat

                val for_all : (elt -> bool) -> tree -> bool

                val exists_ : (elt -> bool) -> tree -> bool

                type enumeration = TabT.R.Defs.Coq_reFS.MSet.Raw.enumeration =
                | End
                | More of elt * tree * enumeration

                val cons : tree -> enumeration -> enumeration

                val compare_more :
                  Coq_regex_as_UCT.t -> (enumeration -> comparison) ->
                  enumeration -> comparison

                val compare_cont :
                  tree -> (enumeration -> comparison) -> enumeration ->
                  comparison

                val compare_end : enumeration -> comparison

                val compare : tree -> tree -> comparison

                val equal : tree -> tree -> bool

                val subsetl :
                  (tree -> bool) -> Coq_regex_as_UCT.t -> tree -> bool

                val subsetr :
                  (tree -> bool) -> Coq_regex_as_UCT.t -> tree -> bool

                val subset : tree -> tree -> bool

                type t = tree

                val height : t -> Z_as_Int.t

                val singleton : Coq_regex_as_UCT.t -> tree

                val create : t -> Coq_regex_as_UCT.t -> t -> tree

                val assert_false : t -> Coq_regex_as_UCT.t -> t -> tree

                val bal : t -> Coq_regex_as_UCT.t -> t -> tree

                val add : Coq_regex_as_UCT.t -> tree -> tree

                val join : tree -> elt -> t -> t

                val remove_min : tree -> elt -> t -> t * elt

                val merge : tree -> tree -> tree

                val remove : Coq_regex_as_UCT.t -> tree -> tree

                val concat : tree -> tree -> tree

                type triple = TabT.R.Defs.Coq_reFS.MSet.Raw.triple = { 
                t_left : t; t_in : bool; t_right : t }

                val t_left : triple -> t

                val t_in : triple -> bool

                val t_right : triple -> t

                val split : Coq_regex_as_UCT.t -> tree -> triple

                val inter : tree -> tree -> tree

                val diff : tree -> tree -> tree

                val union : tree -> tree -> tree

                val filter : (elt -> bool) -> tree -> tree

                val partition : (elt -> bool) -> t -> t * t

                val ltb_tree : Coq_regex_as_UCT.t -> tree -> bool

                val gtb_tree : Coq_regex_as_UCT.t -> tree -> bool

                val isok : tree -> bool

                module MX :
                 sig
                  module OrderTac :
                   sig
                    module OTF :
                     sig
                      type t = Coq_regex_as_UCT.t

                      val compare :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> comparison

                      val eq_dec :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                     end

                    module TO :
                     sig
                      type t = Coq_regex_as_UCT.t

                      val compare :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> comparison

                      val eq_dec :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                     end
                   end

                  val eq_dec :
                    Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                  val lt_dec :
                    Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                  val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                 end

                type coq_R_min_elt = TabT.R.Defs.Coq_reFS.MSet.Raw.coq_R_min_elt =
                | R_min_elt_0 of tree
                | R_min_elt_1 of tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree
                | R_min_elt_2 of tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree * elt option * coq_R_min_elt

                type coq_R_max_elt = TabT.R.Defs.Coq_reFS.MSet.Raw.coq_R_max_elt =
                | R_max_elt_0 of tree
                | R_max_elt_1 of tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree
                | R_max_elt_2 of tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree * elt option * coq_R_max_elt

                module L :
                 sig
                  module MO :
                   sig
                    module OrderTac :
                     sig
                      module OTF :
                       sig
                        type t = Coq_regex_as_UCT.t

                        val compare :
                          Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t ->
                          comparison

                        val eq_dec :
                          Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                       end

                      module TO :
                       sig
                        type t = Coq_regex_as_UCT.t

                        val compare :
                          Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t ->
                          comparison

                        val eq_dec :
                          Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                       end
                     end

                    val eq_dec :
                      Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                    val lt_dec :
                      Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                    val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                   end
                 end

                val flatten_e : enumeration -> elt list

                type coq_R_bal = TabT.R.Defs.Coq_reFS.MSet.Raw.coq_R_bal =
                | R_bal_0 of t * Coq_regex_as_UCT.t * t
                | R_bal_1 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * 
                   tree * Coq_regex_as_UCT.t * tree
                | R_bal_2 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * 
                   tree * Coq_regex_as_UCT.t * tree
                | R_bal_3 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * 
                   tree * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree
                | R_bal_4 of t * Coq_regex_as_UCT.t * t
                | R_bal_5 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * 
                   tree * Coq_regex_as_UCT.t * tree
                | R_bal_6 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * 
                   tree * Coq_regex_as_UCT.t * tree
                | R_bal_7 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * 
                   tree * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree
                | R_bal_8 of t * Coq_regex_as_UCT.t * t

                type coq_R_remove_min = TabT.R.Defs.Coq_reFS.MSet.Raw.coq_R_remove_min =
                | R_remove_min_0 of tree * elt * t
                | R_remove_min_1 of tree * elt * t * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree * (t * elt) * coq_R_remove_min
                   * t * elt

                type coq_R_merge = TabT.R.Defs.Coq_reFS.MSet.Raw.coq_R_merge =
                | R_merge_0 of tree * tree
                | R_merge_1 of tree * tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree
                | R_merge_2 of tree * tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree * t * elt

                type coq_R_concat = TabT.R.Defs.Coq_reFS.MSet.Raw.coq_R_concat =
                | R_concat_0 of tree * tree
                | R_concat_1 of tree * tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree
                | R_concat_2 of tree * tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree * t * elt

                type coq_R_inter = TabT.R.Defs.Coq_reFS.MSet.Raw.coq_R_inter =
                | R_inter_0 of tree * tree
                | R_inter_1 of tree * tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree
                | R_inter_2 of tree * tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree * t * bool * t * tree
                   * coq_R_inter * tree * coq_R_inter
                | R_inter_3 of tree * tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree * t * bool * t * tree
                   * coq_R_inter * tree * coq_R_inter

                type coq_R_diff = TabT.R.Defs.Coq_reFS.MSet.Raw.coq_R_diff =
                | R_diff_0 of tree * tree
                | R_diff_1 of tree * tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree
                | R_diff_2 of tree * tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree * t * bool * t * tree
                   * coq_R_diff * tree * coq_R_diff
                | R_diff_3 of tree * tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree * t * bool * t * tree
                   * coq_R_diff * tree * coq_R_diff

                type coq_R_union = TabT.R.Defs.Coq_reFS.MSet.Raw.coq_R_union =
                | R_union_0 of tree * tree
                | R_union_1 of tree * tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree
                | R_union_2 of tree * tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree * t * bool * t * tree
                   * coq_R_union * tree * coq_R_union
               end

              module E :
               sig
                type t = Coq_regex_as_UCT.t

                val compare :
                  Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> comparison

                val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
               end

              type elt = Coq_regex_as_UCT.t

              type t_ =
                Raw.t
                (* singleton inductive, whose constructor was Mkt *)

              val this : t_ -> Raw.t

              type t = t_

              val mem : elt -> t -> bool

              val add : elt -> t -> t

              val remove : elt -> t -> t

              val singleton : elt -> t

              val union : t -> t -> t

              val inter : t -> t -> t

              val diff : t -> t -> t

              val equal : t -> t -> bool

              val subset : t -> t -> bool

              val empty : t

              val is_empty : t -> bool

              val elements : t -> elt list

              val choose : t -> elt option

              val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

              val cardinal : t -> nat

              val filter : (elt -> bool) -> t -> t

              val for_all : (elt -> bool) -> t -> bool

              val exists_ : (elt -> bool) -> t -> bool

              val partition : (elt -> bool) -> t -> t * t

              val eq_dec : t -> t -> bool

              val compare : t -> t -> comparison

              val min_elt : t -> elt option

              val max_elt : t -> elt option
             end

            type elt = Coq_regex_as_UCT.t

            type t = MSet.t

            val empty : t

            val is_empty : t -> bool

            val mem : elt -> t -> bool

            val add : elt -> t -> t

            val singleton : elt -> t

            val remove : elt -> t -> t

            val union : t -> t -> t

            val inter : t -> t -> t

            val diff : t -> t -> t

            val eq_dec : t -> t -> bool

            val equal : t -> t -> bool

            val subset : t -> t -> bool

            val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

            val for_all : (elt -> bool) -> t -> bool

            val exists_ : (elt -> bool) -> t -> bool

            val filter : (elt -> bool) -> t -> t

            val partition : (elt -> bool) -> t -> t * t

            val cardinal : t -> nat

            val elements : t -> elt list

            val choose : t -> elt option

            module MF :
             sig
              val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
             end

            val min_elt : t -> elt option

            val max_elt : t -> elt option

            val compare : t -> t -> t compare0

            module E :
             sig
              type t = Coq_regex_as_UCT.t

              val compare :
                Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t ->
                Coq_regex_as_UCT.t compare0

              val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
             end
           end

          module Coq_reFSF :
           sig
            val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
           end

          module Coq_reFM :
           sig
            module E :
             sig
              type t = Coq_regex_as_UCT.t

              val compare :
                Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t ->
                Coq_regex_as_UCT.t compare0

              val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
             end

            module Raw :
             sig
              type key = Coq_regex_as_UCT.t

              type 'elt tree = 'elt TabT.R.Defs.Coq_reFM.Raw.tree =
              | Leaf
              | Node of 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t

              val tree_rect :
                'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
                Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

              val tree_rec :
                'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
                Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

              val height : 'a1 tree -> Z_as_Int.t

              val cardinal : 'a1 tree -> nat

              val empty : 'a1 tree

              val is_empty : 'a1 tree -> bool

              val mem : Coq_regex_as_UCT.t -> 'a1 tree -> bool

              val find : Coq_regex_as_UCT.t -> 'a1 tree -> 'a1 option

              val create : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

              val assert_false :
                'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

              val bal : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

              val add : key -> 'a1 -> 'a1 tree -> 'a1 tree

              val remove_min :
                'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree * (key * 'a1)

              val merge : 'a1 tree -> 'a1 tree -> 'a1 tree

              val remove : Coq_regex_as_UCT.t -> 'a1 tree -> 'a1 tree

              val join : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

              type 'elt triple = 'elt TabT.R.Defs.Coq_reFM.Raw.triple = { 
              t_left : 'elt tree; t_opt : 'elt option; t_right : 'elt tree }

              val t_left : 'a1 triple -> 'a1 tree

              val t_opt : 'a1 triple -> 'a1 option

              val t_right : 'a1 triple -> 'a1 tree

              val split : Coq_regex_as_UCT.t -> 'a1 tree -> 'a1 triple

              val concat : 'a1 tree -> 'a1 tree -> 'a1 tree

              val elements_aux :
                (key * 'a1) list -> 'a1 tree -> (key * 'a1) list

              val elements : 'a1 tree -> (key * 'a1) list

              val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

              type 'elt enumeration = 'elt TabT.R.Defs.Coq_reFM.Raw.enumeration =
              | End
              | More of key * 'elt * 'elt tree * 'elt enumeration

              val enumeration_rect :
                'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 ->
                'a2) -> 'a1 enumeration -> 'a2

              val enumeration_rec :
                'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 ->
                'a2) -> 'a1 enumeration -> 'a2

              val cons : 'a1 tree -> 'a1 enumeration -> 'a1 enumeration

              val equal_more :
                ('a1 -> 'a1 -> bool) -> Coq_regex_as_UCT.t -> 'a1 -> ('a1
                enumeration -> bool) -> 'a1 enumeration -> bool

              val equal_cont :
                ('a1 -> 'a1 -> bool) -> 'a1 tree -> ('a1 enumeration -> bool)
                -> 'a1 enumeration -> bool

              val equal_end : 'a1 enumeration -> bool

              val equal : ('a1 -> 'a1 -> bool) -> 'a1 tree -> 'a1 tree -> bool

              val map : ('a1 -> 'a2) -> 'a1 tree -> 'a2 tree

              val mapi : (key -> 'a1 -> 'a2) -> 'a1 tree -> 'a2 tree

              val map_option :
                (key -> 'a1 -> 'a2 option) -> 'a1 tree -> 'a2 tree

              val map2_opt :
                (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3
                tree) -> ('a2 tree -> 'a3 tree) -> 'a1 tree -> 'a2 tree ->
                'a3 tree

              val map2 :
                ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 tree -> 'a2
                tree -> 'a3 tree

              module Proofs :
               sig
                module MX :
                 sig
                  module TO :
                   sig
                    type t = Coq_regex_as_UCT.t
                   end

                  module IsTO :
                   sig
                   end

                  module OrderTac :
                   sig
                   end

                  val eq_dec :
                    Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                  val lt_dec :
                    Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                  val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                 end

                module PX :
                 sig
                  module MO :
                   sig
                    module TO :
                     sig
                      type t = Coq_regex_as_UCT.t
                     end

                    module IsTO :
                     sig
                     end

                    module OrderTac :
                     sig
                     end

                    val eq_dec :
                      Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                    val lt_dec :
                      Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                    val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                   end
                 end

                module L :
                 sig
                  module MX :
                   sig
                    module TO :
                     sig
                      type t = Coq_regex_as_UCT.t
                     end

                    module IsTO :
                     sig
                     end

                    module OrderTac :
                     sig
                     end

                    val eq_dec :
                      Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                    val lt_dec :
                      Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                    val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                   end

                  module PX :
                   sig
                    module MO :
                     sig
                      module TO :
                       sig
                        type t = Coq_regex_as_UCT.t
                       end

                      module IsTO :
                       sig
                       end

                      module OrderTac :
                       sig
                       end

                      val eq_dec :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                      val lt_dec :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                      val eqb :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                     end
                   end

                  type key = Coq_regex_as_UCT.t

                  type 'elt t = (Coq_regex_as_UCT.t * 'elt) list

                  val empty : 'a1 t

                  val is_empty : 'a1 t -> bool

                  val mem : key -> 'a1 t -> bool

                  type 'elt coq_R_mem = 'elt TabT.R.Defs.Coq_reFM.Raw.Proofs.L.coq_R_mem =
                  | R_mem_0 of 'elt t
                  | R_mem_1 of 'elt t * Coq_regex_as_UCT.t * 'elt
                     * (Coq_regex_as_UCT.t * 'elt) list
                  | R_mem_2 of 'elt t * Coq_regex_as_UCT.t * 'elt
                     * (Coq_regex_as_UCT.t * 'elt) list
                  | R_mem_3 of 'elt t * Coq_regex_as_UCT.t * 'elt
                     * (Coq_regex_as_UCT.t * 'elt) list * bool
                     * 'elt coq_R_mem

                  val coq_R_mem_rect :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 ->
                    'a2) -> 'a1 t -> bool -> 'a1 coq_R_mem -> 'a2

                  val coq_R_mem_rec :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 ->
                    'a2) -> 'a1 t -> bool -> 'a1 coq_R_mem -> 'a2

                  val mem_rect :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                  val mem_rec :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                  val coq_R_mem_correct :
                    key -> 'a1 t -> bool -> 'a1 coq_R_mem

                  val find : key -> 'a1 t -> 'a1 option

                  type 'elt coq_R_find = 'elt TabT.R.Defs.Coq_reFM.Raw.Proofs.L.coq_R_find =
                  | R_find_0 of 'elt t
                  | R_find_1 of 'elt t * Coq_regex_as_UCT.t * 'elt
                     * (Coq_regex_as_UCT.t * 'elt) list
                  | R_find_2 of 'elt t * Coq_regex_as_UCT.t * 'elt
                     * (Coq_regex_as_UCT.t * 'elt) list
                  | R_find_3 of 'elt t * Coq_regex_as_UCT.t * 'elt
                     * (Coq_regex_as_UCT.t * 'elt) list * 'elt option
                     * 'elt coq_R_find

                  val coq_R_find_rect :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find ->
                    'a2 -> 'a2) -> 'a1 t -> 'a1 option -> 'a1 coq_R_find ->
                    'a2

                  val coq_R_find_rec :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find ->
                    'a2 -> 'a2) -> 'a1 t -> 'a1 option -> 'a1 coq_R_find ->
                    'a2

                  val find_rect :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                  val find_rec :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                  val coq_R_find_correct :
                    key -> 'a1 t -> 'a1 option -> 'a1 coq_R_find

                  val add : key -> 'a1 -> 'a1 t -> 'a1 t

                  type 'elt coq_R_add = 'elt TabT.R.Defs.Coq_reFM.Raw.Proofs.L.coq_R_add =
                  | R_add_0 of 'elt t
                  | R_add_1 of 'elt t * Coq_regex_as_UCT.t * 'elt
                     * (Coq_regex_as_UCT.t * 'elt) list
                  | R_add_2 of 'elt t * Coq_regex_as_UCT.t * 'elt
                     * (Coq_regex_as_UCT.t * 'elt) list
                  | R_add_3 of 'elt t * Coq_regex_as_UCT.t * 'elt
                     * (Coq_regex_as_UCT.t * 'elt) list * 'elt t
                     * 'elt coq_R_add

                  val coq_R_add_rect :
                    key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_add -> 'a2
                    -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_add -> 'a2

                  val coq_R_add_rec :
                    key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_add -> 'a2
                    -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_add -> 'a2

                  val add_rect :
                    key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                  val add_rec :
                    key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                  val coq_R_add_correct :
                    key -> 'a1 -> 'a1 t -> 'a1 t -> 'a1 coq_R_add

                  val remove : key -> 'a1 t -> 'a1 t

                  type 'elt coq_R_remove = 'elt TabT.R.Defs.Coq_reFM.Raw.Proofs.L.coq_R_remove =
                  | R_remove_0 of 'elt t
                  | R_remove_1 of 'elt t * Coq_regex_as_UCT.t * 'elt
                     * (Coq_regex_as_UCT.t * 'elt) list
                  | R_remove_2 of 'elt t * Coq_regex_as_UCT.t * 'elt
                     * (Coq_regex_as_UCT.t * 'elt) list
                  | R_remove_3 of 'elt t * Coq_regex_as_UCT.t * 'elt
                     * (Coq_regex_as_UCT.t * 'elt) list * 'elt t
                     * 'elt coq_R_remove

                  val coq_R_remove_rect :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_remove ->
                    'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove -> 'a2

                  val coq_R_remove_rec :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_remove ->
                    'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove -> 'a2

                  val remove_rect :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                  val remove_rec :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                  val coq_R_remove_correct :
                    key -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove

                  val elements : 'a1 t -> 'a1 t

                  val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

                  type ('elt, 'a) coq_R_fold = ('elt, 'a) TabT.R.Defs.Coq_reFM.Raw.Proofs.L.coq_R_fold =
                  | R_fold_0 of 'elt t * 'a
                  | R_fold_1 of 'elt t * 'a * Coq_regex_as_UCT.t * 'elt
                     * (Coq_regex_as_UCT.t * 'elt) list * 'a
                     * ('elt, 'a) coq_R_fold

                  val coq_R_fold_rect :
                    (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3)
                    -> ('a1 t -> 'a2 -> Coq_regex_as_UCT.t -> 'a1 ->
                    (Coq_regex_as_UCT.t * 'a1) list -> __ -> 'a2 -> ('a1,
                    'a2) coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a2 ->
                    ('a1, 'a2) coq_R_fold -> 'a3

                  val coq_R_fold_rec :
                    (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3)
                    -> ('a1 t -> 'a2 -> Coq_regex_as_UCT.t -> 'a1 ->
                    (Coq_regex_as_UCT.t * 'a1) list -> __ -> 'a2 -> ('a1,
                    'a2) coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a2 ->
                    ('a1, 'a2) coq_R_fold -> 'a3

                  val fold_rect :
                    (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3)
                    -> ('a1 t -> 'a2 -> Coq_regex_as_UCT.t -> 'a1 ->
                    (Coq_regex_as_UCT.t * 'a1) list -> __ -> 'a3 -> 'a3) ->
                    'a1 t -> 'a2 -> 'a3

                  val fold_rec :
                    (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3)
                    -> ('a1 t -> 'a2 -> Coq_regex_as_UCT.t -> 'a1 ->
                    (Coq_regex_as_UCT.t * 'a1) list -> __ -> 'a3 -> 'a3) ->
                    'a1 t -> 'a2 -> 'a3

                  val coq_R_fold_correct :
                    (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2 ->
                    ('a1, 'a2) coq_R_fold

                  val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool

                  type 'elt coq_R_equal = 'elt TabT.R.Defs.Coq_reFM.Raw.Proofs.L.coq_R_equal =
                  | R_equal_0 of 'elt t * 'elt t
                  | R_equal_1 of 'elt t * 'elt t * Coq_regex_as_UCT.t * 
                     'elt * (Coq_regex_as_UCT.t * 'elt) list
                     * Coq_regex_as_UCT.t * 'elt
                     * (Coq_regex_as_UCT.t * 'elt) list * bool
                     * 'elt coq_R_equal
                  | R_equal_2 of 'elt t * 'elt t * Coq_regex_as_UCT.t * 
                     'elt * (Coq_regex_as_UCT.t * 'elt) list
                     * Coq_regex_as_UCT.t * 'elt
                     * (Coq_regex_as_UCT.t * 'elt) list
                     * Coq_regex_as_UCT.t compare0
                  | R_equal_3 of 'elt t * 'elt t * 'elt t * 'elt t

                  val coq_R_equal_rect :
                    ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                    'a2) -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                    (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> bool -> 'a1 coq_R_equal -> 'a2
                    -> 'a2) -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1
                    -> (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> Coq_regex_as_UCT.t compare0 -> __ -> __ ->
                    'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ ->
                    __ -> 'a2) -> 'a1 t -> 'a1 t -> bool -> 'a1 coq_R_equal
                    -> 'a2

                  val coq_R_equal_rec :
                    ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                    'a2) -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                    (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> bool -> 'a1 coq_R_equal -> 'a2
                    -> 'a2) -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1
                    -> (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> Coq_regex_as_UCT.t compare0 -> __ -> __ ->
                    'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ ->
                    __ -> 'a2) -> 'a1 t -> 'a1 t -> bool -> 'a1 coq_R_equal
                    -> 'a2

                  val equal_rect :
                    ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                    'a2) -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                    (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t
                    -> Coq_regex_as_UCT.t -> 'a1 ->
                    (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> Coq_regex_as_UCT.t compare0 -> __ -> __ ->
                    'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ ->
                    __ -> 'a2) -> 'a1 t -> 'a1 t -> 'a2

                  val equal_rec :
                    ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                    'a2) -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                    (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t
                    -> Coq_regex_as_UCT.t -> 'a1 ->
                    (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> Coq_regex_as_UCT.t compare0 -> __ -> __ ->
                    'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ ->
                    __ -> 'a2) -> 'a1 t -> 'a1 t -> 'a2

                  val coq_R_equal_correct :
                    ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool -> 'a1
                    coq_R_equal

                  val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

                  val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

                  val option_cons :
                    key -> 'a1 option -> (key * 'a1) list -> (key * 'a1) list

                  val map2_l :
                    ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a3 t

                  val map2_r :
                    ('a1 option -> 'a2 option -> 'a3 option) -> 'a2 t -> 'a3 t

                  val map2 :
                    ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2
                    t -> 'a3 t

                  val combine : 'a1 t -> 'a2 t -> ('a1 option * 'a2 option) t

                  val fold_right_pair :
                    ('a1 -> 'a2 -> 'a3 -> 'a3) -> ('a1 * 'a2) list -> 'a3 ->
                    'a3

                  val map2_alt :
                    ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2
                    t -> (key * 'a3) list

                  val at_least_one :
                    'a1 option -> 'a2 option -> ('a1 option * 'a2 option)
                    option

                  val at_least_one_then_f :
                    ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 option ->
                    'a2 option -> 'a3 option
                 end

                type 'elt coq_R_mem = 'elt TabT.R.Defs.Coq_reFM.Raw.Proofs.coq_R_mem =
                | R_mem_0 of 'elt tree
                | R_mem_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t * bool * 'elt coq_R_mem
                | R_mem_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t
                | R_mem_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t * bool * 'elt coq_R_mem

                val coq_R_mem_rect :
                  Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree
                  -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                  -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> ('a1
                  tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
                  __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key ->
                  'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> bool ->
                  'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 tree -> bool -> 'a1
                  coq_R_mem -> 'a2

                val coq_R_mem_rec :
                  Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree
                  -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                  -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> ('a1
                  tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
                  __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key ->
                  'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> bool ->
                  'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 tree -> bool -> 'a1
                  coq_R_mem -> 'a2

                type 'elt coq_R_find = 'elt TabT.R.Defs.Coq_reFM.Raw.Proofs.coq_R_find =
                | R_find_0 of 'elt tree
                | R_find_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t * 'elt option * 'elt coq_R_find
                | R_find_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t
                | R_find_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t * 'elt option * 'elt coq_R_find

                val coq_R_find_rect :
                  Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree
                  -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                  -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2)
                  -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                  __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> 'a1
                  tree -> 'a1 option -> 'a1 coq_R_find -> 'a2

                val coq_R_find_rec :
                  Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree
                  -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                  -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2)
                  -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                  __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> 'a1
                  tree -> 'a1 option -> 'a1 coq_R_find -> 'a2

                type 'elt coq_R_bal = 'elt TabT.R.Defs.Coq_reFM.Raw.Proofs.coq_R_bal =
                | R_bal_0 of 'elt tree * key * 'elt * 'elt tree
                | R_bal_1 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                   * key * 'elt * 'elt tree * Z_as_Int.t
                | R_bal_2 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                   * key * 'elt * 'elt tree * Z_as_Int.t
                | R_bal_3 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                   * key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * 
                   key * 'elt * 'elt tree * Z_as_Int.t
                | R_bal_4 of 'elt tree * key * 'elt * 'elt tree
                | R_bal_5 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                   * key * 'elt * 'elt tree * Z_as_Int.t
                | R_bal_6 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                   * key * 'elt * 'elt tree * Z_as_Int.t
                | R_bal_7 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                   * key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * 
                   key * 'elt * 'elt tree * Z_as_Int.t
                | R_bal_8 of 'elt tree * key * 'elt * 'elt tree

                val coq_R_bal_rect :
                  ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ ->
                  'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ ->
                  'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                  __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree ->
                  __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree ->
                  key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key ->
                  'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree
                  -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2) ->
                  ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __
                  -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __
                  -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key ->
                  'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key
                  -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> __ ->
                  'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ ->
                  __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 ->
                  'a1 tree -> Z_as_Int.t -> __ -> 'a2) -> ('a1 tree -> key ->
                  'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a2) -> 'a1 tree
                  -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_bal ->
                  'a2

                val coq_R_bal_rec :
                  ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ ->
                  'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ ->
                  'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                  __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree ->
                  __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree ->
                  key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key ->
                  'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree
                  -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2) ->
                  ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __
                  -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __
                  -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key ->
                  'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key
                  -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> __ ->
                  'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ ->
                  __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 ->
                  'a1 tree -> Z_as_Int.t -> __ -> 'a2) -> ('a1 tree -> key ->
                  'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a2) -> 'a1 tree
                  -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_bal ->
                  'a2

                type 'elt coq_R_add = 'elt TabT.R.Defs.Coq_reFM.Raw.Proofs.coq_R_add =
                | R_add_0 of 'elt tree
                | R_add_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t * 'elt tree * 'elt coq_R_add
                | R_add_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t
                | R_add_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t * 'elt tree * 'elt coq_R_add

                val coq_R_add_rect :
                  key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                  __ -> 'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1 tree
                  -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                  -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
                  -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree ->
                  'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1
                  coq_R_add -> 'a2

                val coq_R_add_rec :
                  key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                  __ -> 'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1 tree
                  -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                  -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
                  -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree ->
                  'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1
                  coq_R_add -> 'a2

                type 'elt coq_R_remove_min = 'elt TabT.R.Defs.Coq_reFM.Raw.Proofs.coq_R_remove_min =
                | R_remove_min_0 of 'elt tree * key * 'elt * 'elt tree
                | R_remove_min_1 of 'elt tree * key * 'elt * 'elt tree
                   * 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t
                   * ('elt tree * (key * 'elt)) * 'elt coq_R_remove_min
                   * 'elt tree * (key * 'elt)

                val coq_R_remove_min_rect :
                  ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1
                  tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1 ->
                  'a1 tree -> Z_as_Int.t -> __ -> ('a1 tree * (key * 'a1)) ->
                  'a1 coq_R_remove_min -> 'a2 -> 'a1 tree -> (key * 'a1) ->
                  __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> ('a1
                  tree * (key * 'a1)) -> 'a1 coq_R_remove_min -> 'a2

                val coq_R_remove_min_rec :
                  ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1
                  tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1 ->
                  'a1 tree -> Z_as_Int.t -> __ -> ('a1 tree * (key * 'a1)) ->
                  'a1 coq_R_remove_min -> 'a2 -> 'a1 tree -> (key * 'a1) ->
                  __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> ('a1
                  tree * (key * 'a1)) -> 'a1 coq_R_remove_min -> 'a2

                type 'elt coq_R_merge = 'elt TabT.R.Defs.Coq_reFM.Raw.Proofs.coq_R_merge =
                | R_merge_0 of 'elt tree * 'elt tree
                | R_merge_1 of 'elt tree * 'elt tree * 'elt tree * key * 
                   'elt * 'elt tree * Z_as_Int.t
                | R_merge_2 of 'elt tree * 'elt tree * 'elt tree * key * 
                   'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 
                   'elt * 'elt tree * Z_as_Int.t * 'elt tree * (key * 'elt)
                   * key * 'elt

                val coq_R_merge_rect :
                  ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
                  __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree ->
                  (key * 'a1) -> __ -> key -> 'a1 -> __ -> 'a2) -> 'a1 tree
                  -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_merge -> 'a2

                val coq_R_merge_rec :
                  ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
                  __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree ->
                  (key * 'a1) -> __ -> key -> 'a1 -> __ -> 'a2) -> 'a1 tree
                  -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_merge -> 'a2

                type 'elt coq_R_remove = 'elt TabT.R.Defs.Coq_reFM.Raw.Proofs.coq_R_remove =
                | R_remove_0 of 'elt tree
                | R_remove_1 of 'elt tree * 'elt tree * key * 'elt
                   * 'elt tree * Z_as_Int.t * 'elt tree * 'elt coq_R_remove
                | R_remove_2 of 'elt tree * 'elt tree * key * 'elt
                   * 'elt tree * Z_as_Int.t
                | R_remove_3 of 'elt tree * 'elt tree * key * 'elt
                   * 'elt tree * Z_as_Int.t * 'elt tree * 'elt coq_R_remove

                val coq_R_remove_rect :
                  Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree
                  -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                  -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2)
                  -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                  __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> 'a1
                  tree -> 'a1 tree -> 'a1 coq_R_remove -> 'a2

                val coq_R_remove_rec :
                  Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree
                  -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                  -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2)
                  -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                  __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> 'a1
                  tree -> 'a1 tree -> 'a1 coq_R_remove -> 'a2

                type 'elt coq_R_concat = 'elt TabT.R.Defs.Coq_reFM.Raw.Proofs.coq_R_concat =
                | R_concat_0 of 'elt tree * 'elt tree
                | R_concat_1 of 'elt tree * 'elt tree * 'elt tree * key
                   * 'elt * 'elt tree * Z_as_Int.t
                | R_concat_2 of 'elt tree * 'elt tree * 'elt tree * key
                   * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 
                   'elt * 'elt tree * Z_as_Int.t * 'elt tree * (key * 'elt)

                val coq_R_concat_rect :
                  ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
                  __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree ->
                  (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1
                  tree -> 'a1 coq_R_concat -> 'a2

                val coq_R_concat_rec :
                  ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
                  __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree ->
                  (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1
                  tree -> 'a1 coq_R_concat -> 'a2

                type 'elt coq_R_split = 'elt TabT.R.Defs.Coq_reFM.Raw.Proofs.coq_R_split =
                | R_split_0 of 'elt tree
                | R_split_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t * 'elt triple * 'elt coq_R_split * 'elt tree
                   * 'elt option * 'elt tree
                | R_split_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t
                | R_split_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t * 'elt triple * 'elt coq_R_split * 'elt tree
                   * 'elt option * 'elt tree

                val coq_R_split_rect :
                  Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree
                  -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                  -> __ -> __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1
                  tree -> 'a1 option -> 'a1 tree -> __ -> 'a2) -> ('a1 tree
                  -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                  -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
                  -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 triple
                  -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option -> 'a1
                  tree -> __ -> 'a2) -> 'a1 tree -> 'a1 triple -> 'a1
                  coq_R_split -> 'a2

                val coq_R_split_rec :
                  Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree
                  -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                  -> __ -> __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1
                  tree -> 'a1 option -> 'a1 tree -> __ -> 'a2) -> ('a1 tree
                  -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                  -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
                  -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 triple
                  -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option -> 'a1
                  tree -> __ -> 'a2) -> 'a1 tree -> 'a1 triple -> 'a1
                  coq_R_split -> 'a2

                type ('elt, 'x) coq_R_map_option = ('elt, 'x) TabT.R.Defs.Coq_reFM.Raw.Proofs.coq_R_map_option =
                | R_map_option_0 of 'elt tree
                | R_map_option_1 of 'elt tree * 'elt tree * key * 'elt
                   * 'elt tree * Z_as_Int.t * 'x * 'x tree
                   * ('elt, 'x) coq_R_map_option * 'x tree
                   * ('elt, 'x) coq_R_map_option
                | R_map_option_2 of 'elt tree * 'elt tree * key * 'elt
                   * 'elt tree * Z_as_Int.t * 'x tree
                   * ('elt, 'x) coq_R_map_option * 'x tree
                   * ('elt, 'x) coq_R_map_option

                val coq_R_map_option_rect :
                  (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) ->
                  ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> 'a2 -> __ -> 'a2 tree -> ('a1, 'a2)
                  coq_R_map_option -> 'a3 -> 'a2 tree -> ('a1, 'a2)
                  coq_R_map_option -> 'a3 -> 'a3) -> ('a1 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a2
                  tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2 tree ->
                  ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> 'a1 tree ->
                  'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3

                val coq_R_map_option_rec :
                  (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) ->
                  ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> 'a2 -> __ -> 'a2 tree -> ('a1, 'a2)
                  coq_R_map_option -> 'a3 -> 'a2 tree -> ('a1, 'a2)
                  coq_R_map_option -> 'a3 -> 'a3) -> ('a1 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a2
                  tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2 tree ->
                  ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> 'a1 tree ->
                  'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3

                type ('elt, 'x0, 'x) coq_R_map2_opt = ('elt, 'x0, 'x) TabT.R.Defs.Coq_reFM.Raw.Proofs.coq_R_map2_opt =
                | R_map2_opt_0 of 'elt tree * 'x0 tree
                | R_map2_opt_1 of 'elt tree * 'x0 tree * 'elt tree * 
                   key * 'elt * 'elt tree * Z_as_Int.t
                | R_map2_opt_2 of 'elt tree * 'x0 tree * 'elt tree * 
                   key * 'elt * 'elt tree * Z_as_Int.t * 'x0 tree * key * 
                   'x0 * 'x0 tree * Z_as_Int.t * 'x0 tree * 'x0 option
                   * 'x0 tree * 'x * 'x tree * ('elt, 'x0, 'x) coq_R_map2_opt
                   * 'x tree * ('elt, 'x0, 'x) coq_R_map2_opt
                | R_map2_opt_3 of 'elt tree * 'x0 tree * 'elt tree * 
                   key * 'elt * 'elt tree * Z_as_Int.t * 'x0 tree * key * 
                   'x0 * 'x0 tree * Z_as_Int.t * 'x0 tree * 'x0 option
                   * 'x0 tree * 'x tree * ('elt, 'x0, 'x) coq_R_map2_opt
                   * 'x tree * ('elt, 'x0, 'x) coq_R_map2_opt

                val coq_R_map2_opt_rect :
                  (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree ->
                  'a3 tree) -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2
                  tree -> __ -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a4) ->
                  ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree
                  -> Z_as_Int.t -> __ -> 'a2 tree -> key -> 'a2 -> 'a2 tree
                  -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2 option -> 'a2 tree
                  -> __ -> 'a3 -> __ -> 'a3 tree -> ('a1, 'a2, 'a3)
                  coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
                  coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree ->
                  'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                  'a2 tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ ->
                  'a2 tree -> 'a2 option -> 'a2 tree -> __ -> __ -> 'a3 tree
                  -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree ->
                  ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1 tree
                  -> 'a2 tree -> 'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt
                  -> 'a4

                val coq_R_map2_opt_rec :
                  (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree ->
                  'a3 tree) -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2
                  tree -> __ -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a4) ->
                  ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree
                  -> Z_as_Int.t -> __ -> 'a2 tree -> key -> 'a2 -> 'a2 tree
                  -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2 option -> 'a2 tree
                  -> __ -> 'a3 -> __ -> 'a3 tree -> ('a1, 'a2, 'a3)
                  coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
                  coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree ->
                  'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                  'a2 tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ ->
                  'a2 tree -> 'a2 option -> 'a2 tree -> __ -> __ -> 'a3 tree
                  -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree ->
                  ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1 tree
                  -> 'a2 tree -> 'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt
                  -> 'a4

                val fold' :
                  (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

                val flatten_e : 'a1 enumeration -> (key * 'a1) list
               end
             end

            type 'elt bst =
              'elt Raw.tree
              (* singleton inductive, whose constructor was Bst *)

            val this : 'a1 bst -> 'a1 Raw.tree

            type 'elt t = 'elt bst

            type key = Coq_regex_as_UCT.t

            val empty : 'a1 t

            val is_empty : 'a1 t -> bool

            val add : key -> 'a1 -> 'a1 t -> 'a1 t

            val remove : key -> 'a1 t -> 'a1 t

            val mem : key -> 'a1 t -> bool

            val find : key -> 'a1 t -> 'a1 option

            val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

            val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

            val map2 :
              ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t ->
              'a3 t

            val elements : 'a1 t -> (key * 'a1) list

            val cardinal : 'a1 t -> nat

            val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

            val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool
           end

          module Coq_reFMF :
           sig
            val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

            val coq_In_dec : 'a1 Coq_reFM.t -> Coq_reFM.key -> bool
           end

          module MatchSpec :
           sig
           end

          module MatchSpecLemmas :
           sig
           end

          module Notations :
           sig
           end

          module Helpers :
           sig
            val coq_Plus : Regexes.regex -> Regexes.regex

            val coq_IterUnion : Regexes.regex list -> Regexes.regex

            val coq_IterApp : Regexes.regex list -> Regexes.regex

            val coq_Optional : Regexes.regex -> Regexes.regex

            val coq_REString : Strings.coq_String -> Regexes.regex
           end
         end
       end

      module Ty :
       sig
        module D :
         sig
          module CoreDefs :
           sig
            val char_set :
              TabT.R.Defs.Regexes.regex -> TabT.R.Ty.coq_Sigma list

            val regex_depth : TabT.R.Defs.Regexes.regex -> nat

            val regex_length : TabT.R.Defs.Regexes.regex -> nat

            val coq_Brzozowski_bound' : nat -> positive

            val coq_Brzozowski_bound : TabT.R.Defs.Regexes.regex -> positive

            val fin_states : TabT.R.Defs.Coq_reFS.t -> TabT.R.Defs.Coq_reFS.t

            type coq_DFA =
              (TabT.R.Defs.Regexes.regex * TabT.TabTy.coq_Table) * TabT.R.Defs.Coq_reFS.t

            val defDFA : coq_DFA

            val coq_DFAtransition : TabT.R.Ty.coq_Sigma -> coq_DFA -> coq_DFA

            val coq_DFAtransition_list :
              TabT.R.Ty.coq_Sigma list -> coq_DFA -> coq_DFA

            val coq_DFAaccepting : coq_DFA -> bool

            val coq_DFAaccepts :
              TabT.R.Defs.Strings.coq_String -> coq_DFA -> bool

            val regex2dfa : TabT.R.Defs.Regexes.regex -> coq_DFA

            val dfa2regex : coq_DFA -> TabT.R.Defs.Regexes.regex
           end

          module Correct :
           sig
            module Mat :
             sig
              val exp_matchb :
                TabT.R.Defs.Strings.coq_String -> TabT.R.Defs.Regexes.regex
                -> bool
             end
           end
         end

        type coq_Label = LABELS.coq_Label

        val defLabel : coq_Label

        val coq_Label_eq_dec : coq_Label -> coq_Label -> bool

        type coq_Pointer = R.Defs.Regexes.regex

        val defPointer : coq_Pointer

        type coq_Delta = TabT.TabTy.coq_Table * TabT.R.Defs.Coq_reFS.t

        val defDelta : TabT.TabTy.coq_Table * TabT.TabTy.Coq_reFS.t

        type coq_State = coq_Pointer * coq_Delta

        val defState :
          coq_Pointer * (TabT.TabTy.coq_Table * TabT.TabTy.Coq_reFS.t)

        val transition : R.Ty.coq_Sigma -> coq_State -> coq_State

        val transition_list : R.Ty.coq_Sigma list -> coq_State -> coq_State

        val accepts : R.Defs.Strings.coq_String -> coq_State -> bool

        val accepting : coq_State -> bool

        val init_state : R.Defs.Regexes.regex -> coq_State

        val init_state_inv : coq_State -> R.Defs.Regexes.regex

        val pointer_compare : coq_Pointer -> coq_Pointer -> comparison

        val pos2list : positive -> bool list

        val list2pos : bool list -> positive

        val int2list : z -> bool list

        val list2int : bool list -> z

        type index = z

        val index0 : index

        val index_eq_dec : index -> index -> bool

        val init_index : nat -> index

        val index2list : index -> bool list

        val list2index : bool list -> index

        val incr : index -> index

        val decr : index -> index
       end

      module Defs :
       sig
        module Pointer_as_UCT :
         sig
          type t = Ty.coq_Pointer

          val compare : Ty.coq_Pointer -> Ty.coq_Pointer -> comparison

          val coq_Pointer_eq_dec : Ty.coq_Pointer -> Ty.coq_Pointer -> bool
         end

        module Coredefs :
         sig
          type coq_Prefix = R.Defs.Strings.coq_String

          type coq_Suffix = R.Defs.Strings.coq_String

          type coq_Token = Ty.coq_Label * coq_Prefix

          type coq_Rule = Ty.coq_Label * R.Defs.Regexes.regex

          type sRule = Ty.coq_Label * Ty.coq_State
         end

        module MaxMunchSpec :
         sig
         end

        module Corollaries :
         sig
          val ru_dec : Coredefs.coq_Rule -> Coredefs.coq_Rule -> bool
         end
       end
     end

    module MemTy :
     sig
      module Pointer_as_UOT :
       sig
        type t = STT.Defs.Pointer_as_UCT.t

        val compare : t -> t -> t compare0

        val eq_dec : t -> t -> bool
       end

      module FM :
       sig
        module E :
         sig
          type t = STT.Defs.Pointer_as_UCT.t

          val compare :
            STT.Defs.Pointer_as_UCT.t -> STT.Defs.Pointer_as_UCT.t ->
            STT.Defs.Pointer_as_UCT.t compare0

          val eq_dec :
            STT.Defs.Pointer_as_UCT.t -> STT.Defs.Pointer_as_UCT.t -> bool
         end

        module Raw :
         sig
          type key = STT.Defs.Pointer_as_UCT.t

          type 'elt tree =
          | Leaf
          | Node of 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t

          val tree_rect :
            'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
            Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

          val tree_rec :
            'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
            Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

          val height : 'a1 tree -> Z_as_Int.t

          val cardinal : 'a1 tree -> nat

          val empty : 'a1 tree

          val is_empty : 'a1 tree -> bool

          val mem : STT.Defs.Pointer_as_UCT.t -> 'a1 tree -> bool

          val find : STT.Defs.Pointer_as_UCT.t -> 'a1 tree -> 'a1 option

          val create : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

          val assert_false : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

          val bal : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

          val add : key -> 'a1 -> 'a1 tree -> 'a1 tree

          val remove_min :
            'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree * (key * 'a1)

          val merge : 'a1 tree -> 'a1 tree -> 'a1 tree

          val remove : STT.Defs.Pointer_as_UCT.t -> 'a1 tree -> 'a1 tree

          val join : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

          type 'elt triple = { t_left : 'elt tree; t_opt : 'elt option;
                               t_right : 'elt tree }

          val t_left : 'a1 triple -> 'a1 tree

          val t_opt : 'a1 triple -> 'a1 option

          val t_right : 'a1 triple -> 'a1 tree

          val split : STT.Defs.Pointer_as_UCT.t -> 'a1 tree -> 'a1 triple

          val concat : 'a1 tree -> 'a1 tree -> 'a1 tree

          val elements_aux : (key * 'a1) list -> 'a1 tree -> (key * 'a1) list

          val elements : 'a1 tree -> (key * 'a1) list

          val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

          type 'elt enumeration =
          | End
          | More of key * 'elt * 'elt tree * 'elt enumeration

          val enumeration_rect :
            'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 -> 'a2)
            -> 'a1 enumeration -> 'a2

          val enumeration_rec :
            'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 -> 'a2)
            -> 'a1 enumeration -> 'a2

          val cons : 'a1 tree -> 'a1 enumeration -> 'a1 enumeration

          val equal_more :
            ('a1 -> 'a1 -> bool) -> STT.Defs.Pointer_as_UCT.t -> 'a1 -> ('a1
            enumeration -> bool) -> 'a1 enumeration -> bool

          val equal_cont :
            ('a1 -> 'a1 -> bool) -> 'a1 tree -> ('a1 enumeration -> bool) ->
            'a1 enumeration -> bool

          val equal_end : 'a1 enumeration -> bool

          val equal : ('a1 -> 'a1 -> bool) -> 'a1 tree -> 'a1 tree -> bool

          val map : ('a1 -> 'a2) -> 'a1 tree -> 'a2 tree

          val mapi : (key -> 'a1 -> 'a2) -> 'a1 tree -> 'a2 tree

          val map_option : (key -> 'a1 -> 'a2 option) -> 'a1 tree -> 'a2 tree

          val map2_opt :
            (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3
            tree) -> ('a2 tree -> 'a3 tree) -> 'a1 tree -> 'a2 tree -> 'a3
            tree

          val map2 :
            ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 tree -> 'a2 tree
            -> 'a3 tree

          module Proofs :
           sig
            module MX :
             sig
              module TO :
               sig
                type t = STT.Defs.Pointer_as_UCT.t
               end

              module IsTO :
               sig
               end

              module OrderTac :
               sig
               end

              val eq_dec :
                STT.Defs.Pointer_as_UCT.t -> STT.Defs.Pointer_as_UCT.t -> bool

              val lt_dec :
                STT.Defs.Pointer_as_UCT.t -> STT.Defs.Pointer_as_UCT.t -> bool

              val eqb :
                STT.Defs.Pointer_as_UCT.t -> STT.Defs.Pointer_as_UCT.t -> bool
             end

            module PX :
             sig
              module MO :
               sig
                module TO :
                 sig
                  type t = STT.Defs.Pointer_as_UCT.t
                 end

                module IsTO :
                 sig
                 end

                module OrderTac :
                 sig
                 end

                val eq_dec :
                  STT.Defs.Pointer_as_UCT.t -> STT.Defs.Pointer_as_UCT.t ->
                  bool

                val lt_dec :
                  STT.Defs.Pointer_as_UCT.t -> STT.Defs.Pointer_as_UCT.t ->
                  bool

                val eqb :
                  STT.Defs.Pointer_as_UCT.t -> STT.Defs.Pointer_as_UCT.t ->
                  bool
               end
             end

            module L :
             sig
              module MX :
               sig
                module TO :
                 sig
                  type t = STT.Defs.Pointer_as_UCT.t
                 end

                module IsTO :
                 sig
                 end

                module OrderTac :
                 sig
                 end

                val eq_dec :
                  STT.Defs.Pointer_as_UCT.t -> STT.Defs.Pointer_as_UCT.t ->
                  bool

                val lt_dec :
                  STT.Defs.Pointer_as_UCT.t -> STT.Defs.Pointer_as_UCT.t ->
                  bool

                val eqb :
                  STT.Defs.Pointer_as_UCT.t -> STT.Defs.Pointer_as_UCT.t ->
                  bool
               end

              module PX :
               sig
                module MO :
                 sig
                  module TO :
                   sig
                    type t = STT.Defs.Pointer_as_UCT.t
                   end

                  module IsTO :
                   sig
                   end

                  module OrderTac :
                   sig
                   end

                  val eq_dec :
                    STT.Defs.Pointer_as_UCT.t -> STT.Defs.Pointer_as_UCT.t ->
                    bool

                  val lt_dec :
                    STT.Defs.Pointer_as_UCT.t -> STT.Defs.Pointer_as_UCT.t ->
                    bool

                  val eqb :
                    STT.Defs.Pointer_as_UCT.t -> STT.Defs.Pointer_as_UCT.t ->
                    bool
                 end
               end

              type key = STT.Defs.Pointer_as_UCT.t

              type 'elt t = (STT.Defs.Pointer_as_UCT.t * 'elt) list

              val empty : 'a1 t

              val is_empty : 'a1 t -> bool

              val mem : key -> 'a1 t -> bool

              type 'elt coq_R_mem =
              | R_mem_0 of 'elt t
              | R_mem_1 of 'elt t * STT.Defs.Pointer_as_UCT.t * 'elt
                 * (STT.Defs.Pointer_as_UCT.t * 'elt) list
              | R_mem_2 of 'elt t * STT.Defs.Pointer_as_UCT.t * 'elt
                 * (STT.Defs.Pointer_as_UCT.t * 'elt) list
              | R_mem_3 of 'elt t * STT.Defs.Pointer_as_UCT.t * 'elt
                 * (STT.Defs.Pointer_as_UCT.t * 'elt) list * bool
                 * 'elt coq_R_mem

              val coq_R_mem_rect :
                key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 t -> bool -> 'a1
                coq_R_mem -> 'a2

              val coq_R_mem_rec :
                key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 t -> bool -> 'a1
                coq_R_mem -> 'a2

              val mem_rect :
                key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2 -> 'a2) -> 'a1 t -> 'a2

              val mem_rec :
                key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2 -> 'a2) -> 'a1 t -> 'a2

              val coq_R_mem_correct : key -> 'a1 t -> bool -> 'a1 coq_R_mem

              val find : key -> 'a1 t -> 'a1 option

              type 'elt coq_R_find =
              | R_find_0 of 'elt t
              | R_find_1 of 'elt t * STT.Defs.Pointer_as_UCT.t * 'elt
                 * (STT.Defs.Pointer_as_UCT.t * 'elt) list
              | R_find_2 of 'elt t * STT.Defs.Pointer_as_UCT.t * 'elt
                 * (STT.Defs.Pointer_as_UCT.t * 'elt) list
              | R_find_3 of 'elt t * STT.Defs.Pointer_as_UCT.t * 'elt
                 * (STT.Defs.Pointer_as_UCT.t * 'elt) list * 'elt option
                 * 'elt coq_R_find

              val coq_R_find_rect :
                key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> 'a1 t -> 'a1
                option -> 'a1 coq_R_find -> 'a2

              val coq_R_find_rec :
                key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> 'a1 t -> 'a1
                option -> 'a1 coq_R_find -> 'a2

              val find_rect :
                key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2 -> 'a2) -> 'a1 t -> 'a2

              val find_rec :
                key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2 -> 'a2) -> 'a1 t -> 'a2

              val coq_R_find_correct :
                key -> 'a1 t -> 'a1 option -> 'a1 coq_R_find

              val add : key -> 'a1 -> 'a1 t -> 'a1 t

              type 'elt coq_R_add =
              | R_add_0 of 'elt t
              | R_add_1 of 'elt t * STT.Defs.Pointer_as_UCT.t * 'elt
                 * (STT.Defs.Pointer_as_UCT.t * 'elt) list
              | R_add_2 of 'elt t * STT.Defs.Pointer_as_UCT.t * 'elt
                 * (STT.Defs.Pointer_as_UCT.t * 'elt) list
              | R_add_3 of 'elt t * STT.Defs.Pointer_as_UCT.t * 'elt
                 * (STT.Defs.Pointer_as_UCT.t * 'elt) list * 'elt t
                 * 'elt coq_R_add

              val coq_R_add_rect :
                key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a1 t -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t ->
                'a1 coq_R_add -> 'a2

              val coq_R_add_rec :
                key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a1 t -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t ->
                'a1 coq_R_add -> 'a2

              val add_rect :
                key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2 -> 'a2) -> 'a1 t -> 'a2

              val add_rec :
                key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2 -> 'a2) -> 'a1 t -> 'a2

              val coq_R_add_correct :
                key -> 'a1 -> 'a1 t -> 'a1 t -> 'a1 coq_R_add

              val remove : key -> 'a1 t -> 'a1 t

              type 'elt coq_R_remove =
              | R_remove_0 of 'elt t
              | R_remove_1 of 'elt t * STT.Defs.Pointer_as_UCT.t * 'elt
                 * (STT.Defs.Pointer_as_UCT.t * 'elt) list
              | R_remove_2 of 'elt t * STT.Defs.Pointer_as_UCT.t * 'elt
                 * (STT.Defs.Pointer_as_UCT.t * 'elt) list
              | R_remove_3 of 'elt t * STT.Defs.Pointer_as_UCT.t * 'elt
                 * (STT.Defs.Pointer_as_UCT.t * 'elt) list * 'elt t
                 * 'elt coq_R_remove

              val coq_R_remove_rect :
                key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a1 t -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t ->
                'a1 coq_R_remove -> 'a2

              val coq_R_remove_rec :
                key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a1 t -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t ->
                'a1 coq_R_remove -> 'a2

              val remove_rect :
                key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2 -> 'a2) -> 'a1 t -> 'a2

              val remove_rec :
                key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2 -> 'a2) -> 'a1 t -> 'a2

              val coq_R_remove_correct :
                key -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove

              val elements : 'a1 t -> 'a1 t

              val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

              type ('elt, 'a) coq_R_fold =
              | R_fold_0 of 'elt t * 'a
              | R_fold_1 of 'elt t * 'a * STT.Defs.Pointer_as_UCT.t * 
                 'elt * (STT.Defs.Pointer_as_UCT.t * 'elt) list * 'a
                 * ('elt, 'a) coq_R_fold

              val coq_R_fold_rect :
                (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) ->
                ('a1 t -> 'a2 -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> 'a2 -> ('a1,
                'a2) coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a2 ->
                ('a1, 'a2) coq_R_fold -> 'a3

              val coq_R_fold_rec :
                (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) ->
                ('a1 t -> 'a2 -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> 'a2 -> ('a1,
                'a2) coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a2 ->
                ('a1, 'a2) coq_R_fold -> 'a3

              val fold_rect :
                (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) ->
                ('a1 t -> 'a2 -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> 'a3 -> 'a3)
                -> 'a1 t -> 'a2 -> 'a3

              val fold_rec :
                (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) ->
                ('a1 t -> 'a2 -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> 'a3 -> 'a3)
                -> 'a1 t -> 'a2 -> 'a3

              val coq_R_fold_correct :
                (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2 -> ('a1,
                'a2) coq_R_fold

              val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool

              type 'elt coq_R_equal =
              | R_equal_0 of 'elt t * 'elt t
              | R_equal_1 of 'elt t * 'elt t * STT.Defs.Pointer_as_UCT.t
                 * 'elt * (STT.Defs.Pointer_as_UCT.t * 'elt) list
                 * STT.Defs.Pointer_as_UCT.t * 'elt
                 * (STT.Defs.Pointer_as_UCT.t * 'elt) list * bool
                 * 'elt coq_R_equal
              | R_equal_2 of 'elt t * 'elt t * STT.Defs.Pointer_as_UCT.t
                 * 'elt * (STT.Defs.Pointer_as_UCT.t * 'elt) list
                 * STT.Defs.Pointer_as_UCT.t * 'elt
                 * (STT.Defs.Pointer_as_UCT.t * 'elt) list
                 * STT.Defs.Pointer_as_UCT.t compare0
              | R_equal_3 of 'elt t * 'elt t * 'elt t * 'elt t

              val coq_R_equal_rect :
                ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2)
                -> ('a1 t -> 'a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                bool -> 'a1 coq_R_equal -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ ->
                STT.Defs.Pointer_as_UCT.t compare0 -> __ -> __ -> 'a2) ->
                ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2)
                -> 'a1 t -> 'a1 t -> bool -> 'a1 coq_R_equal -> 'a2

              val coq_R_equal_rec :
                ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2)
                -> ('a1 t -> 'a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                bool -> 'a1 coq_R_equal -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ ->
                STT.Defs.Pointer_as_UCT.t compare0 -> __ -> __ -> 'a2) ->
                ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2)
                -> 'a1 t -> 'a1 t -> bool -> 'a1 coq_R_equal -> 'a2

              val equal_rect :
                ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2)
                -> ('a1 t -> 'a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2 -> 'a2) -> ('a1 t -> 'a1 t -> STT.Defs.Pointer_as_UCT.t
                -> 'a1 -> (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ ->
                STT.Defs.Pointer_as_UCT.t compare0 -> __ -> __ -> 'a2) ->
                ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2)
                -> 'a1 t -> 'a1 t -> 'a2

              val equal_rec :
                ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2)
                -> ('a1 t -> 'a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2 -> 'a2) -> ('a1 t -> 'a1 t -> STT.Defs.Pointer_as_UCT.t
                -> 'a1 -> (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ ->
                STT.Defs.Pointer_as_UCT.t compare0 -> __ -> __ -> 'a2) ->
                ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2)
                -> 'a1 t -> 'a1 t -> 'a2

              val coq_R_equal_correct :
                ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool -> 'a1
                coq_R_equal

              val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

              val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

              val option_cons :
                key -> 'a1 option -> (key * 'a1) list -> (key * 'a1) list

              val map2_l :
                ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a3 t

              val map2_r :
                ('a1 option -> 'a2 option -> 'a3 option) -> 'a2 t -> 'a3 t

              val map2 :
                ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t ->
                'a3 t

              val combine : 'a1 t -> 'a2 t -> ('a1 option * 'a2 option) t

              val fold_right_pair :
                ('a1 -> 'a2 -> 'a3 -> 'a3) -> ('a1 * 'a2) list -> 'a3 -> 'a3

              val map2_alt :
                ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t ->
                (key * 'a3) list

              val at_least_one :
                'a1 option -> 'a2 option -> ('a1 option * 'a2 option) option

              val at_least_one_then_f :
                ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 option -> 'a2
                option -> 'a3 option
             end

            type 'elt coq_R_mem =
            | R_mem_0 of 'elt tree
            | R_mem_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t * bool * 'elt coq_R_mem
            | R_mem_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t
            | R_mem_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t * bool * 'elt coq_R_mem

            val coq_R_mem_rect :
              STT.Defs.Pointer_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1
              tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
              -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> ('a1
              tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
              -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 ->
              'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> bool -> 'a1
              coq_R_mem -> 'a2 -> 'a2) -> 'a1 tree -> bool -> 'a1 coq_R_mem
              -> 'a2

            val coq_R_mem_rec :
              STT.Defs.Pointer_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1
              tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
              -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> ('a1
              tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
              -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 ->
              'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> bool -> 'a1
              coq_R_mem -> 'a2 -> 'a2) -> 'a1 tree -> bool -> 'a1 coq_R_mem
              -> 'a2

            type 'elt coq_R_find =
            | R_find_0 of 'elt tree
            | R_find_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t * 'elt option * 'elt coq_R_find
            | R_find_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t
            | R_find_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t * 'elt option * 'elt coq_R_find

            val coq_R_find_rect :
              STT.Defs.Pointer_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1
              tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
              -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) ->
              ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
              -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key ->
              'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 option
              -> 'a1 coq_R_find -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 option ->
              'a1 coq_R_find -> 'a2

            val coq_R_find_rec :
              STT.Defs.Pointer_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1
              tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
              -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) ->
              ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
              -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key ->
              'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 option
              -> 'a1 coq_R_find -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 option ->
              'a1 coq_R_find -> 'a2

            type 'elt coq_R_bal =
            | R_bal_0 of 'elt tree * key * 'elt * 'elt tree
            | R_bal_1 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
               key * 'elt * 'elt tree * Z_as_Int.t
            | R_bal_2 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
               key * 'elt * 'elt tree * Z_as_Int.t
            | R_bal_3 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
               key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 
               'elt * 'elt tree * Z_as_Int.t
            | R_bal_4 of 'elt tree * key * 'elt * 'elt tree
            | R_bal_5 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
               key * 'elt * 'elt tree * Z_as_Int.t
            | R_bal_6 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
               key * 'elt * 'elt tree * Z_as_Int.t
            | R_bal_7 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
               key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 
               'elt * 'elt tree * Z_as_Int.t
            | R_bal_8 of 'elt tree * key * 'elt * 'elt tree

            val coq_R_bal_rect :
              ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> 'a2)
              -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree
              -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
              'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1
              tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __
              -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ ->
              __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
              __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
              __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
              -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1
              tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1
              tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree ->
              key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree ->
              key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> __ ->
              'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __
              -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
              -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
              -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ ->
              __ -> __ -> __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
              'a1 tree -> 'a1 coq_R_bal -> 'a2

            val coq_R_bal_rec :
              ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> 'a2)
              -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree
              -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
              'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1
              tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __
              -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ ->
              __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
              __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
              __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
              -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1
              tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1
              tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree ->
              key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree ->
              key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> __ ->
              'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __
              -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
              -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
              -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ ->
              __ -> __ -> __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
              'a1 tree -> 'a1 coq_R_bal -> 'a2

            type 'elt coq_R_add =
            | R_add_0 of 'elt tree
            | R_add_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t * 'elt tree * 'elt coq_R_add
            | R_add_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t
            | R_add_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t * 'elt tree * 'elt coq_R_add

            val coq_R_add_rect :
              key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree
              -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
              'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1 tree -> 'a1
              tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __
              -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
              Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_add ->
              'a2 -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_add -> 'a2

            val coq_R_add_rec :
              key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree
              -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
              'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1 tree -> 'a1
              tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __
              -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
              Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_add ->
              'a2 -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_add -> 'a2

            type 'elt coq_R_remove_min =
            | R_remove_min_0 of 'elt tree * key * 'elt * 'elt tree
            | R_remove_min_1 of 'elt tree * key * 'elt * 'elt tree
               * 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t
               * ('elt tree * (key * 'elt)) * 'elt coq_R_remove_min
               * 'elt tree * (key * 'elt)

            val coq_R_remove_min_rect :
              ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1 tree
              -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree
              -> Z_as_Int.t -> __ -> ('a1 tree * (key * 'a1)) -> 'a1
              coq_R_remove_min -> 'a2 -> 'a1 tree -> (key * 'a1) -> __ ->
              'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> ('a1
              tree * (key * 'a1)) -> 'a1 coq_R_remove_min -> 'a2

            val coq_R_remove_min_rec :
              ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1 tree
              -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree
              -> Z_as_Int.t -> __ -> ('a1 tree * (key * 'a1)) -> 'a1
              coq_R_remove_min -> 'a2 -> 'a1 tree -> (key * 'a1) -> __ ->
              'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> ('a1
              tree * (key * 'a1)) -> 'a1 coq_R_remove_min -> 'a2

            type 'elt coq_R_merge =
            | R_merge_0 of 'elt tree * 'elt tree
            | R_merge_1 of 'elt tree * 'elt tree * 'elt tree * key * 
               'elt * 'elt tree * Z_as_Int.t
            | R_merge_2 of 'elt tree * 'elt tree * 'elt tree * key * 
               'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 'elt
               * 'elt tree * Z_as_Int.t * 'elt tree * (key * 'elt) * 
               key * 'elt

            val coq_R_merge_rect :
              ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
              'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
              'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
              tree -> Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree
              -> Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> key ->
              'a1 -> __ -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 tree -> 'a1
              coq_R_merge -> 'a2

            val coq_R_merge_rec :
              ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
              'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
              'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
              tree -> Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree
              -> Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> key ->
              'a1 -> __ -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 tree -> 'a1
              coq_R_merge -> 'a2

            type 'elt coq_R_remove =
            | R_remove_0 of 'elt tree
            | R_remove_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t * 'elt tree * 'elt coq_R_remove
            | R_remove_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t
            | R_remove_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t * 'elt tree * 'elt coq_R_remove

            val coq_R_remove_rect :
              STT.Defs.Pointer_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1
              tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
              -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) ->
              ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
              -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key ->
              'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree ->
              'a1 coq_R_remove -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1
              coq_R_remove -> 'a2

            val coq_R_remove_rec :
              STT.Defs.Pointer_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1
              tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
              -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) ->
              ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
              -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key ->
              'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree ->
              'a1 coq_R_remove -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1
              coq_R_remove -> 'a2

            type 'elt coq_R_concat =
            | R_concat_0 of 'elt tree * 'elt tree
            | R_concat_1 of 'elt tree * 'elt tree * 'elt tree * key * 
               'elt * 'elt tree * Z_as_Int.t
            | R_concat_2 of 'elt tree * 'elt tree * 'elt tree * key * 
               'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 'elt
               * 'elt tree * Z_as_Int.t * 'elt tree * (key * 'elt)

            val coq_R_concat_rect :
              ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
              'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
              'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
              tree -> Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree
              -> Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> 'a2) ->
              'a1 tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_concat -> 'a2

            val coq_R_concat_rec :
              ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
              'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
              'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
              tree -> Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree
              -> Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> 'a2) ->
              'a1 tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_concat -> 'a2

            type 'elt coq_R_split =
            | R_split_0 of 'elt tree
            | R_split_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t * 'elt triple * 'elt coq_R_split * 'elt tree
               * 'elt option * 'elt tree
            | R_split_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t
            | R_split_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t * 'elt triple * 'elt coq_R_split * 'elt tree
               * 'elt option * 'elt tree

            val coq_R_split_rect :
              STT.Defs.Pointer_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1
              tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
              -> __ -> __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree
              -> 'a1 option -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
              tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __
              -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
              Z_as_Int.t -> __ -> __ -> __ -> 'a1 triple -> 'a1 coq_R_split
              -> 'a2 -> 'a1 tree -> 'a1 option -> 'a1 tree -> __ -> 'a2) ->
              'a1 tree -> 'a1 triple -> 'a1 coq_R_split -> 'a2

            val coq_R_split_rec :
              STT.Defs.Pointer_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1
              tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
              -> __ -> __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree
              -> 'a1 option -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
              tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __
              -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
              Z_as_Int.t -> __ -> __ -> __ -> 'a1 triple -> 'a1 coq_R_split
              -> 'a2 -> 'a1 tree -> 'a1 option -> 'a1 tree -> __ -> 'a2) ->
              'a1 tree -> 'a1 triple -> 'a1 coq_R_split -> 'a2

            type ('elt, 'x) coq_R_map_option =
            | R_map_option_0 of 'elt tree
            | R_map_option_1 of 'elt tree * 'elt tree * key * 'elt
               * 'elt tree * Z_as_Int.t * 'x * 'x tree
               * ('elt, 'x) coq_R_map_option * 'x tree
               * ('elt, 'x) coq_R_map_option
            | R_map_option_2 of 'elt tree * 'elt tree * key * 'elt
               * 'elt tree * Z_as_Int.t * 'x tree
               * ('elt, 'x) coq_R_map_option * 'x tree
               * ('elt, 'x) coq_R_map_option

            val coq_R_map_option_rect :
              (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) -> ('a1
              tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
              -> 'a2 -> __ -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3
              -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) ->
              ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
              -> __ -> __ -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3
              -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) ->
              'a1 tree -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3

            val coq_R_map_option_rec :
              (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) -> ('a1
              tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
              -> 'a2 -> __ -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3
              -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) ->
              ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
              -> __ -> __ -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3
              -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) ->
              'a1 tree -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3

            type ('elt, 'x0, 'x) coq_R_map2_opt =
            | R_map2_opt_0 of 'elt tree * 'x0 tree
            | R_map2_opt_1 of 'elt tree * 'x0 tree * 'elt tree * key * 
               'elt * 'elt tree * Z_as_Int.t
            | R_map2_opt_2 of 'elt tree * 'x0 tree * 'elt tree * key * 
               'elt * 'elt tree * Z_as_Int.t * 'x0 tree * key * 'x0
               * 'x0 tree * Z_as_Int.t * 'x0 tree * 'x0 option * 'x0 tree
               * 'x * 'x tree * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
               * ('elt, 'x0, 'x) coq_R_map2_opt
            | R_map2_opt_3 of 'elt tree * 'x0 tree * 'elt tree * key * 
               'elt * 'elt tree * Z_as_Int.t * 'x0 tree * key * 'x0
               * 'x0 tree * Z_as_Int.t * 'x0 tree * 'x0 option * 'x0 tree
               * 'x tree * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
               * ('elt, 'x0, 'x) coq_R_map2_opt

            val coq_R_map2_opt_rect :
              (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3
              tree) -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2 tree -> __
              -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 ->
              'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a4) -> ('a1 tree -> 'a2
              tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
              -> 'a2 tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ ->
              'a2 tree -> 'a2 option -> 'a2 tree -> __ -> 'a3 -> __ -> 'a3
              tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree ->
              ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree ->
              'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
              __ -> 'a2 tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ ->
              'a2 tree -> 'a2 option -> 'a2 tree -> __ -> __ -> 'a3 tree ->
              ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2,
              'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1 tree -> 'a2 tree ->
              'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4

            val coq_R_map2_opt_rec :
              (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3
              tree) -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2 tree -> __
              -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 ->
              'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a4) -> ('a1 tree -> 'a2
              tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
              -> 'a2 tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ ->
              'a2 tree -> 'a2 option -> 'a2 tree -> __ -> 'a3 -> __ -> 'a3
              tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree ->
              ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree ->
              'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
              __ -> 'a2 tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ ->
              'a2 tree -> 'a2 option -> 'a2 tree -> __ -> __ -> 'a3 tree ->
              ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2,
              'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1 tree -> 'a2 tree ->
              'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4

            val fold' : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

            val flatten_e : 'a1 enumeration -> (key * 'a1) list
           end
         end

        type 'elt bst =
          'elt Raw.tree
          (* singleton inductive, whose constructor was Bst *)

        val this : 'a1 bst -> 'a1 Raw.tree

        type 'elt t = 'elt bst

        type key = STT.Defs.Pointer_as_UCT.t

        val empty : 'a1 t

        val is_empty : 'a1 t -> bool

        val add : key -> 'a1 -> 'a1 t -> 'a1 t

        val remove : key -> 'a1 t -> 'a1 t

        val mem : key -> 'a1 t -> bool

        val find : key -> 'a1 t -> 'a1 option

        val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

        val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

        val map2 :
          ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t -> 'a3 t

        val elements : 'a1 t -> (key * 'a1) list

        val cardinal : 'a1 t -> nat

        val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

        val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool
       end

      module FMF :
       sig
        val eqb :
          STT.Defs.Pointer_as_UCT.t -> STT.Defs.Pointer_as_UCT.t -> bool

        val coq_In_dec : 'a1 FM.t -> FM.key -> bool
       end

      type coq_Memo =
        ((STT.R.Defs.Strings.coq_String * STT.R.Defs.Strings.coq_String) * STT.Ty.index)
        option Trie.coq_Trie FM.t

      val emptyMemo : coq_Memo

      val get_Memo :
        coq_Memo -> STT.Ty.coq_Pointer -> STT.Ty.index ->
        ((STT.R.Defs.Strings.coq_String * STT.R.Defs.Strings.coq_String) * STT.Ty.index)
        option option

      val set_Memo :
        coq_Memo -> STT.Ty.coq_Pointer -> STT.Ty.index ->
        ((STT.R.Defs.Strings.coq_String * STT.R.Defs.Strings.coq_String) * STT.Ty.index)
        option -> coq_Memo
     end

    module Defs :
     sig
      module NaiveLexer :
       sig
        module LEM :
         sig
          module IMPL :
           sig
            val max_pref_fn :
              STT.R.Defs.Strings.coq_String -> STT.Ty.index ->
              STT.Ty.coq_State ->
              ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
              option

            val extract_fsm_for_max :
              STT.R.Defs.Strings.coq_String -> STT.Ty.index ->
              (STT.Ty.coq_Label * STT.Ty.coq_State) ->
              STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
              option

            val max_prefs :
              STT.R.Defs.Strings.coq_String -> STT.Ty.index ->
              (STT.Ty.coq_Label * STT.Ty.coq_State) list ->
              (STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
              option) list

            val longer_pref :
              (STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
              option) ->
              (STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
              option) ->
              STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
              option

            val max_of_prefs :
              (STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
              option) list ->
              STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
              option

            val init_srule :
              STT.Defs.Coredefs.coq_Rule -> STT.Defs.Coredefs.sRule
           end
         end

        module Lex :
         sig
          val lex' :
            STT.Defs.Coredefs.sRule list -> STT.R.Defs.Strings.coq_String ->
            STT.Ty.index -> STT.Defs.Coredefs.coq_Token
            list * STT.R.Defs.Strings.coq_String

          val lex :
            STT.Defs.Coredefs.coq_Rule list -> STT.R.Defs.Strings.coq_String
            -> STT.Defs.Coredefs.coq_Token
            list * STT.R.Defs.Strings.coq_String
         end
       end

      module NaiveLexerF :
       sig
        module LEM :
         sig
          module IMPL :
           sig
            module LEM :
             sig
              module IMPL :
               sig
                val max_pref_fn :
                  STT.R.Defs.Strings.coq_String -> STT.Ty.index ->
                  STT.Ty.coq_State ->
                  ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
                  option

                val extract_fsm_for_max :
                  STT.R.Defs.Strings.coq_String -> STT.Ty.index ->
                  (STT.Ty.coq_Label * STT.Ty.coq_State) ->
                  STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
                  option

                val max_prefs :
                  STT.R.Defs.Strings.coq_String -> STT.Ty.index ->
                  (STT.Ty.coq_Label * STT.Ty.coq_State) list ->
                  (STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
                  option) list

                val longer_pref :
                  (STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
                  option) ->
                  (STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
                  option) ->
                  STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
                  option

                val max_of_prefs :
                  (STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
                  option) list ->
                  STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
                  option

                val init_srule :
                  STT.Defs.Coredefs.coq_Rule -> STT.Defs.Coredefs.sRule
               end
             end

            module Lex :
             sig
              val lex' :
                STT.Defs.Coredefs.sRule list -> STT.R.Defs.Strings.coq_String
                -> STT.Ty.index -> STT.Defs.Coredefs.coq_Token
                list * STT.R.Defs.Strings.coq_String

              val lex :
                STT.Defs.Coredefs.coq_Rule list ->
                STT.R.Defs.Strings.coq_String -> STT.Defs.Coredefs.coq_Token
                list * STT.R.Defs.Strings.coq_String
             end
           end

          module Lemmas :
           sig
            module IMPL :
             sig
              val max_pref_fn :
                STT.R.Defs.Strings.coq_String -> STT.Ty.index ->
                STT.Ty.coq_State ->
                ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
                option

              val extract_fsm_for_max :
                STT.R.Defs.Strings.coq_String -> STT.Ty.index ->
                (STT.Ty.coq_Label * STT.Ty.coq_State) ->
                STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
                option

              val max_prefs :
                STT.R.Defs.Strings.coq_String -> STT.Ty.index ->
                (STT.Ty.coq_Label * STT.Ty.coq_State) list ->
                (STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
                option) list

              val longer_pref :
                (STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
                option) ->
                (STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
                option) ->
                STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
                option

              val max_of_prefs :
                (STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
                option) list ->
                STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
                option

              val init_srule :
                STT.Defs.Coredefs.coq_Rule -> STT.Defs.Coredefs.sRule
             end
           end
         end
       end

      module Invariants :
       sig
       end
     end
   end

  module Correctness :
   sig
    module IMPL :
     sig
      module MEMO :
       sig
        type coq_Memo = MEM.MemTy.coq_Memo

        val emptyMemo : coq_Memo

        val set_Memo :
          coq_Memo -> MEM.STT.Ty.coq_Pointer -> MEM.STT.Ty.index ->
          ((MEM.STT.R.Defs.Strings.coq_String * MEM.STT.R.Defs.Strings.coq_String) * MEM.STT.Ty.index)
          option -> coq_Memo

        val get_Memo :
          coq_Memo -> MEM.STT.Ty.coq_Pointer -> MEM.STT.Ty.index ->
          ((MEM.STT.R.Defs.Strings.coq_String * MEM.STT.R.Defs.Strings.coq_String) * MEM.STT.Ty.index)
          option option
       end

      module Defs :
       sig
        module NaiveLexer :
         sig
          module LEM :
           sig
            module IMPL :
             sig
              val max_pref_fn :
                MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
                MEM.STT.Ty.coq_State ->
                ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                option

              val extract_fsm_for_max :
                MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
                (MEM.STT.Ty.coq_Label * MEM.STT.Ty.coq_State) ->
                MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                option

              val max_prefs :
                MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
                (MEM.STT.Ty.coq_Label * MEM.STT.Ty.coq_State) list ->
                (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                option) list

              val longer_pref :
                (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                option) ->
                (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                option) ->
                MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                option

              val max_of_prefs :
                (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                option) list ->
                MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                option

              val init_srule :
                MEM.STT.Defs.Coredefs.coq_Rule -> MEM.STT.Defs.Coredefs.sRule
             end
           end

          module Lex :
           sig
            val lex' :
              MEM.STT.Defs.Coredefs.sRule list ->
              MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
              MEM.STT.Defs.Coredefs.coq_Token
              list * MEM.STT.R.Defs.Strings.coq_String

            val lex :
              MEM.STT.Defs.Coredefs.coq_Rule list ->
              MEM.STT.R.Defs.Strings.coq_String ->
              MEM.STT.Defs.Coredefs.coq_Token
              list * MEM.STT.R.Defs.Strings.coq_String
           end
         end

        module NaiveLexerF :
         sig
          module LEM :
           sig
            module IMPL :
             sig
              module LEM :
               sig
                module IMPL :
                 sig
                  val max_pref_fn :
                    MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
                    MEM.STT.Ty.coq_State ->
                    ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                    option

                  val extract_fsm_for_max :
                    MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
                    (MEM.STT.Ty.coq_Label * MEM.STT.Ty.coq_State) ->
                    MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                    option

                  val max_prefs :
                    MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
                    (MEM.STT.Ty.coq_Label * MEM.STT.Ty.coq_State) list ->
                    (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                    option) list

                  val longer_pref :
                    (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                    option) ->
                    (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                    option) ->
                    MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                    option

                  val max_of_prefs :
                    (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                    option) list ->
                    MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                    option

                  val init_srule :
                    MEM.STT.Defs.Coredefs.coq_Rule ->
                    MEM.STT.Defs.Coredefs.sRule
                 end
               end

              module Lex :
               sig
                val lex' :
                  MEM.STT.Defs.Coredefs.sRule list ->
                  MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
                  MEM.STT.Defs.Coredefs.coq_Token
                  list * MEM.STT.R.Defs.Strings.coq_String

                val lex :
                  MEM.STT.Defs.Coredefs.coq_Rule list ->
                  MEM.STT.R.Defs.Strings.coq_String ->
                  MEM.STT.Defs.Coredefs.coq_Token
                  list * MEM.STT.R.Defs.Strings.coq_String
               end
             end

            module Lemmas :
             sig
              module IMPL :
               sig
                val max_pref_fn :
                  MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
                  MEM.STT.Ty.coq_State ->
                  ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                  option

                val extract_fsm_for_max :
                  MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
                  (MEM.STT.Ty.coq_Label * MEM.STT.Ty.coq_State) ->
                  MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                  option

                val max_prefs :
                  MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
                  (MEM.STT.Ty.coq_Label * MEM.STT.Ty.coq_State) list ->
                  (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                  option) list

                val longer_pref :
                  (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                  option) ->
                  (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                  option) ->
                  MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                  option

                val max_of_prefs :
                  (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                  option) list ->
                  MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                  option

                val init_srule :
                  MEM.STT.Defs.Coredefs.coq_Rule ->
                  MEM.STT.Defs.Coredefs.sRule
               end
             end
           end
         end

        module Invariants :
         sig
         end
       end

      module L :
       sig
        module IMPL :
         sig
          module LEM :
           sig
            module IMPL :
             sig
              val max_pref_fn :
                MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
                MEM.STT.Ty.coq_State ->
                ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                option

              val extract_fsm_for_max :
                MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
                (MEM.STT.Ty.coq_Label * MEM.STT.Ty.coq_State) ->
                MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                option

              val max_prefs :
                MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
                (MEM.STT.Ty.coq_Label * MEM.STT.Ty.coq_State) list ->
                (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                option) list

              val longer_pref :
                (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                option) ->
                (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                option) ->
                MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                option

              val max_of_prefs :
                (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                option) list ->
                MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                option

              val init_srule :
                MEM.STT.Defs.Coredefs.coq_Rule -> MEM.STT.Defs.Coredefs.sRule
             end
           end

          module Lex :
           sig
            val lex' :
              MEM.STT.Defs.Coredefs.sRule list ->
              MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
              MEM.STT.Defs.Coredefs.coq_Token
              list * MEM.STT.R.Defs.Strings.coq_String

            val lex :
              MEM.STT.Defs.Coredefs.coq_Rule list ->
              MEM.STT.R.Defs.Strings.coq_String ->
              MEM.STT.Defs.Coredefs.coq_Token
              list * MEM.STT.R.Defs.Strings.coq_String
           end
         end

        module Lemmas :
         sig
          module IMPL :
           sig
            val max_pref_fn :
              MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
              MEM.STT.Ty.coq_State ->
              ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
              option

            val extract_fsm_for_max :
              MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
              (MEM.STT.Ty.coq_Label * MEM.STT.Ty.coq_State) ->
              MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
              option

            val max_prefs :
              MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
              (MEM.STT.Ty.coq_Label * MEM.STT.Ty.coq_State) list ->
              (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
              option) list

            val longer_pref :
              (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
              option) ->
              (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
              option) ->
              MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
              option

            val max_of_prefs :
              (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
              option) list ->
              MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
              option

            val init_srule :
              MEM.STT.Defs.Coredefs.coq_Rule -> MEM.STT.Defs.Coredefs.sRule
           end
         end
       end

      module Utils :
       sig
        val zip : 'a1 list -> 'a2 list -> ('a1 * 'a2) list

        val unzip : ('a1 * 'a2) list -> 'a1 list * 'a2 list

        val ssnd : ('a1 * ('a2 * 'a3)) -> 'a3
       end

      module MPref :
       sig
        val max_pref_fn_M :
          MEMO.coq_Memo -> MEM.STT.R.Defs.Strings.coq_String ->
          MEM.STT.Ty.index -> MEM.STT.Ty.coq_State ->
          MEMO.coq_Memo * ((MEM.STT.R.Defs.Strings.coq_String * MEM.STT.R.Defs.Strings.coq_String) * MEM.STT.Ty.index)
          option

        val extract_fsm_for_max_M :
          MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
          (MEMO.coq_Memo * (MEM.STT.Ty.coq_Label * MEM.STT.Ty.coq_State)) ->
          MEMO.coq_Memo * (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
          option)

        val max_prefs_M :
          MEMO.coq_Memo list -> MEM.STT.R.Defs.Strings.coq_String ->
          MEM.STT.Ty.index -> (MEM.STT.Ty.coq_Label * MEM.STT.Ty.coq_State)
          list -> MEMO.coq_Memo
          list * (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
          option) list

        val max_of_prefs_M :
          (MEMO.coq_Memo
          list * (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
          option) list) -> (MEMO.coq_Memo
          list * MEM.STT.Ty.coq_Label) * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
          option
       end

      module TypeCheckLemmas :
       sig
        module MemoEq :
         sig
         end

        module Accessible :
         sig
         end

        module Lengths :
         sig
         end

        module LexyClosure :
         sig
         end

        module IndexClosure :
         sig
         end
       end

      module Lex :
       sig
        val lex'_M :
          MEM.STT.R.Defs.Strings.coq_String -> MEMO.coq_Memo list ->
          MEM.STT.Defs.Coredefs.sRule list ->
          MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
          (MEMO.coq_Memo list * MEM.STT.Defs.Coredefs.coq_Token
          list) * MEM.STT.R.Defs.Strings.coq_String

        val init_srule :
          MEM.STT.Defs.Coredefs.coq_Rule -> MEM.STT.Defs.Coredefs.sRule

        val init_Memos :
          MEM.STT.Defs.Coredefs.sRule list -> MEMO.coq_Memo list

        val lex_M :
          MEM.STT.Defs.Coredefs.coq_Rule list ->
          MEM.STT.R.Defs.Strings.coq_String ->
          MEM.STT.Defs.Coredefs.coq_Token
          list * MEM.STT.R.Defs.Strings.coq_String
       end
     end

    module CaseLemmas :
     sig
     end
   end

  module LitLexer :
   sig
    val lex :
      MEM.STT.Defs.Coredefs.coq_Rule list ->
      MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Defs.Coredefs.coq_Token
      list * MEM.STT.R.Defs.Strings.coq_String
   end
 end

module Coq_regex_builders :
 functor (R:T) ->
 sig
  val coq_Char_of_nat : nat -> R.Defs.Regexes.regex

  val asciiUnion : char list -> R.Defs.Regexes.regex

  val stringUnion : char list -> R.Defs.Regexes.regex

  val asciiApp : char list -> R.Defs.Regexes.regex

  val stringApp : char list -> R.Defs.Regexes.regex
 end

module Coq_prebuilt_regexes :
 functor (R:T) ->
 sig
  module Coq_builders :
   sig
    val coq_Char_of_nat : nat -> R.Defs.Regexes.regex

    val asciiUnion : char list -> R.Defs.Regexes.regex

    val stringUnion : char list -> R.Defs.Regexes.regex

    val asciiApp : char list -> R.Defs.Regexes.regex

    val stringApp : char list -> R.Defs.Regexes.regex
   end

  module Coq_whitespace :
   sig
    val tab_ascii : char

    val linebreak_ascii : char

    val carriage_return_ascii : char

    val space_ascii : char

    val ws_chars : char list

    val ws_re : R.Defs.Regexes.regex

    val ws_carr_chars : char list

    val ws_carr_re : R.Defs.Regexes.regex
   end

  module Coq_numbers :
   sig
    val digit_re : R.Defs.Regexes.regex

    val nz_digit_re : R.Defs.Regexes.regex

    val zero_re : R.Defs.Regexes.regex

    val pos_lz_re : R.Defs.Regexes.regex

    val pos_re : R.Defs.Regexes.regex

    val nat_lz_re : R.Defs.Regexes.regex

    val nat_re : R.Defs.Regexes.regex

    val int_lz_re : R.Defs.Regexes.regex

    val int_re : R.Defs.Regexes.regex

    val int_no_neg0_lz_re : R.Defs.Regexes.regex

    val int_no_neg0_re : R.Defs.Regexes.regex

    val dec_part_re : R.Defs.Regexes.regex

    val dec_lz_re : R.Defs.Regexes.regex

    val dec_re : R.Defs.Regexes.regex

    val dec_no_neg0_lz_re : R.Defs.Regexes.regex

    val dec_no_neg0_re : R.Defs.Regexes.regex

    val proper_dec_lz_re : R.Defs.Regexes.regex

    val proper_dec_re : R.Defs.Regexes.regex

    val proper_dec_no_neg0_lz_re : R.Defs.Regexes.regex

    val proper_dec_no_neg0_re : R.Defs.Regexes.regex
   end

  module Strings_regex :
   sig
    val coq_AZ_re : R.Defs.Regexes.regex

    val az_re : R.Defs.Regexes.regex

    val punc_re : R.Defs.Regexes.regex

    val quote_re : R.Defs.Regexes.regex

    val esc_quote_re : R.Defs.Regexes.regex

    val esc_bslash_re : R.Defs.Regexes.regex

    val char_re : R.Defs.Regexes.regex

    val string_re : R.Defs.Regexes.regex
   end
 end

module LABELS :
 sig
  type coq_Label' =
  | INT
  | FLOAT
  | STRING
  | TRUE
  | FALSE
  | NULL
  | COLON
  | COMMA
  | LEFT_BRACKET
  | RIGHT_BRACKET
  | LEFT_BRACE
  | RIGHT_BRACE
  | WS

  val coq_Label'_rect :
    'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1
    -> 'a1 -> 'a1 -> coq_Label' -> 'a1

  val coq_Label'_rec :
    'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1 -> 'a1
    -> 'a1 -> 'a1 -> coq_Label' -> 'a1

  type coq_Label = coq_Label'

  val defLabel : coq_Label

  val coq_Label_eq_dec : coq_Label -> coq_Label -> bool
 end

module LXR :
 sig
  module MEM :
   sig
    module STT :
     sig
      module TabT :
       sig
        module R :
         sig
          module Ty :
           sig
            type coq_Sigma = ALPHABET.coq_Sigma

            val coq_SigmaEnum : coq_Sigma list

            val coq_Sigma_dec : coq_Sigma -> coq_Sigma -> bool

            val compareT : coq_Sigma -> coq_Sigma -> comparison

            val ascii2Sigma : char -> coq_Sigma
           end

          module Defs :
           sig
            module T_as_UCT :
             sig
              type t = Ty.coq_Sigma

              val compare : Ty.coq_Sigma -> Ty.coq_Sigma -> comparison
             end

            module T_as_UOT :
             sig
              type t = T_as_UCT.t

              val compare : t -> t -> t compare0

              val eq_dec : t -> t -> bool
             end

            module SigFS :
             sig
              module X' :
               sig
                type t = T_as_UCT.t

                val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                val compare : T_as_UCT.t -> T_as_UCT.t -> comparison
               end

              module MSet :
               sig
                module Raw :
                 sig
                  type elt = T_as_UCT.t

                  type tree =
                  | Leaf
                  | Node of Z_as_Int.t * tree * T_as_UCT.t * tree

                  val empty : tree

                  val is_empty : tree -> bool

                  val mem : T_as_UCT.t -> tree -> bool

                  val min_elt : tree -> elt option

                  val max_elt : tree -> elt option

                  val choose : tree -> elt option

                  val fold : (elt -> 'a1 -> 'a1) -> tree -> 'a1 -> 'a1

                  val elements_aux :
                    T_as_UCT.t list -> tree -> T_as_UCT.t list

                  val elements : tree -> T_as_UCT.t list

                  val rev_elements_aux :
                    T_as_UCT.t list -> tree -> T_as_UCT.t list

                  val rev_elements : tree -> T_as_UCT.t list

                  val cardinal : tree -> nat

                  val maxdepth : tree -> nat

                  val mindepth : tree -> nat

                  val for_all : (elt -> bool) -> tree -> bool

                  val exists_ : (elt -> bool) -> tree -> bool

                  type enumeration =
                  | End
                  | More of elt * tree * enumeration

                  val cons : tree -> enumeration -> enumeration

                  val compare_more :
                    T_as_UCT.t -> (enumeration -> comparison) -> enumeration
                    -> comparison

                  val compare_cont :
                    tree -> (enumeration -> comparison) -> enumeration ->
                    comparison

                  val compare_end : enumeration -> comparison

                  val compare : tree -> tree -> comparison

                  val equal : tree -> tree -> bool

                  val subsetl : (tree -> bool) -> T_as_UCT.t -> tree -> bool

                  val subsetr : (tree -> bool) -> T_as_UCT.t -> tree -> bool

                  val subset : tree -> tree -> bool

                  type t = tree

                  val height : t -> Z_as_Int.t

                  val singleton : T_as_UCT.t -> tree

                  val create : t -> T_as_UCT.t -> t -> tree

                  val assert_false : t -> T_as_UCT.t -> t -> tree

                  val bal : t -> T_as_UCT.t -> t -> tree

                  val add : T_as_UCT.t -> tree -> tree

                  val join : tree -> elt -> t -> t

                  val remove_min : tree -> elt -> t -> t * elt

                  val merge : tree -> tree -> tree

                  val remove : T_as_UCT.t -> tree -> tree

                  val concat : tree -> tree -> tree

                  type triple = { t_left : t; t_in : bool; t_right : t }

                  val t_left : triple -> t

                  val t_in : triple -> bool

                  val t_right : triple -> t

                  val split : T_as_UCT.t -> tree -> triple

                  val inter : tree -> tree -> tree

                  val diff : tree -> tree -> tree

                  val union : tree -> tree -> tree

                  val filter : (elt -> bool) -> tree -> tree

                  val partition : (elt -> bool) -> t -> t * t

                  val ltb_tree : T_as_UCT.t -> tree -> bool

                  val gtb_tree : T_as_UCT.t -> tree -> bool

                  val isok : tree -> bool

                  module MX :
                   sig
                    module OrderTac :
                     sig
                      module OTF :
                       sig
                        type t = T_as_UCT.t

                        val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

                        val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
                       end

                      module TO :
                       sig
                        type t = T_as_UCT.t

                        val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

                        val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
                       end
                     end

                    val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                    val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                    val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
                   end

                  type coq_R_min_elt =
                  | R_min_elt_0 of tree
                  | R_min_elt_1 of tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree
                  | R_min_elt_2 of tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree * Z_as_Int.t * tree * T_as_UCT.t * tree
                     * elt option * coq_R_min_elt

                  type coq_R_max_elt =
                  | R_max_elt_0 of tree
                  | R_max_elt_1 of tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree
                  | R_max_elt_2 of tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree * Z_as_Int.t * tree * T_as_UCT.t * tree
                     * elt option * coq_R_max_elt

                  module L :
                   sig
                    module MO :
                     sig
                      module OrderTac :
                       sig
                        module OTF :
                         sig
                          type t = T_as_UCT.t

                          val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

                          val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
                         end

                        module TO :
                         sig
                          type t = T_as_UCT.t

                          val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

                          val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
                         end
                       end

                      val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                      val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                      val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
                     end
                   end

                  val flatten_e : enumeration -> elt list

                  type coq_R_bal =
                  | R_bal_0 of t * T_as_UCT.t * t
                  | R_bal_1 of t * T_as_UCT.t * t * Z_as_Int.t * tree
                     * T_as_UCT.t * tree
                  | R_bal_2 of t * T_as_UCT.t * t * Z_as_Int.t * tree
                     * T_as_UCT.t * tree
                  | R_bal_3 of t * T_as_UCT.t * t * Z_as_Int.t * tree
                     * T_as_UCT.t * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree
                  | R_bal_4 of t * T_as_UCT.t * t
                  | R_bal_5 of t * T_as_UCT.t * t * Z_as_Int.t * tree
                     * T_as_UCT.t * tree
                  | R_bal_6 of t * T_as_UCT.t * t * Z_as_Int.t * tree
                     * T_as_UCT.t * tree
                  | R_bal_7 of t * T_as_UCT.t * t * Z_as_Int.t * tree
                     * T_as_UCT.t * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree
                  | R_bal_8 of t * T_as_UCT.t * t

                  type coq_R_remove_min =
                  | R_remove_min_0 of tree * elt * t
                  | R_remove_min_1 of tree * elt * t * Z_as_Int.t * tree
                     * T_as_UCT.t * tree * (t * elt) * coq_R_remove_min * 
                     t * elt

                  type coq_R_merge =
                  | R_merge_0 of tree * tree
                  | R_merge_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree
                  | R_merge_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree * Z_as_Int.t * tree * T_as_UCT.t * tree * 
                     t * elt

                  type coq_R_concat =
                  | R_concat_0 of tree * tree
                  | R_concat_1 of tree * tree * Z_as_Int.t * tree
                     * T_as_UCT.t * tree
                  | R_concat_2 of tree * tree * Z_as_Int.t * tree
                     * T_as_UCT.t * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree * t * elt

                  type coq_R_inter =
                  | R_inter_0 of tree * tree
                  | R_inter_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree
                  | R_inter_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree * Z_as_Int.t * tree * T_as_UCT.t * tree * 
                     t * bool * t * tree * coq_R_inter * tree * coq_R_inter
                  | R_inter_3 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree * Z_as_Int.t * tree * T_as_UCT.t * tree * 
                     t * bool * t * tree * coq_R_inter * tree * coq_R_inter

                  type coq_R_diff =
                  | R_diff_0 of tree * tree
                  | R_diff_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree
                  | R_diff_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree * Z_as_Int.t * tree * T_as_UCT.t * tree * 
                     t * bool * t * tree * coq_R_diff * tree * coq_R_diff
                  | R_diff_3 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree * Z_as_Int.t * tree * T_as_UCT.t * tree * 
                     t * bool * t * tree * coq_R_diff * tree * coq_R_diff

                  type coq_R_union =
                  | R_union_0 of tree * tree
                  | R_union_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree
                  | R_union_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree * Z_as_Int.t * tree * T_as_UCT.t * tree * 
                     t * bool * t * tree * coq_R_union * tree * coq_R_union
                 end

                module E :
                 sig
                  type t = T_as_UCT.t

                  val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

                  val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
                 end

                type elt = T_as_UCT.t

                type t_ =
                  Raw.t
                  (* singleton inductive, whose constructor was Mkt *)

                val this : t_ -> Raw.t

                type t = t_

                val mem : elt -> t -> bool

                val add : elt -> t -> t

                val remove : elt -> t -> t

                val singleton : elt -> t

                val union : t -> t -> t

                val inter : t -> t -> t

                val diff : t -> t -> t

                val equal : t -> t -> bool

                val subset : t -> t -> bool

                val empty : t

                val is_empty : t -> bool

                val elements : t -> elt list

                val choose : t -> elt option

                val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

                val cardinal : t -> nat

                val filter : (elt -> bool) -> t -> t

                val for_all : (elt -> bool) -> t -> bool

                val exists_ : (elt -> bool) -> t -> bool

                val partition : (elt -> bool) -> t -> t * t

                val eq_dec : t -> t -> bool

                val compare : t -> t -> comparison

                val min_elt : t -> elt option

                val max_elt : t -> elt option
               end

              type elt = T_as_UCT.t

              type t = MSet.t

              val empty : t

              val is_empty : t -> bool

              val mem : elt -> t -> bool

              val add : elt -> t -> t

              val singleton : elt -> t

              val remove : elt -> t -> t

              val union : t -> t -> t

              val inter : t -> t -> t

              val diff : t -> t -> t

              val eq_dec : t -> t -> bool

              val equal : t -> t -> bool

              val subset : t -> t -> bool

              val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

              val for_all : (elt -> bool) -> t -> bool

              val exists_ : (elt -> bool) -> t -> bool

              val filter : (elt -> bool) -> t -> t

              val partition : (elt -> bool) -> t -> t * t

              val cardinal : t -> nat

              val elements : t -> elt list

              val choose : t -> elt option

              module MF :
               sig
                val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
               end

              val min_elt : t -> elt option

              val max_elt : t -> elt option

              val compare : t -> t -> t compare0

              module E :
               sig
                type t = T_as_UCT.t

                val compare : T_as_UCT.t -> T_as_UCT.t -> T_as_UCT.t compare0

                val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
               end
             end

            module SigFSF :
             sig
              val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
             end

            module SigFM :
             sig
              module E :
               sig
                type t = T_as_UCT.t

                val compare : T_as_UCT.t -> T_as_UCT.t -> T_as_UCT.t compare0

                val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
               end

              module Raw :
               sig
                type key = T_as_UCT.t

                type 'elt tree =
                | Leaf
                | Node of 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t

                val tree_rect :
                  'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
                  Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

                val tree_rec :
                  'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
                  Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

                val height : 'a1 tree -> Z_as_Int.t

                val cardinal : 'a1 tree -> nat

                val empty : 'a1 tree

                val is_empty : 'a1 tree -> bool

                val mem : T_as_UCT.t -> 'a1 tree -> bool

                val find : T_as_UCT.t -> 'a1 tree -> 'a1 option

                val create : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

                val assert_false :
                  'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

                val bal : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

                val add : key -> 'a1 -> 'a1 tree -> 'a1 tree

                val remove_min :
                  'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree * (key * 'a1)

                val merge : 'a1 tree -> 'a1 tree -> 'a1 tree

                val remove : T_as_UCT.t -> 'a1 tree -> 'a1 tree

                val join : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

                type 'elt triple = { t_left : 'elt tree; t_opt : 'elt option;
                                     t_right : 'elt tree }

                val t_left : 'a1 triple -> 'a1 tree

                val t_opt : 'a1 triple -> 'a1 option

                val t_right : 'a1 triple -> 'a1 tree

                val split : T_as_UCT.t -> 'a1 tree -> 'a1 triple

                val concat : 'a1 tree -> 'a1 tree -> 'a1 tree

                val elements_aux :
                  (key * 'a1) list -> 'a1 tree -> (key * 'a1) list

                val elements : 'a1 tree -> (key * 'a1) list

                val fold :
                  (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

                type 'elt enumeration =
                | End
                | More of key * 'elt * 'elt tree * 'elt enumeration

                val enumeration_rect :
                  'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 ->
                  'a2) -> 'a1 enumeration -> 'a2

                val enumeration_rec :
                  'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 ->
                  'a2) -> 'a1 enumeration -> 'a2

                val cons : 'a1 tree -> 'a1 enumeration -> 'a1 enumeration

                val equal_more :
                  ('a1 -> 'a1 -> bool) -> T_as_UCT.t -> 'a1 -> ('a1
                  enumeration -> bool) -> 'a1 enumeration -> bool

                val equal_cont :
                  ('a1 -> 'a1 -> bool) -> 'a1 tree -> ('a1 enumeration ->
                  bool) -> 'a1 enumeration -> bool

                val equal_end : 'a1 enumeration -> bool

                val equal :
                  ('a1 -> 'a1 -> bool) -> 'a1 tree -> 'a1 tree -> bool

                val map : ('a1 -> 'a2) -> 'a1 tree -> 'a2 tree

                val mapi : (key -> 'a1 -> 'a2) -> 'a1 tree -> 'a2 tree

                val map_option :
                  (key -> 'a1 -> 'a2 option) -> 'a1 tree -> 'a2 tree

                val map2_opt :
                  (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree ->
                  'a3 tree) -> ('a2 tree -> 'a3 tree) -> 'a1 tree -> 'a2 tree
                  -> 'a3 tree

                val map2 :
                  ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 tree -> 'a2
                  tree -> 'a3 tree

                module Proofs :
                 sig
                  module MX :
                   sig
                    module TO :
                     sig
                      type t = T_as_UCT.t
                     end

                    module IsTO :
                     sig
                     end

                    module OrderTac :
                     sig
                     end

                    val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                    val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                    val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
                   end

                  module PX :
                   sig
                    module MO :
                     sig
                      module TO :
                       sig
                        type t = T_as_UCT.t
                       end

                      module IsTO :
                       sig
                       end

                      module OrderTac :
                       sig
                       end

                      val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                      val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                      val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
                     end
                   end

                  module L :
                   sig
                    module MX :
                     sig
                      module TO :
                       sig
                        type t = T_as_UCT.t
                       end

                      module IsTO :
                       sig
                       end

                      module OrderTac :
                       sig
                       end

                      val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                      val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                      val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
                     end

                    module PX :
                     sig
                      module MO :
                       sig
                        module TO :
                         sig
                          type t = T_as_UCT.t
                         end

                        module IsTO :
                         sig
                         end

                        module OrderTac :
                         sig
                         end

                        val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                        val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                        val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
                       end
                     end

                    type key = T_as_UCT.t

                    type 'elt t = (T_as_UCT.t * 'elt) list

                    val empty : 'a1 t

                    val is_empty : 'a1 t -> bool

                    val mem : key -> 'a1 t -> bool

                    type 'elt coq_R_mem =
                    | R_mem_0 of 'elt t
                    | R_mem_1 of 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list
                    | R_mem_2 of 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list
                    | R_mem_3 of 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list * bool * 'elt coq_R_mem

                    val coq_R_mem_rect :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                      'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                      'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 ->
                      'a2) -> 'a1 t -> bool -> 'a1 coq_R_mem -> 'a2

                    val coq_R_mem_rec :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                      'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                      'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 ->
                      'a2) -> 'a1 t -> bool -> 'a1 coq_R_mem -> 'a2

                    val mem_rect :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                      'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                      'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val mem_rec :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                      'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                      'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val coq_R_mem_correct :
                      key -> 'a1 t -> bool -> 'a1 coq_R_mem

                    val find : key -> 'a1 t -> 'a1 option

                    type 'elt coq_R_find =
                    | R_find_0 of 'elt t
                    | R_find_1 of 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list
                    | R_find_2 of 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list
                    | R_find_3 of 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list * 'elt option
                       * 'elt coq_R_find

                    val coq_R_find_rect :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                      'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                      'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find ->
                      'a2 -> 'a2) -> 'a1 t -> 'a1 option -> 'a1 coq_R_find ->
                      'a2

                    val coq_R_find_rec :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                      'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                      'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find ->
                      'a2 -> 'a2) -> 'a1 t -> 'a1 option -> 'a1 coq_R_find ->
                      'a2

                    val find_rect :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                      'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                      'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val find_rec :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                      'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                      'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val coq_R_find_correct :
                      key -> 'a1 t -> 'a1 option -> 'a1 coq_R_find

                    val add : key -> 'a1 -> 'a1 t -> 'a1 t

                    type 'elt coq_R_add =
                    | R_add_0 of 'elt t
                    | R_add_1 of 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list
                    | R_add_2 of 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list
                    | R_add_3 of 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list * 'elt t * 'elt coq_R_add

                    val coq_R_add_rect :
                      key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
                      __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_add -> 'a2 ->
                      'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_add -> 'a2

                    val coq_R_add_rec :
                      key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
                      __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_add -> 'a2 ->
                      'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_add -> 'a2

                    val add_rect :
                      key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
                      __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val add_rec :
                      key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
                      __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val coq_R_add_correct :
                      key -> 'a1 -> 'a1 t -> 'a1 t -> 'a1 coq_R_add

                    val remove : key -> 'a1 t -> 'a1 t

                    type 'elt coq_R_remove =
                    | R_remove_0 of 'elt t
                    | R_remove_1 of 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list
                    | R_remove_2 of 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list
                    | R_remove_3 of 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list * 'elt t * 'elt coq_R_remove

                    val coq_R_remove_rect :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                      'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                      'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_remove -> 'a2
                      -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove -> 'a2

                    val coq_R_remove_rec :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                      'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                      'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_remove -> 'a2
                      -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove -> 'a2

                    val remove_rect :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                      'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                      'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val remove_rec :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                      'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                      'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val coq_R_remove_correct :
                      key -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove

                    val elements : 'a1 t -> 'a1 t

                    val fold :
                      (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

                    type ('elt, 'a) coq_R_fold =
                    | R_fold_0 of 'elt t * 'a
                    | R_fold_1 of 'elt t * 'a * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list * 'a * ('elt, 'a) coq_R_fold

                    val coq_R_fold_rect :
                      (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ ->
                      'a3) -> ('a1 t -> 'a2 -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> 'a2 -> ('a1, 'a2)
                      coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a2 ->
                      ('a1, 'a2) coq_R_fold -> 'a3

                    val coq_R_fold_rec :
                      (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ ->
                      'a3) -> ('a1 t -> 'a2 -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> 'a2 -> ('a1, 'a2)
                      coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a2 ->
                      ('a1, 'a2) coq_R_fold -> 'a3

                    val fold_rect :
                      (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ ->
                      'a3) -> ('a1 t -> 'a2 -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> 'a3 -> 'a3) -> 'a1 t
                      -> 'a2 -> 'a3

                    val fold_rec :
                      (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ ->
                      'a3) -> ('a1 t -> 'a2 -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> 'a3 -> 'a3) -> 'a1 t
                      -> 'a2 -> 'a3

                    val coq_R_fold_correct :
                      (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2 ->
                      ('a1, 'a2) coq_R_fold

                    val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool

                    type 'elt coq_R_equal =
                    | R_equal_0 of 'elt t * 'elt t
                    | R_equal_1 of 'elt t * 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list * bool * 'elt coq_R_equal
                    | R_equal_2 of 'elt t * 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list * T_as_UCT.t compare0
                    | R_equal_3 of 'elt t * 'elt t * 'elt t * 'elt t

                    val coq_R_equal_rect :
                      ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                      'a2) -> ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> bool ->
                      'a1 coq_R_equal -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t ->
                      T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
                      T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
                      T_as_UCT.t compare0 -> __ -> __ -> 'a2) -> ('a1 t ->
                      'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2) ->
                      'a1 t -> 'a1 t -> bool -> 'a1 coq_R_equal -> 'a2

                    val coq_R_equal_rec :
                      ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                      'a2) -> ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> bool ->
                      'a1 coq_R_equal -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t ->
                      T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
                      T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
                      T_as_UCT.t compare0 -> __ -> __ -> 'a2) -> ('a1 t ->
                      'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2) ->
                      'a1 t -> 'a1 t -> bool -> 'a1 coq_R_equal -> 'a2

                    val equal_rect :
                      ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                      'a2) -> ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
                      'a2) -> ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t compare0 ->
                      __ -> __ -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ ->
                      'a1 t -> __ -> __ -> 'a2) -> 'a1 t -> 'a1 t -> 'a2

                    val equal_rec :
                      ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                      'a2) -> ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
                      'a2) -> ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t compare0 ->
                      __ -> __ -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ ->
                      'a1 t -> __ -> __ -> 'a2) -> 'a1 t -> 'a1 t -> 'a2

                    val coq_R_equal_correct :
                      ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool -> 'a1
                      coq_R_equal

                    val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

                    val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

                    val option_cons :
                      key -> 'a1 option -> (key * 'a1) list -> (key * 'a1)
                      list

                    val map2_l :
                      ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t ->
                      'a3 t

                    val map2_r :
                      ('a1 option -> 'a2 option -> 'a3 option) -> 'a2 t ->
                      'a3 t

                    val map2 :
                      ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t ->
                      'a2 t -> 'a3 t

                    val combine :
                      'a1 t -> 'a2 t -> ('a1 option * 'a2 option) t

                    val fold_right_pair :
                      ('a1 -> 'a2 -> 'a3 -> 'a3) -> ('a1 * 'a2) list -> 'a3
                      -> 'a3

                    val map2_alt :
                      ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t ->
                      'a2 t -> (key * 'a3) list

                    val at_least_one :
                      'a1 option -> 'a2 option -> ('a1 option * 'a2 option)
                      option

                    val at_least_one_then_f :
                      ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 option
                      -> 'a2 option -> 'a3 option
                   end

                  type 'elt coq_R_mem =
                  | R_mem_0 of 'elt tree
                  | R_mem_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                     * Z_as_Int.t * bool * 'elt coq_R_mem
                  | R_mem_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                     * Z_as_Int.t
                  | R_mem_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                     * Z_as_Int.t * bool * 'elt coq_R_mem

                  val coq_R_mem_rect :
                    T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key
                    -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
                    bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 tree -> bool
                    -> 'a1 coq_R_mem -> 'a2

                  val coq_R_mem_rec :
                    T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key
                    -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
                    bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 tree -> bool
                    -> 'a1 coq_R_mem -> 'a2

                  type 'elt coq_R_find =
                  | R_find_0 of 'elt tree
                  | R_find_1 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'elt option * 'elt coq_R_find
                  | R_find_2 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t
                  | R_find_3 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'elt option * 'elt coq_R_find

                  val coq_R_find_rect :
                    T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) ->
                    ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) ->
                    'a1 tree -> 'a1 option -> 'a1 coq_R_find -> 'a2

                  val coq_R_find_rec :
                    T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) ->
                    ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) ->
                    'a1 tree -> 'a1 option -> 'a1 coq_R_find -> 'a2

                  type 'elt coq_R_bal =
                  | R_bal_0 of 'elt tree * key * 'elt * 'elt tree
                  | R_bal_1 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                     * key * 'elt * 'elt tree * Z_as_Int.t
                  | R_bal_2 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                     * key * 'elt * 'elt tree * Z_as_Int.t
                  | R_bal_3 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                     * key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t
                  | R_bal_4 of 'elt tree * key * 'elt * 'elt tree
                  | R_bal_5 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                     * key * 'elt * 'elt tree * Z_as_Int.t
                  | R_bal_6 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                     * key * 'elt * 'elt tree * Z_as_Int.t
                  | R_bal_7 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                     * key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t
                  | R_bal_8 of 'elt tree * key * 'elt * 'elt tree

                  val coq_R_bal_rect :
                    ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ ->
                    'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
                    -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                    -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1
                    tree -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree
                    -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key
                    -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
                    -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 ->
                    'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key ->
                    'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2)
                    -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __
                    -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key ->
                    'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree ->
                    key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
                    'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
                    -> __ -> __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree
                    -> 'a1 tree -> 'a1 coq_R_bal -> 'a2

                  val coq_R_bal_rec :
                    ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ ->
                    'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
                    -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                    -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1
                    tree -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree
                    -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key
                    -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
                    -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 ->
                    'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key ->
                    'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2)
                    -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __
                    -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key ->
                    'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree ->
                    key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
                    'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
                    -> __ -> __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree
                    -> 'a1 tree -> 'a1 coq_R_bal -> 'a2

                  type 'elt coq_R_add =
                  | R_add_0 of 'elt tree
                  | R_add_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                     * Z_as_Int.t * 'elt tree * 'elt coq_R_add
                  | R_add_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                     * Z_as_Int.t
                  | R_add_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                     * Z_as_Int.t * 'elt tree * 'elt coq_R_add

                  val coq_R_add_rect :
                    key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key
                    -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
                    tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 tree -> 'a1
                    tree -> 'a1 coq_R_add -> 'a2

                  val coq_R_add_rec :
                    key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key
                    -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
                    tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 tree -> 'a1
                    tree -> 'a1 coq_R_add -> 'a2

                  type 'elt coq_R_remove_min =
                  | R_remove_min_0 of 'elt tree * key * 'elt * 'elt tree
                  | R_remove_min_1 of 'elt tree * key * 'elt * 'elt tree
                     * 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t
                     * ('elt tree * (key * 'elt)) * 'elt coq_R_remove_min
                     * 'elt tree * (key * 'elt)

                  val coq_R_remove_min_rect :
                    ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1
                    tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1
                    -> 'a1 tree -> Z_as_Int.t -> __ -> ('a1
                    tree * (key * 'a1)) -> 'a1 coq_R_remove_min -> 'a2 -> 'a1
                    tree -> (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> key ->
                    'a1 -> 'a1 tree -> ('a1 tree * (key * 'a1)) -> 'a1
                    coq_R_remove_min -> 'a2

                  val coq_R_remove_min_rec :
                    ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1
                    tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1
                    -> 'a1 tree -> Z_as_Int.t -> __ -> ('a1
                    tree * (key * 'a1)) -> 'a1 coq_R_remove_min -> 'a2 -> 'a1
                    tree -> (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> key ->
                    'a1 -> 'a1 tree -> ('a1 tree * (key * 'a1)) -> 'a1
                    coq_R_remove_min -> 'a2

                  type 'elt coq_R_merge =
                  | R_merge_0 of 'elt tree * 'elt tree
                  | R_merge_1 of 'elt tree * 'elt tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t
                  | R_merge_2 of 'elt tree * 'elt tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree
                     * (key * 'elt) * key * 'elt

                  val coq_R_merge_rect :
                    ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> (key * 'a1) -> __ -> key -> 'a1 -> __ -> 'a2) -> 'a1
                    tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_merge -> 'a2

                  val coq_R_merge_rec :
                    ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> (key * 'a1) -> __ -> key -> 'a1 -> __ -> 'a2) -> 'a1
                    tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_merge -> 'a2

                  type 'elt coq_R_remove =
                  | R_remove_0 of 'elt tree
                  | R_remove_1 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'elt tree * 'elt coq_R_remove
                  | R_remove_2 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t
                  | R_remove_3 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'elt tree * 'elt coq_R_remove

                  val coq_R_remove_rect :
                    T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) ->
                    ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) ->
                    'a1 tree -> 'a1 tree -> 'a1 coq_R_remove -> 'a2

                  val coq_R_remove_rec :
                    T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) ->
                    ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) ->
                    'a1 tree -> 'a1 tree -> 'a1 coq_R_remove -> 'a2

                  type 'elt coq_R_concat =
                  | R_concat_0 of 'elt tree * 'elt tree
                  | R_concat_1 of 'elt tree * 'elt tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t
                  | R_concat_2 of 'elt tree * 'elt tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree
                     * (key * 'elt)

                  val coq_R_concat_rect :
                    ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> 'a1 tree ->
                    'a1 tree -> 'a1 coq_R_concat -> 'a2

                  val coq_R_concat_rec :
                    ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> 'a1 tree ->
                    'a1 tree -> 'a1 coq_R_concat -> 'a2

                  type 'elt coq_R_split =
                  | R_split_0 of 'elt tree
                  | R_split_1 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'elt triple
                     * 'elt coq_R_split * 'elt tree * 'elt option * 'elt tree
                  | R_split_2 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t
                  | R_split_3 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'elt triple
                     * 'elt coq_R_split * 'elt tree * 'elt option * 'elt tree

                  val coq_R_split_rect :
                    T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree
                    -> 'a1 option -> 'a1 tree -> __ -> 'a2) -> ('a1 tree ->
                    'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
                    -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 triple
                    -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option ->
                    'a1 tree -> __ -> 'a2) -> 'a1 tree -> 'a1 triple -> 'a1
                    coq_R_split -> 'a2

                  val coq_R_split_rec :
                    T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree
                    -> 'a1 option -> 'a1 tree -> __ -> 'a2) -> ('a1 tree ->
                    'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
                    -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 triple
                    -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option ->
                    'a1 tree -> __ -> 'a2) -> 'a1 tree -> 'a1 triple -> 'a1
                    coq_R_split -> 'a2

                  type ('elt, 'x) coq_R_map_option =
                  | R_map_option_0 of 'elt tree
                  | R_map_option_1 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'x * 'x tree
                     * ('elt, 'x) coq_R_map_option * 'x tree
                     * ('elt, 'x) coq_R_map_option
                  | R_map_option_2 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'x tree
                     * ('elt, 'x) coq_R_map_option * 'x tree
                     * ('elt, 'x) coq_R_map_option

                  val coq_R_map_option_rect :
                    (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) ->
                    ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> 'a2 -> __ -> 'a2 tree -> ('a1, 'a2)
                    coq_R_map_option -> 'a3 -> 'a2 tree -> ('a1, 'a2)
                    coq_R_map_option -> 'a3 -> 'a3) -> ('a1 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                    'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2
                    tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> 'a1
                    tree -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3

                  val coq_R_map_option_rec :
                    (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) ->
                    ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> 'a2 -> __ -> 'a2 tree -> ('a1, 'a2)
                    coq_R_map_option -> 'a3 -> 'a2 tree -> ('a1, 'a2)
                    coq_R_map_option -> 'a3 -> 'a3) -> ('a1 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                    'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2
                    tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> 'a1
                    tree -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3

                  type ('elt, 'x0, 'x) coq_R_map2_opt =
                  | R_map2_opt_0 of 'elt tree * 'x0 tree
                  | R_map2_opt_1 of 'elt tree * 'x0 tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t
                  | R_map2_opt_2 of 'elt tree * 'x0 tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t * 'x0 tree * 
                     key * 'x0 * 'x0 tree * Z_as_Int.t * 'x0 tree
                     * 'x0 option * 'x0 tree * 'x * 'x tree
                     * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
                     * ('elt, 'x0, 'x) coq_R_map2_opt
                  | R_map2_opt_3 of 'elt tree * 'x0 tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t * 'x0 tree * 
                     key * 'x0 * 'x0 tree * Z_as_Int.t * 'x0 tree
                     * 'x0 option * 'x0 tree * 'x tree
                     * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
                     * ('elt, 'x0, 'x) coq_R_map2_opt

                  val coq_R_map2_opt_rect :
                    (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree ->
                    'a3 tree) -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2
                    tree -> __ -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                    'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1
                    -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 tree -> key -> 'a2
                    -> 'a2 tree -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2 option
                    -> 'a2 tree -> __ -> 'a3 -> __ -> 'a3 tree -> ('a1, 'a2,
                    'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
                    coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree ->
                    'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    'a2 tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ ->
                    'a2 tree -> 'a2 option -> 'a2 tree -> __ -> __ -> 'a3
                    tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree
                    -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1
                    tree -> 'a2 tree -> 'a3 tree -> ('a1, 'a2, 'a3)
                    coq_R_map2_opt -> 'a4

                  val coq_R_map2_opt_rec :
                    (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree ->
                    'a3 tree) -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2
                    tree -> __ -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                    'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1
                    -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 tree -> key -> 'a2
                    -> 'a2 tree -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2 option
                    -> 'a2 tree -> __ -> 'a3 -> __ -> 'a3 tree -> ('a1, 'a2,
                    'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
                    coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree ->
                    'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    'a2 tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ ->
                    'a2 tree -> 'a2 option -> 'a2 tree -> __ -> __ -> 'a3
                    tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree
                    -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1
                    tree -> 'a2 tree -> 'a3 tree -> ('a1, 'a2, 'a3)
                    coq_R_map2_opt -> 'a4

                  val fold' :
                    (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

                  val flatten_e : 'a1 enumeration -> (key * 'a1) list
                 end
               end

              type 'elt bst =
                'elt Raw.tree
                (* singleton inductive, whose constructor was Bst *)

              val this : 'a1 bst -> 'a1 Raw.tree

              type 'elt t = 'elt bst

              type key = T_as_UCT.t

              val empty : 'a1 t

              val is_empty : 'a1 t -> bool

              val add : key -> 'a1 -> 'a1 t -> 'a1 t

              val remove : key -> 'a1 t -> 'a1 t

              val mem : key -> 'a1 t -> bool

              val find : key -> 'a1 t -> 'a1 option

              val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

              val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

              val map2 :
                ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t ->
                'a3 t

              val elements : 'a1 t -> (key * 'a1) list

              val cardinal : 'a1 t -> nat

              val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

              val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool
             end

            module SigFMF :
             sig
              val eqb : T_as_UCT.t -> T_as_UCT.t -> bool

              val coq_In_dec : 'a1 SigFM.t -> SigFM.key -> bool
             end

            module Strings :
             sig
              type coq_String = Ty.coq_Sigma list

              val coq_String_dec : coq_String -> coq_String -> bool

              val rm_empty : coq_String list -> Ty.coq_Sigma list list
             end

            module Regexes :
             sig
              type regex =
              | EmptySet
              | EmptyStr
              | Char of Ty.coq_Sigma
              | App of regex * regex
              | Union of regex * regex
              | Star of regex

              val regex_rect :
                'a1 -> 'a1 -> (Ty.coq_Sigma -> 'a1) -> (regex -> 'a1 -> regex
                -> 'a1 -> 'a1) -> (regex -> 'a1 -> regex -> 'a1 -> 'a1) ->
                (regex -> 'a1 -> 'a1) -> regex -> 'a1

              val regex_rec :
                'a1 -> 'a1 -> (Ty.coq_Sigma -> 'a1) -> (regex -> 'a1 -> regex
                -> 'a1 -> 'a1) -> (regex -> 'a1 -> regex -> 'a1 -> 'a1) ->
                (regex -> 'a1 -> 'a1) -> regex -> 'a1

              val regex_dec : regex -> regex -> bool

              val regex_eq : regex -> regex -> bool

              val nullable' : regex -> bool

              val nullable : regex -> bool

              val derivative : Ty.coq_Sigma -> regex -> regex

              val derivative_list : Ty.coq_Sigma list -> regex -> regex

              val re_compare : regex -> regex -> comparison
             end

            module Coq_regex_as_UCT :
             sig
              type t = Regexes.regex

              val compare : Regexes.regex -> Regexes.regex -> comparison
             end

            module Coq_regex_as_UOT :
             sig
              type t = Coq_regex_as_UCT.t

              val compare : t -> t -> t compare0

              val eq_dec : t -> t -> bool
             end

            module Coq_reFS :
             sig
              module X' :
               sig
                type t = Coq_regex_as_UCT.t

                val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                val compare :
                  Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> comparison
               end

              module MSet :
               sig
                module Raw :
                 sig
                  type elt = Coq_regex_as_UCT.t

                  type tree =
                  | Leaf
                  | Node of Z_as_Int.t * tree * Coq_regex_as_UCT.t * tree

                  val empty : tree

                  val is_empty : tree -> bool

                  val mem : Coq_regex_as_UCT.t -> tree -> bool

                  val min_elt : tree -> elt option

                  val max_elt : tree -> elt option

                  val choose : tree -> elt option

                  val fold : (elt -> 'a1 -> 'a1) -> tree -> 'a1 -> 'a1

                  val elements_aux :
                    Coq_regex_as_UCT.t list -> tree -> Coq_regex_as_UCT.t list

                  val elements : tree -> Coq_regex_as_UCT.t list

                  val rev_elements_aux :
                    Coq_regex_as_UCT.t list -> tree -> Coq_regex_as_UCT.t list

                  val rev_elements : tree -> Coq_regex_as_UCT.t list

                  val cardinal : tree -> nat

                  val maxdepth : tree -> nat

                  val mindepth : tree -> nat

                  val for_all : (elt -> bool) -> tree -> bool

                  val exists_ : (elt -> bool) -> tree -> bool

                  type enumeration =
                  | End
                  | More of elt * tree * enumeration

                  val cons : tree -> enumeration -> enumeration

                  val compare_more :
                    Coq_regex_as_UCT.t -> (enumeration -> comparison) ->
                    enumeration -> comparison

                  val compare_cont :
                    tree -> (enumeration -> comparison) -> enumeration ->
                    comparison

                  val compare_end : enumeration -> comparison

                  val compare : tree -> tree -> comparison

                  val equal : tree -> tree -> bool

                  val subsetl :
                    (tree -> bool) -> Coq_regex_as_UCT.t -> tree -> bool

                  val subsetr :
                    (tree -> bool) -> Coq_regex_as_UCT.t -> tree -> bool

                  val subset : tree -> tree -> bool

                  type t = tree

                  val height : t -> Z_as_Int.t

                  val singleton : Coq_regex_as_UCT.t -> tree

                  val create : t -> Coq_regex_as_UCT.t -> t -> tree

                  val assert_false : t -> Coq_regex_as_UCT.t -> t -> tree

                  val bal : t -> Coq_regex_as_UCT.t -> t -> tree

                  val add : Coq_regex_as_UCT.t -> tree -> tree

                  val join : tree -> elt -> t -> t

                  val remove_min : tree -> elt -> t -> t * elt

                  val merge : tree -> tree -> tree

                  val remove : Coq_regex_as_UCT.t -> tree -> tree

                  val concat : tree -> tree -> tree

                  type triple = { t_left : t; t_in : bool; t_right : t }

                  val t_left : triple -> t

                  val t_in : triple -> bool

                  val t_right : triple -> t

                  val split : Coq_regex_as_UCT.t -> tree -> triple

                  val inter : tree -> tree -> tree

                  val diff : tree -> tree -> tree

                  val union : tree -> tree -> tree

                  val filter : (elt -> bool) -> tree -> tree

                  val partition : (elt -> bool) -> t -> t * t

                  val ltb_tree : Coq_regex_as_UCT.t -> tree -> bool

                  val gtb_tree : Coq_regex_as_UCT.t -> tree -> bool

                  val isok : tree -> bool

                  module MX :
                   sig
                    module OrderTac :
                     sig
                      module OTF :
                       sig
                        type t = Coq_regex_as_UCT.t

                        val compare :
                          Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t ->
                          comparison

                        val eq_dec :
                          Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                       end

                      module TO :
                       sig
                        type t = Coq_regex_as_UCT.t

                        val compare :
                          Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t ->
                          comparison

                        val eq_dec :
                          Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                       end
                     end

                    val eq_dec :
                      Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                    val lt_dec :
                      Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                    val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                   end

                  type coq_R_min_elt =
                  | R_min_elt_0 of tree
                  | R_min_elt_1 of tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree
                  | R_min_elt_2 of tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * elt option * coq_R_min_elt

                  type coq_R_max_elt =
                  | R_max_elt_0 of tree
                  | R_max_elt_1 of tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree
                  | R_max_elt_2 of tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * elt option * coq_R_max_elt

                  module L :
                   sig
                    module MO :
                     sig
                      module OrderTac :
                       sig
                        module OTF :
                         sig
                          type t = Coq_regex_as_UCT.t

                          val compare :
                            Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t ->
                            comparison

                          val eq_dec :
                            Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                         end

                        module TO :
                         sig
                          type t = Coq_regex_as_UCT.t

                          val compare :
                            Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t ->
                            comparison

                          val eq_dec :
                            Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                         end
                       end

                      val eq_dec :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                      val lt_dec :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                      val eqb :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                     end
                   end

                  val flatten_e : enumeration -> elt list

                  type coq_R_bal =
                  | R_bal_0 of t * Coq_regex_as_UCT.t * t
                  | R_bal_1 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * 
                     tree * Coq_regex_as_UCT.t * tree
                  | R_bal_2 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * 
                     tree * Coq_regex_as_UCT.t * tree
                  | R_bal_3 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * 
                     tree * Coq_regex_as_UCT.t * tree * Z_as_Int.t * 
                     tree * Coq_regex_as_UCT.t * tree
                  | R_bal_4 of t * Coq_regex_as_UCT.t * t
                  | R_bal_5 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * 
                     tree * Coq_regex_as_UCT.t * tree
                  | R_bal_6 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * 
                     tree * Coq_regex_as_UCT.t * tree
                  | R_bal_7 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * 
                     tree * Coq_regex_as_UCT.t * tree * Z_as_Int.t * 
                     tree * Coq_regex_as_UCT.t * tree
                  | R_bal_8 of t * Coq_regex_as_UCT.t * t

                  type coq_R_remove_min =
                  | R_remove_min_0 of tree * elt * t
                  | R_remove_min_1 of tree * elt * t * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * (t * elt)
                     * coq_R_remove_min * t * elt

                  type coq_R_merge =
                  | R_merge_0 of tree * tree
                  | R_merge_1 of tree * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree
                  | R_merge_2 of tree * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * t * elt

                  type coq_R_concat =
                  | R_concat_0 of tree * tree
                  | R_concat_1 of tree * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree
                  | R_concat_2 of tree * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * t * elt

                  type coq_R_inter =
                  | R_inter_0 of tree * tree
                  | R_inter_1 of tree * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree
                  | R_inter_2 of tree * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * t * bool * t * tree
                     * coq_R_inter * tree * coq_R_inter
                  | R_inter_3 of tree * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * t * bool * t * tree
                     * coq_R_inter * tree * coq_R_inter

                  type coq_R_diff =
                  | R_diff_0 of tree * tree
                  | R_diff_1 of tree * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree
                  | R_diff_2 of tree * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * t * bool * t * tree
                     * coq_R_diff * tree * coq_R_diff
                  | R_diff_3 of tree * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * t * bool * t * tree
                     * coq_R_diff * tree * coq_R_diff

                  type coq_R_union =
                  | R_union_0 of tree * tree
                  | R_union_1 of tree * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree
                  | R_union_2 of tree * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * t * bool * t * tree
                     * coq_R_union * tree * coq_R_union
                 end

                module E :
                 sig
                  type t = Coq_regex_as_UCT.t

                  val compare :
                    Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> comparison

                  val eq_dec :
                    Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                 end

                type elt = Coq_regex_as_UCT.t

                type t_ =
                  Raw.t
                  (* singleton inductive, whose constructor was Mkt *)

                val this : t_ -> Raw.t

                type t = t_

                val mem : elt -> t -> bool

                val add : elt -> t -> t

                val remove : elt -> t -> t

                val singleton : elt -> t

                val union : t -> t -> t

                val inter : t -> t -> t

                val diff : t -> t -> t

                val equal : t -> t -> bool

                val subset : t -> t -> bool

                val empty : t

                val is_empty : t -> bool

                val elements : t -> elt list

                val choose : t -> elt option

                val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

                val cardinal : t -> nat

                val filter : (elt -> bool) -> t -> t

                val for_all : (elt -> bool) -> t -> bool

                val exists_ : (elt -> bool) -> t -> bool

                val partition : (elt -> bool) -> t -> t * t

                val eq_dec : t -> t -> bool

                val compare : t -> t -> comparison

                val min_elt : t -> elt option

                val max_elt : t -> elt option
               end

              type elt = Coq_regex_as_UCT.t

              type t = MSet.t

              val empty : t

              val is_empty : t -> bool

              val mem : elt -> t -> bool

              val add : elt -> t -> t

              val singleton : elt -> t

              val remove : elt -> t -> t

              val union : t -> t -> t

              val inter : t -> t -> t

              val diff : t -> t -> t

              val eq_dec : t -> t -> bool

              val equal : t -> t -> bool

              val subset : t -> t -> bool

              val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

              val for_all : (elt -> bool) -> t -> bool

              val exists_ : (elt -> bool) -> t -> bool

              val filter : (elt -> bool) -> t -> t

              val partition : (elt -> bool) -> t -> t * t

              val cardinal : t -> nat

              val elements : t -> elt list

              val choose : t -> elt option

              module MF :
               sig
                val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
               end

              val min_elt : t -> elt option

              val max_elt : t -> elt option

              val compare : t -> t -> t compare0

              module E :
               sig
                type t = Coq_regex_as_UCT.t

                val compare :
                  Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t ->
                  Coq_regex_as_UCT.t compare0

                val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
               end
             end

            module Coq_reFSF :
             sig
              val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
             end

            module Coq_reFM :
             sig
              module E :
               sig
                type t = Coq_regex_as_UCT.t

                val compare :
                  Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t ->
                  Coq_regex_as_UCT.t compare0

                val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
               end

              module Raw :
               sig
                type key = Coq_regex_as_UCT.t

                type 'elt tree =
                | Leaf
                | Node of 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t

                val tree_rect :
                  'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
                  Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

                val tree_rec :
                  'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
                  Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

                val height : 'a1 tree -> Z_as_Int.t

                val cardinal : 'a1 tree -> nat

                val empty : 'a1 tree

                val is_empty : 'a1 tree -> bool

                val mem : Coq_regex_as_UCT.t -> 'a1 tree -> bool

                val find : Coq_regex_as_UCT.t -> 'a1 tree -> 'a1 option

                val create : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

                val assert_false :
                  'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

                val bal : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

                val add : key -> 'a1 -> 'a1 tree -> 'a1 tree

                val remove_min :
                  'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree * (key * 'a1)

                val merge : 'a1 tree -> 'a1 tree -> 'a1 tree

                val remove : Coq_regex_as_UCT.t -> 'a1 tree -> 'a1 tree

                val join : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

                type 'elt triple = { t_left : 'elt tree; t_opt : 'elt option;
                                     t_right : 'elt tree }

                val t_left : 'a1 triple -> 'a1 tree

                val t_opt : 'a1 triple -> 'a1 option

                val t_right : 'a1 triple -> 'a1 tree

                val split : Coq_regex_as_UCT.t -> 'a1 tree -> 'a1 triple

                val concat : 'a1 tree -> 'a1 tree -> 'a1 tree

                val elements_aux :
                  (key * 'a1) list -> 'a1 tree -> (key * 'a1) list

                val elements : 'a1 tree -> (key * 'a1) list

                val fold :
                  (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

                type 'elt enumeration =
                | End
                | More of key * 'elt * 'elt tree * 'elt enumeration

                val enumeration_rect :
                  'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 ->
                  'a2) -> 'a1 enumeration -> 'a2

                val enumeration_rec :
                  'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 ->
                  'a2) -> 'a1 enumeration -> 'a2

                val cons : 'a1 tree -> 'a1 enumeration -> 'a1 enumeration

                val equal_more :
                  ('a1 -> 'a1 -> bool) -> Coq_regex_as_UCT.t -> 'a1 -> ('a1
                  enumeration -> bool) -> 'a1 enumeration -> bool

                val equal_cont :
                  ('a1 -> 'a1 -> bool) -> 'a1 tree -> ('a1 enumeration ->
                  bool) -> 'a1 enumeration -> bool

                val equal_end : 'a1 enumeration -> bool

                val equal :
                  ('a1 -> 'a1 -> bool) -> 'a1 tree -> 'a1 tree -> bool

                val map : ('a1 -> 'a2) -> 'a1 tree -> 'a2 tree

                val mapi : (key -> 'a1 -> 'a2) -> 'a1 tree -> 'a2 tree

                val map_option :
                  (key -> 'a1 -> 'a2 option) -> 'a1 tree -> 'a2 tree

                val map2_opt :
                  (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree ->
                  'a3 tree) -> ('a2 tree -> 'a3 tree) -> 'a1 tree -> 'a2 tree
                  -> 'a3 tree

                val map2 :
                  ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 tree -> 'a2
                  tree -> 'a3 tree

                module Proofs :
                 sig
                  module MX :
                   sig
                    module TO :
                     sig
                      type t = Coq_regex_as_UCT.t
                     end

                    module IsTO :
                     sig
                     end

                    module OrderTac :
                     sig
                     end

                    val eq_dec :
                      Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                    val lt_dec :
                      Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                    val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                   end

                  module PX :
                   sig
                    module MO :
                     sig
                      module TO :
                       sig
                        type t = Coq_regex_as_UCT.t
                       end

                      module IsTO :
                       sig
                       end

                      module OrderTac :
                       sig
                       end

                      val eq_dec :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                      val lt_dec :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                      val eqb :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                     end
                   end

                  module L :
                   sig
                    module MX :
                     sig
                      module TO :
                       sig
                        type t = Coq_regex_as_UCT.t
                       end

                      module IsTO :
                       sig
                       end

                      module OrderTac :
                       sig
                       end

                      val eq_dec :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                      val lt_dec :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                      val eqb :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                     end

                    module PX :
                     sig
                      module MO :
                       sig
                        module TO :
                         sig
                          type t = Coq_regex_as_UCT.t
                         end

                        module IsTO :
                         sig
                         end

                        module OrderTac :
                         sig
                         end

                        val eq_dec :
                          Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                        val lt_dec :
                          Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                        val eqb :
                          Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                       end
                     end

                    type key = Coq_regex_as_UCT.t

                    type 'elt t = (Coq_regex_as_UCT.t * 'elt) list

                    val empty : 'a1 t

                    val is_empty : 'a1 t -> bool

                    val mem : key -> 'a1 t -> bool

                    type 'elt coq_R_mem =
                    | R_mem_0 of 'elt t
                    | R_mem_1 of 'elt t * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list
                    | R_mem_2 of 'elt t * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list
                    | R_mem_3 of 'elt t * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list * bool
                       * 'elt coq_R_mem

                    val coq_R_mem_rect :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2
                      -> 'a2) -> 'a1 t -> bool -> 'a1 coq_R_mem -> 'a2

                    val coq_R_mem_rec :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2
                      -> 'a2) -> 'a1 t -> bool -> 'a1 coq_R_mem -> 'a2

                    val mem_rect :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val mem_rec :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val coq_R_mem_correct :
                      key -> 'a1 t -> bool -> 'a1 coq_R_mem

                    val find : key -> 'a1 t -> 'a1 option

                    type 'elt coq_R_find =
                    | R_find_0 of 'elt t
                    | R_find_1 of 'elt t * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list
                    | R_find_2 of 'elt t * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list
                    | R_find_3 of 'elt t * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list * 'elt option
                       * 'elt coq_R_find

                    val coq_R_find_rect :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find
                      -> 'a2 -> 'a2) -> 'a1 t -> 'a1 option -> 'a1 coq_R_find
                      -> 'a2

                    val coq_R_find_rec :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find
                      -> 'a2 -> 'a2) -> 'a1 t -> 'a1 option -> 'a1 coq_R_find
                      -> 'a2

                    val find_rect :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val find_rec :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val coq_R_find_correct :
                      key -> 'a1 t -> 'a1 option -> 'a1 coq_R_find

                    val add : key -> 'a1 -> 'a1 t -> 'a1 t

                    type 'elt coq_R_add =
                    | R_add_0 of 'elt t
                    | R_add_1 of 'elt t * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list
                    | R_add_2 of 'elt t * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list
                    | R_add_3 of 'elt t * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list * 'elt t
                       * 'elt coq_R_add

                    val coq_R_add_rect :
                      key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_add -> 'a2
                      -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_add -> 'a2

                    val coq_R_add_rec :
                      key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_add -> 'a2
                      -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_add -> 'a2

                    val add_rect :
                      key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val add_rec :
                      key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val coq_R_add_correct :
                      key -> 'a1 -> 'a1 t -> 'a1 t -> 'a1 coq_R_add

                    val remove : key -> 'a1 t -> 'a1 t

                    type 'elt coq_R_remove =
                    | R_remove_0 of 'elt t
                    | R_remove_1 of 'elt t * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list
                    | R_remove_2 of 'elt t * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list
                    | R_remove_3 of 'elt t * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list * 'elt t
                       * 'elt coq_R_remove

                    val coq_R_remove_rect :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_remove ->
                      'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove -> 'a2

                    val coq_R_remove_rec :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_remove ->
                      'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove -> 'a2

                    val remove_rect :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val remove_rec :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val coq_R_remove_correct :
                      key -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove

                    val elements : 'a1 t -> 'a1 t

                    val fold :
                      (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

                    type ('elt, 'a) coq_R_fold =
                    | R_fold_0 of 'elt t * 'a
                    | R_fold_1 of 'elt t * 'a * Coq_regex_as_UCT.t * 
                       'elt * (Coq_regex_as_UCT.t * 'elt) list * 'a
                       * ('elt, 'a) coq_R_fold

                    val coq_R_fold_rect :
                      (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ ->
                      'a3) -> ('a1 t -> 'a2 -> Coq_regex_as_UCT.t -> 'a1 ->
                      (Coq_regex_as_UCT.t * 'a1) list -> __ -> 'a2 -> ('a1,
                      'a2) coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a2
                      -> ('a1, 'a2) coq_R_fold -> 'a3

                    val coq_R_fold_rec :
                      (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ ->
                      'a3) -> ('a1 t -> 'a2 -> Coq_regex_as_UCT.t -> 'a1 ->
                      (Coq_regex_as_UCT.t * 'a1) list -> __ -> 'a2 -> ('a1,
                      'a2) coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a2
                      -> ('a1, 'a2) coq_R_fold -> 'a3

                    val fold_rect :
                      (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ ->
                      'a3) -> ('a1 t -> 'a2 -> Coq_regex_as_UCT.t -> 'a1 ->
                      (Coq_regex_as_UCT.t * 'a1) list -> __ -> 'a3 -> 'a3) ->
                      'a1 t -> 'a2 -> 'a3

                    val fold_rec :
                      (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ ->
                      'a3) -> ('a1 t -> 'a2 -> Coq_regex_as_UCT.t -> 'a1 ->
                      (Coq_regex_as_UCT.t * 'a1) list -> __ -> 'a3 -> 'a3) ->
                      'a1 t -> 'a2 -> 'a3

                    val coq_R_fold_correct :
                      (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2 ->
                      ('a1, 'a2) coq_R_fold

                    val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool

                    type 'elt coq_R_equal =
                    | R_equal_0 of 'elt t * 'elt t
                    | R_equal_1 of 'elt t * 'elt t * Coq_regex_as_UCT.t
                       * 'elt * (Coq_regex_as_UCT.t * 'elt) list
                       * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list * bool
                       * 'elt coq_R_equal
                    | R_equal_2 of 'elt t * 'elt t * Coq_regex_as_UCT.t
                       * 'elt * (Coq_regex_as_UCT.t * 'elt) list
                       * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list
                       * Coq_regex_as_UCT.t compare0
                    | R_equal_3 of 'elt t * 'elt t * 'elt t * 'elt t

                    val coq_R_equal_rect :
                      ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                      'a2) -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                      (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> bool -> 'a1 coq_R_equal ->
                      'a2 -> 'a2) -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t ->
                      'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> Coq_regex_as_UCT.t compare0 -> __ -> __
                      -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t ->
                      __ -> __ -> 'a2) -> 'a1 t -> 'a1 t -> bool -> 'a1
                      coq_R_equal -> 'a2

                    val coq_R_equal_rec :
                      ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                      'a2) -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                      (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> bool -> 'a1 coq_R_equal ->
                      'a2 -> 'a2) -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t ->
                      'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> Coq_regex_as_UCT.t compare0 -> __ -> __
                      -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t ->
                      __ -> __ -> 'a2) -> 'a1 t -> 'a1 t -> bool -> 'a1
                      coq_R_equal -> 'a2

                    val equal_rect :
                      ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                      'a2) -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                      (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2 -> 'a2) -> ('a1 t -> 'a1
                      t -> Coq_regex_as_UCT.t -> 'a1 ->
                      (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> Coq_regex_as_UCT.t compare0 -> __ -> __
                      -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t ->
                      __ -> __ -> 'a2) -> 'a1 t -> 'a1 t -> 'a2

                    val equal_rec :
                      ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                      'a2) -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                      (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2 -> 'a2) -> ('a1 t -> 'a1
                      t -> Coq_regex_as_UCT.t -> 'a1 ->
                      (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> Coq_regex_as_UCT.t compare0 -> __ -> __
                      -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t ->
                      __ -> __ -> 'a2) -> 'a1 t -> 'a1 t -> 'a2

                    val coq_R_equal_correct :
                      ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool -> 'a1
                      coq_R_equal

                    val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

                    val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

                    val option_cons :
                      key -> 'a1 option -> (key * 'a1) list -> (key * 'a1)
                      list

                    val map2_l :
                      ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t ->
                      'a3 t

                    val map2_r :
                      ('a1 option -> 'a2 option -> 'a3 option) -> 'a2 t ->
                      'a3 t

                    val map2 :
                      ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t ->
                      'a2 t -> 'a3 t

                    val combine :
                      'a1 t -> 'a2 t -> ('a1 option * 'a2 option) t

                    val fold_right_pair :
                      ('a1 -> 'a2 -> 'a3 -> 'a3) -> ('a1 * 'a2) list -> 'a3
                      -> 'a3

                    val map2_alt :
                      ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t ->
                      'a2 t -> (key * 'a3) list

                    val at_least_one :
                      'a1 option -> 'a2 option -> ('a1 option * 'a2 option)
                      option

                    val at_least_one_then_f :
                      ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 option
                      -> 'a2 option -> 'a3 option
                   end

                  type 'elt coq_R_mem =
                  | R_mem_0 of 'elt tree
                  | R_mem_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                     * Z_as_Int.t * bool * 'elt coq_R_mem
                  | R_mem_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                     * Z_as_Int.t
                  | R_mem_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                     * Z_as_Int.t * bool * 'elt coq_R_mem

                  val coq_R_mem_rect :
                    Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2)
                    -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 tree
                    -> bool -> 'a1 coq_R_mem -> 'a2

                  val coq_R_mem_rec :
                    Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2)
                    -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 tree
                    -> bool -> 'a1 coq_R_mem -> 'a2

                  type 'elt coq_R_find =
                  | R_find_0 of 'elt tree
                  | R_find_1 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'elt option * 'elt coq_R_find
                  | R_find_2 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t
                  | R_find_3 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'elt option * 'elt coq_R_find

                  val coq_R_find_rect :
                    Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2
                    -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
                    tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree
                    -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                    -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 ->
                    'a2) -> 'a1 tree -> 'a1 option -> 'a1 coq_R_find -> 'a2

                  val coq_R_find_rec :
                    Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2
                    -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
                    tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree
                    -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                    -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 ->
                    'a2) -> 'a1 tree -> 'a1 option -> 'a1 coq_R_find -> 'a2

                  type 'elt coq_R_bal =
                  | R_bal_0 of 'elt tree * key * 'elt * 'elt tree
                  | R_bal_1 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                     * key * 'elt * 'elt tree * Z_as_Int.t
                  | R_bal_2 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                     * key * 'elt * 'elt tree * Z_as_Int.t
                  | R_bal_3 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                     * key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t
                  | R_bal_4 of 'elt tree * key * 'elt * 'elt tree
                  | R_bal_5 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                     * key * 'elt * 'elt tree * Z_as_Int.t
                  | R_bal_6 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                     * key * 'elt * 'elt tree * Z_as_Int.t
                  | R_bal_7 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                     * key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t
                  | R_bal_8 of 'elt tree * key * 'elt * 'elt tree

                  val coq_R_bal_rect :
                    ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ ->
                    'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
                    -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                    -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1
                    tree -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree
                    -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key
                    -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
                    -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 ->
                    'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key ->
                    'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2)
                    -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __
                    -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key ->
                    'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree ->
                    key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
                    'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
                    -> __ -> __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree
                    -> 'a1 tree -> 'a1 coq_R_bal -> 'a2

                  val coq_R_bal_rec :
                    ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ ->
                    'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
                    -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                    -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1
                    tree -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree
                    -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key
                    -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
                    -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 ->
                    'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key ->
                    'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2)
                    -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __
                    -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key ->
                    'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree ->
                    key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
                    'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
                    -> __ -> __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree
                    -> 'a1 tree -> 'a1 coq_R_bal -> 'a2

                  type 'elt coq_R_add =
                  | R_add_0 of 'elt tree
                  | R_add_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                     * Z_as_Int.t * 'elt tree * 'elt coq_R_add
                  | R_add_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                     * Z_as_Int.t
                  | R_add_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                     * Z_as_Int.t * 'elt tree * 'elt coq_R_add

                  val coq_R_add_rect :
                    key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key
                    -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
                    tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 tree -> 'a1
                    tree -> 'a1 coq_R_add -> 'a2

                  val coq_R_add_rec :
                    key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key
                    -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
                    tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 tree -> 'a1
                    tree -> 'a1 coq_R_add -> 'a2

                  type 'elt coq_R_remove_min =
                  | R_remove_min_0 of 'elt tree * key * 'elt * 'elt tree
                  | R_remove_min_1 of 'elt tree * key * 'elt * 'elt tree
                     * 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t
                     * ('elt tree * (key * 'elt)) * 'elt coq_R_remove_min
                     * 'elt tree * (key * 'elt)

                  val coq_R_remove_min_rect :
                    ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1
                    tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1
                    -> 'a1 tree -> Z_as_Int.t -> __ -> ('a1
                    tree * (key * 'a1)) -> 'a1 coq_R_remove_min -> 'a2 -> 'a1
                    tree -> (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> key ->
                    'a1 -> 'a1 tree -> ('a1 tree * (key * 'a1)) -> 'a1
                    coq_R_remove_min -> 'a2

                  val coq_R_remove_min_rec :
                    ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1
                    tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1
                    -> 'a1 tree -> Z_as_Int.t -> __ -> ('a1
                    tree * (key * 'a1)) -> 'a1 coq_R_remove_min -> 'a2 -> 'a1
                    tree -> (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> key ->
                    'a1 -> 'a1 tree -> ('a1 tree * (key * 'a1)) -> 'a1
                    coq_R_remove_min -> 'a2

                  type 'elt coq_R_merge =
                  | R_merge_0 of 'elt tree * 'elt tree
                  | R_merge_1 of 'elt tree * 'elt tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t
                  | R_merge_2 of 'elt tree * 'elt tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree
                     * (key * 'elt) * key * 'elt

                  val coq_R_merge_rect :
                    ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> (key * 'a1) -> __ -> key -> 'a1 -> __ -> 'a2) -> 'a1
                    tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_merge -> 'a2

                  val coq_R_merge_rec :
                    ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> (key * 'a1) -> __ -> key -> 'a1 -> __ -> 'a2) -> 'a1
                    tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_merge -> 'a2

                  type 'elt coq_R_remove =
                  | R_remove_0 of 'elt tree
                  | R_remove_1 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'elt tree * 'elt coq_R_remove
                  | R_remove_2 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t
                  | R_remove_3 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'elt tree * 'elt coq_R_remove

                  val coq_R_remove_rect :
                    Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2
                    -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
                    tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree
                    -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                    -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 ->
                    'a2) -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_remove -> 'a2

                  val coq_R_remove_rec :
                    Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2
                    -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
                    tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree
                    -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                    -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 ->
                    'a2) -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_remove -> 'a2

                  type 'elt coq_R_concat =
                  | R_concat_0 of 'elt tree * 'elt tree
                  | R_concat_1 of 'elt tree * 'elt tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t
                  | R_concat_2 of 'elt tree * 'elt tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree
                     * (key * 'elt)

                  val coq_R_concat_rect :
                    ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> 'a1 tree ->
                    'a1 tree -> 'a1 coq_R_concat -> 'a2

                  val coq_R_concat_rec :
                    ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> 'a1 tree ->
                    'a1 tree -> 'a1 coq_R_concat -> 'a2

                  type 'elt coq_R_split =
                  | R_split_0 of 'elt tree
                  | R_split_1 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'elt triple
                     * 'elt coq_R_split * 'elt tree * 'elt option * 'elt tree
                  | R_split_2 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t
                  | R_split_3 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'elt triple
                     * 'elt coq_R_split * 'elt tree * 'elt option * 'elt tree

                  val coq_R_split_rect :
                    Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2
                    -> 'a1 tree -> 'a1 option -> 'a1 tree -> __ -> 'a2) ->
                    ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree
                    -> 'a1 option -> 'a1 tree -> __ -> 'a2) -> 'a1 tree ->
                    'a1 triple -> 'a1 coq_R_split -> 'a2

                  val coq_R_split_rec :
                    Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2
                    -> 'a1 tree -> 'a1 option -> 'a1 tree -> __ -> 'a2) ->
                    ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree
                    -> 'a1 option -> 'a1 tree -> __ -> 'a2) -> 'a1 tree ->
                    'a1 triple -> 'a1 coq_R_split -> 'a2

                  type ('elt, 'x) coq_R_map_option =
                  | R_map_option_0 of 'elt tree
                  | R_map_option_1 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'x * 'x tree
                     * ('elt, 'x) coq_R_map_option * 'x tree
                     * ('elt, 'x) coq_R_map_option
                  | R_map_option_2 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'x tree
                     * ('elt, 'x) coq_R_map_option * 'x tree
                     * ('elt, 'x) coq_R_map_option

                  val coq_R_map_option_rect :
                    (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) ->
                    ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> 'a2 -> __ -> 'a2 tree -> ('a1, 'a2)
                    coq_R_map_option -> 'a3 -> 'a2 tree -> ('a1, 'a2)
                    coq_R_map_option -> 'a3 -> 'a3) -> ('a1 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                    'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2
                    tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> 'a1
                    tree -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3

                  val coq_R_map_option_rec :
                    (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) ->
                    ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> 'a2 -> __ -> 'a2 tree -> ('a1, 'a2)
                    coq_R_map_option -> 'a3 -> 'a2 tree -> ('a1, 'a2)
                    coq_R_map_option -> 'a3 -> 'a3) -> ('a1 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                    'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2
                    tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> 'a1
                    tree -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3

                  type ('elt, 'x0, 'x) coq_R_map2_opt =
                  | R_map2_opt_0 of 'elt tree * 'x0 tree
                  | R_map2_opt_1 of 'elt tree * 'x0 tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t
                  | R_map2_opt_2 of 'elt tree * 'x0 tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t * 'x0 tree * 
                     key * 'x0 * 'x0 tree * Z_as_Int.t * 'x0 tree
                     * 'x0 option * 'x0 tree * 'x * 'x tree
                     * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
                     * ('elt, 'x0, 'x) coq_R_map2_opt
                  | R_map2_opt_3 of 'elt tree * 'x0 tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t * 'x0 tree * 
                     key * 'x0 * 'x0 tree * Z_as_Int.t * 'x0 tree
                     * 'x0 option * 'x0 tree * 'x tree
                     * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
                     * ('elt, 'x0, 'x) coq_R_map2_opt

                  val coq_R_map2_opt_rect :
                    (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree ->
                    'a3 tree) -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2
                    tree -> __ -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                    'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1
                    -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 tree -> key -> 'a2
                    -> 'a2 tree -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2 option
                    -> 'a2 tree -> __ -> 'a3 -> __ -> 'a3 tree -> ('a1, 'a2,
                    'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
                    coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree ->
                    'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    'a2 tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ ->
                    'a2 tree -> 'a2 option -> 'a2 tree -> __ -> __ -> 'a3
                    tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree
                    -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1
                    tree -> 'a2 tree -> 'a3 tree -> ('a1, 'a2, 'a3)
                    coq_R_map2_opt -> 'a4

                  val coq_R_map2_opt_rec :
                    (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree ->
                    'a3 tree) -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2
                    tree -> __ -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                    'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1
                    -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 tree -> key -> 'a2
                    -> 'a2 tree -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2 option
                    -> 'a2 tree -> __ -> 'a3 -> __ -> 'a3 tree -> ('a1, 'a2,
                    'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
                    coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree ->
                    'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    'a2 tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ ->
                    'a2 tree -> 'a2 option -> 'a2 tree -> __ -> __ -> 'a3
                    tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree
                    -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1
                    tree -> 'a2 tree -> 'a3 tree -> ('a1, 'a2, 'a3)
                    coq_R_map2_opt -> 'a4

                  val fold' :
                    (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

                  val flatten_e : 'a1 enumeration -> (key * 'a1) list
                 end
               end

              type 'elt bst =
                'elt Raw.tree
                (* singleton inductive, whose constructor was Bst *)

              val this : 'a1 bst -> 'a1 Raw.tree

              type 'elt t = 'elt bst

              type key = Coq_regex_as_UCT.t

              val empty : 'a1 t

              val is_empty : 'a1 t -> bool

              val add : key -> 'a1 -> 'a1 t -> 'a1 t

              val remove : key -> 'a1 t -> 'a1 t

              val mem : key -> 'a1 t -> bool

              val find : key -> 'a1 t -> 'a1 option

              val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

              val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

              val map2 :
                ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t ->
                'a3 t

              val elements : 'a1 t -> (key * 'a1) list

              val cardinal : 'a1 t -> nat

              val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

              val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool
             end

            module Coq_reFMF :
             sig
              val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

              val coq_In_dec : 'a1 Coq_reFM.t -> Coq_reFM.key -> bool
             end

            module MatchSpec :
             sig
             end

            module MatchSpecLemmas :
             sig
             end

            module Notations :
             sig
             end

            module Helpers :
             sig
              val coq_Plus : Regexes.regex -> Regexes.regex

              val coq_IterUnion : Regexes.regex list -> Regexes.regex

              val coq_IterApp : Regexes.regex list -> Regexes.regex

              val coq_Optional : Regexes.regex -> Regexes.regex

              val coq_REString : Strings.coq_String -> Regexes.regex
             end
           end
         end

        module TabTy :
         sig
          module DS :
           sig
            module T_as_UCT :
             sig
              type t = R.Ty.coq_Sigma

              val compare : R.Ty.coq_Sigma -> R.Ty.coq_Sigma -> comparison
             end

            module T_as_UOT :
             sig
              type t = T_as_UCT.t

              val compare : t -> t -> t compare0

              val eq_dec : t -> t -> bool
             end

            module SigFS :
             sig
              module X' :
               sig
                type t = T_as_UCT.t

                val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                val compare : T_as_UCT.t -> T_as_UCT.t -> comparison
               end

              module MSet :
               sig
                module Raw :
                 sig
                  type elt = T_as_UCT.t

                  type tree = R.Defs.SigFS.MSet.Raw.tree =
                  | Leaf
                  | Node of Z_as_Int.t * tree * T_as_UCT.t * tree

                  val empty : tree

                  val is_empty : tree -> bool

                  val mem : T_as_UCT.t -> tree -> bool

                  val min_elt : tree -> elt option

                  val max_elt : tree -> elt option

                  val choose : tree -> elt option

                  val fold : (elt -> 'a1 -> 'a1) -> tree -> 'a1 -> 'a1

                  val elements_aux :
                    T_as_UCT.t list -> tree -> T_as_UCT.t list

                  val elements : tree -> T_as_UCT.t list

                  val rev_elements_aux :
                    T_as_UCT.t list -> tree -> T_as_UCT.t list

                  val rev_elements : tree -> T_as_UCT.t list

                  val cardinal : tree -> nat

                  val maxdepth : tree -> nat

                  val mindepth : tree -> nat

                  val for_all : (elt -> bool) -> tree -> bool

                  val exists_ : (elt -> bool) -> tree -> bool

                  type enumeration = R.Defs.SigFS.MSet.Raw.enumeration =
                  | End
                  | More of elt * tree * enumeration

                  val cons : tree -> enumeration -> enumeration

                  val compare_more :
                    T_as_UCT.t -> (enumeration -> comparison) -> enumeration
                    -> comparison

                  val compare_cont :
                    tree -> (enumeration -> comparison) -> enumeration ->
                    comparison

                  val compare_end : enumeration -> comparison

                  val compare : tree -> tree -> comparison

                  val equal : tree -> tree -> bool

                  val subsetl : (tree -> bool) -> T_as_UCT.t -> tree -> bool

                  val subsetr : (tree -> bool) -> T_as_UCT.t -> tree -> bool

                  val subset : tree -> tree -> bool

                  type t = tree

                  val height : t -> Z_as_Int.t

                  val singleton : T_as_UCT.t -> tree

                  val create : t -> T_as_UCT.t -> t -> tree

                  val assert_false : t -> T_as_UCT.t -> t -> tree

                  val bal : t -> T_as_UCT.t -> t -> tree

                  val add : T_as_UCT.t -> tree -> tree

                  val join : tree -> elt -> t -> t

                  val remove_min : tree -> elt -> t -> t * elt

                  val merge : tree -> tree -> tree

                  val remove : T_as_UCT.t -> tree -> tree

                  val concat : tree -> tree -> tree

                  type triple = R.Defs.SigFS.MSet.Raw.triple = { t_left : 
                                                                 t;
                                                                 t_in : 
                                                                 bool;
                                                                 t_right : 
                                                                 t }

                  val t_left : triple -> t

                  val t_in : triple -> bool

                  val t_right : triple -> t

                  val split : T_as_UCT.t -> tree -> triple

                  val inter : tree -> tree -> tree

                  val diff : tree -> tree -> tree

                  val union : tree -> tree -> tree

                  val filter : (elt -> bool) -> tree -> tree

                  val partition : (elt -> bool) -> t -> t * t

                  val ltb_tree : T_as_UCT.t -> tree -> bool

                  val gtb_tree : T_as_UCT.t -> tree -> bool

                  val isok : tree -> bool

                  module MX :
                   sig
                    module OrderTac :
                     sig
                      module OTF :
                       sig
                        type t = T_as_UCT.t

                        val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

                        val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
                       end

                      module TO :
                       sig
                        type t = T_as_UCT.t

                        val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

                        val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
                       end
                     end

                    val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                    val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                    val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
                   end

                  type coq_R_min_elt = R.Defs.SigFS.MSet.Raw.coq_R_min_elt =
                  | R_min_elt_0 of tree
                  | R_min_elt_1 of tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree
                  | R_min_elt_2 of tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree * Z_as_Int.t * tree * T_as_UCT.t * tree
                     * elt option * coq_R_min_elt

                  type coq_R_max_elt = R.Defs.SigFS.MSet.Raw.coq_R_max_elt =
                  | R_max_elt_0 of tree
                  | R_max_elt_1 of tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree
                  | R_max_elt_2 of tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree * Z_as_Int.t * tree * T_as_UCT.t * tree
                     * elt option * coq_R_max_elt

                  module L :
                   sig
                    module MO :
                     sig
                      module OrderTac :
                       sig
                        module OTF :
                         sig
                          type t = T_as_UCT.t

                          val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

                          val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
                         end

                        module TO :
                         sig
                          type t = T_as_UCT.t

                          val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

                          val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
                         end
                       end

                      val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                      val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                      val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
                     end
                   end

                  val flatten_e : enumeration -> elt list

                  type coq_R_bal = R.Defs.SigFS.MSet.Raw.coq_R_bal =
                  | R_bal_0 of t * T_as_UCT.t * t
                  | R_bal_1 of t * T_as_UCT.t * t * Z_as_Int.t * tree
                     * T_as_UCT.t * tree
                  | R_bal_2 of t * T_as_UCT.t * t * Z_as_Int.t * tree
                     * T_as_UCT.t * tree
                  | R_bal_3 of t * T_as_UCT.t * t * Z_as_Int.t * tree
                     * T_as_UCT.t * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree
                  | R_bal_4 of t * T_as_UCT.t * t
                  | R_bal_5 of t * T_as_UCT.t * t * Z_as_Int.t * tree
                     * T_as_UCT.t * tree
                  | R_bal_6 of t * T_as_UCT.t * t * Z_as_Int.t * tree
                     * T_as_UCT.t * tree
                  | R_bal_7 of t * T_as_UCT.t * t * Z_as_Int.t * tree
                     * T_as_UCT.t * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree
                  | R_bal_8 of t * T_as_UCT.t * t

                  type coq_R_remove_min = R.Defs.SigFS.MSet.Raw.coq_R_remove_min =
                  | R_remove_min_0 of tree * elt * t
                  | R_remove_min_1 of tree * elt * t * Z_as_Int.t * tree
                     * T_as_UCT.t * tree * (t * elt) * coq_R_remove_min * 
                     t * elt

                  type coq_R_merge = R.Defs.SigFS.MSet.Raw.coq_R_merge =
                  | R_merge_0 of tree * tree
                  | R_merge_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree
                  | R_merge_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree * Z_as_Int.t * tree * T_as_UCT.t * tree * 
                     t * elt

                  type coq_R_concat = R.Defs.SigFS.MSet.Raw.coq_R_concat =
                  | R_concat_0 of tree * tree
                  | R_concat_1 of tree * tree * Z_as_Int.t * tree
                     * T_as_UCT.t * tree
                  | R_concat_2 of tree * tree * Z_as_Int.t * tree
                     * T_as_UCT.t * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree * t * elt

                  type coq_R_inter = R.Defs.SigFS.MSet.Raw.coq_R_inter =
                  | R_inter_0 of tree * tree
                  | R_inter_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree
                  | R_inter_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree * Z_as_Int.t * tree * T_as_UCT.t * tree * 
                     t * bool * t * tree * coq_R_inter * tree * coq_R_inter
                  | R_inter_3 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree * Z_as_Int.t * tree * T_as_UCT.t * tree * 
                     t * bool * t * tree * coq_R_inter * tree * coq_R_inter

                  type coq_R_diff = R.Defs.SigFS.MSet.Raw.coq_R_diff =
                  | R_diff_0 of tree * tree
                  | R_diff_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree
                  | R_diff_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree * Z_as_Int.t * tree * T_as_UCT.t * tree * 
                     t * bool * t * tree * coq_R_diff * tree * coq_R_diff
                  | R_diff_3 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree * Z_as_Int.t * tree * T_as_UCT.t * tree * 
                     t * bool * t * tree * coq_R_diff * tree * coq_R_diff

                  type coq_R_union = R.Defs.SigFS.MSet.Raw.coq_R_union =
                  | R_union_0 of tree * tree
                  | R_union_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree
                  | R_union_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                     * tree * Z_as_Int.t * tree * T_as_UCT.t * tree * 
                     t * bool * t * tree * coq_R_union * tree * coq_R_union
                 end

                module E :
                 sig
                  type t = T_as_UCT.t

                  val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

                  val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
                 end

                type elt = T_as_UCT.t

                type t_ =
                  Raw.t
                  (* singleton inductive, whose constructor was Mkt *)

                val this : t_ -> Raw.t

                type t = t_

                val mem : elt -> t -> bool

                val add : elt -> t -> t

                val remove : elt -> t -> t

                val singleton : elt -> t

                val union : t -> t -> t

                val inter : t -> t -> t

                val diff : t -> t -> t

                val equal : t -> t -> bool

                val subset : t -> t -> bool

                val empty : t

                val is_empty : t -> bool

                val elements : t -> elt list

                val choose : t -> elt option

                val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

                val cardinal : t -> nat

                val filter : (elt -> bool) -> t -> t

                val for_all : (elt -> bool) -> t -> bool

                val exists_ : (elt -> bool) -> t -> bool

                val partition : (elt -> bool) -> t -> t * t

                val eq_dec : t -> t -> bool

                val compare : t -> t -> comparison

                val min_elt : t -> elt option

                val max_elt : t -> elt option
               end

              type elt = T_as_UCT.t

              type t = MSet.t

              val empty : t

              val is_empty : t -> bool

              val mem : elt -> t -> bool

              val add : elt -> t -> t

              val singleton : elt -> t

              val remove : elt -> t -> t

              val union : t -> t -> t

              val inter : t -> t -> t

              val diff : t -> t -> t

              val eq_dec : t -> t -> bool

              val equal : t -> t -> bool

              val subset : t -> t -> bool

              val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

              val for_all : (elt -> bool) -> t -> bool

              val exists_ : (elt -> bool) -> t -> bool

              val filter : (elt -> bool) -> t -> t

              val partition : (elt -> bool) -> t -> t * t

              val cardinal : t -> nat

              val elements : t -> elt list

              val choose : t -> elt option

              module MF :
               sig
                val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
               end

              val min_elt : t -> elt option

              val max_elt : t -> elt option

              val compare : t -> t -> t compare0

              module E :
               sig
                type t = T_as_UCT.t

                val compare : T_as_UCT.t -> T_as_UCT.t -> T_as_UCT.t compare0

                val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
               end
             end

            module SigFSF :
             sig
              val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
             end

            module SigFM :
             sig
              module E :
               sig
                type t = T_as_UCT.t

                val compare : T_as_UCT.t -> T_as_UCT.t -> T_as_UCT.t compare0

                val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
               end

              module Raw :
               sig
                type key = T_as_UCT.t

                type 'elt tree = 'elt R.Defs.SigFM.Raw.tree =
                | Leaf
                | Node of 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t

                val tree_rect :
                  'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
                  Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

                val tree_rec :
                  'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
                  Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

                val height : 'a1 tree -> Z_as_Int.t

                val cardinal : 'a1 tree -> nat

                val empty : 'a1 tree

                val is_empty : 'a1 tree -> bool

                val mem : T_as_UCT.t -> 'a1 tree -> bool

                val find : T_as_UCT.t -> 'a1 tree -> 'a1 option

                val create : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

                val assert_false :
                  'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

                val bal : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

                val add : key -> 'a1 -> 'a1 tree -> 'a1 tree

                val remove_min :
                  'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree * (key * 'a1)

                val merge : 'a1 tree -> 'a1 tree -> 'a1 tree

                val remove : T_as_UCT.t -> 'a1 tree -> 'a1 tree

                val join : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

                type 'elt triple = 'elt R.Defs.SigFM.Raw.triple = { t_left : 
                                                                    'elt tree;
                                                                    t_opt : 
                                                                    'elt
                                                                    option;
                                                                    t_right : 
                                                                    'elt tree }

                val t_left : 'a1 triple -> 'a1 tree

                val t_opt : 'a1 triple -> 'a1 option

                val t_right : 'a1 triple -> 'a1 tree

                val split : T_as_UCT.t -> 'a1 tree -> 'a1 triple

                val concat : 'a1 tree -> 'a1 tree -> 'a1 tree

                val elements_aux :
                  (key * 'a1) list -> 'a1 tree -> (key * 'a1) list

                val elements : 'a1 tree -> (key * 'a1) list

                val fold :
                  (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

                type 'elt enumeration = 'elt R.Defs.SigFM.Raw.enumeration =
                | End
                | More of key * 'elt * 'elt tree * 'elt enumeration

                val enumeration_rect :
                  'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 ->
                  'a2) -> 'a1 enumeration -> 'a2

                val enumeration_rec :
                  'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 ->
                  'a2) -> 'a1 enumeration -> 'a2

                val cons : 'a1 tree -> 'a1 enumeration -> 'a1 enumeration

                val equal_more :
                  ('a1 -> 'a1 -> bool) -> T_as_UCT.t -> 'a1 -> ('a1
                  enumeration -> bool) -> 'a1 enumeration -> bool

                val equal_cont :
                  ('a1 -> 'a1 -> bool) -> 'a1 tree -> ('a1 enumeration ->
                  bool) -> 'a1 enumeration -> bool

                val equal_end : 'a1 enumeration -> bool

                val equal :
                  ('a1 -> 'a1 -> bool) -> 'a1 tree -> 'a1 tree -> bool

                val map : ('a1 -> 'a2) -> 'a1 tree -> 'a2 tree

                val mapi : (key -> 'a1 -> 'a2) -> 'a1 tree -> 'a2 tree

                val map_option :
                  (key -> 'a1 -> 'a2 option) -> 'a1 tree -> 'a2 tree

                val map2_opt :
                  (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree ->
                  'a3 tree) -> ('a2 tree -> 'a3 tree) -> 'a1 tree -> 'a2 tree
                  -> 'a3 tree

                val map2 :
                  ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 tree -> 'a2
                  tree -> 'a3 tree

                module Proofs :
                 sig
                  module MX :
                   sig
                    module TO :
                     sig
                      type t = T_as_UCT.t
                     end

                    module IsTO :
                     sig
                     end

                    module OrderTac :
                     sig
                     end

                    val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                    val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                    val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
                   end

                  module PX :
                   sig
                    module MO :
                     sig
                      module TO :
                       sig
                        type t = T_as_UCT.t
                       end

                      module IsTO :
                       sig
                       end

                      module OrderTac :
                       sig
                       end

                      val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                      val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                      val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
                     end
                   end

                  module L :
                   sig
                    module MX :
                     sig
                      module TO :
                       sig
                        type t = T_as_UCT.t
                       end

                      module IsTO :
                       sig
                       end

                      module OrderTac :
                       sig
                       end

                      val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                      val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                      val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
                     end

                    module PX :
                     sig
                      module MO :
                       sig
                        module TO :
                         sig
                          type t = T_as_UCT.t
                         end

                        module IsTO :
                         sig
                         end

                        module OrderTac :
                         sig
                         end

                        val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                        val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                        val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
                       end
                     end

                    type key = T_as_UCT.t

                    type 'elt t = (T_as_UCT.t * 'elt) list

                    val empty : 'a1 t

                    val is_empty : 'a1 t -> bool

                    val mem : key -> 'a1 t -> bool

                    type 'elt coq_R_mem = 'elt R.Defs.SigFM.Raw.Proofs.L.coq_R_mem =
                    | R_mem_0 of 'elt t
                    | R_mem_1 of 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list
                    | R_mem_2 of 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list
                    | R_mem_3 of 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list * bool * 'elt coq_R_mem

                    val coq_R_mem_rect :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                      'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                      'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 ->
                      'a2) -> 'a1 t -> bool -> 'a1 coq_R_mem -> 'a2

                    val coq_R_mem_rec :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                      'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                      'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 ->
                      'a2) -> 'a1 t -> bool -> 'a1 coq_R_mem -> 'a2

                    val mem_rect :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                      'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                      'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val mem_rec :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                      'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                      'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val coq_R_mem_correct :
                      key -> 'a1 t -> bool -> 'a1 coq_R_mem

                    val find : key -> 'a1 t -> 'a1 option

                    type 'elt coq_R_find = 'elt R.Defs.SigFM.Raw.Proofs.L.coq_R_find =
                    | R_find_0 of 'elt t
                    | R_find_1 of 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list
                    | R_find_2 of 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list
                    | R_find_3 of 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list * 'elt option
                       * 'elt coq_R_find

                    val coq_R_find_rect :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                      'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                      'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find ->
                      'a2 -> 'a2) -> 'a1 t -> 'a1 option -> 'a1 coq_R_find ->
                      'a2

                    val coq_R_find_rec :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                      'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                      'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find ->
                      'a2 -> 'a2) -> 'a1 t -> 'a1 option -> 'a1 coq_R_find ->
                      'a2

                    val find_rect :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                      'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                      'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val find_rec :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                      'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                      'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val coq_R_find_correct :
                      key -> 'a1 t -> 'a1 option -> 'a1 coq_R_find

                    val add : key -> 'a1 -> 'a1 t -> 'a1 t

                    type 'elt coq_R_add = 'elt R.Defs.SigFM.Raw.Proofs.L.coq_R_add =
                    | R_add_0 of 'elt t
                    | R_add_1 of 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list
                    | R_add_2 of 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list
                    | R_add_3 of 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list * 'elt t * 'elt coq_R_add

                    val coq_R_add_rect :
                      key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
                      __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_add -> 'a2 ->
                      'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_add -> 'a2

                    val coq_R_add_rec :
                      key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
                      __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_add -> 'a2 ->
                      'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_add -> 'a2

                    val add_rect :
                      key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
                      __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val add_rec :
                      key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
                      __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val coq_R_add_correct :
                      key -> 'a1 -> 'a1 t -> 'a1 t -> 'a1 coq_R_add

                    val remove : key -> 'a1 t -> 'a1 t

                    type 'elt coq_R_remove = 'elt R.Defs.SigFM.Raw.Proofs.L.coq_R_remove =
                    | R_remove_0 of 'elt t
                    | R_remove_1 of 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list
                    | R_remove_2 of 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list
                    | R_remove_3 of 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list * 'elt t * 'elt coq_R_remove

                    val coq_R_remove_rect :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                      'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                      'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_remove -> 'a2
                      -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove -> 'a2

                    val coq_R_remove_rec :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                      'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                      'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_remove -> 'a2
                      -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove -> 'a2

                    val remove_rect :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                      'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                      'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val remove_rec :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                      'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                      'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) ->
                      ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                      -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val coq_R_remove_correct :
                      key -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove

                    val elements : 'a1 t -> 'a1 t

                    val fold :
                      (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

                    type ('elt, 'a) coq_R_fold = ('elt, 'a) R.Defs.SigFM.Raw.Proofs.L.coq_R_fold =
                    | R_fold_0 of 'elt t * 'a
                    | R_fold_1 of 'elt t * 'a * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list * 'a * ('elt, 'a) coq_R_fold

                    val coq_R_fold_rect :
                      (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ ->
                      'a3) -> ('a1 t -> 'a2 -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> 'a2 -> ('a1, 'a2)
                      coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a2 ->
                      ('a1, 'a2) coq_R_fold -> 'a3

                    val coq_R_fold_rec :
                      (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ ->
                      'a3) -> ('a1 t -> 'a2 -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> 'a2 -> ('a1, 'a2)
                      coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a2 ->
                      ('a1, 'a2) coq_R_fold -> 'a3

                    val fold_rect :
                      (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ ->
                      'a3) -> ('a1 t -> 'a2 -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> 'a3 -> 'a3) -> 'a1 t
                      -> 'a2 -> 'a3

                    val fold_rec :
                      (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ ->
                      'a3) -> ('a1 t -> 'a2 -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> 'a3 -> 'a3) -> 'a1 t
                      -> 'a2 -> 'a3

                    val coq_R_fold_correct :
                      (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2 ->
                      ('a1, 'a2) coq_R_fold

                    val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool

                    type 'elt coq_R_equal = 'elt R.Defs.SigFM.Raw.Proofs.L.coq_R_equal =
                    | R_equal_0 of 'elt t * 'elt t
                    | R_equal_1 of 'elt t * 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list * bool * 'elt coq_R_equal
                    | R_equal_2 of 'elt t * 'elt t * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list * T_as_UCT.t * 'elt
                       * (T_as_UCT.t * 'elt) list * T_as_UCT.t compare0
                    | R_equal_3 of 'elt t * 'elt t * 'elt t * 'elt t

                    val coq_R_equal_rect :
                      ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                      'a2) -> ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> bool ->
                      'a1 coq_R_equal -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t ->
                      T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
                      T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
                      T_as_UCT.t compare0 -> __ -> __ -> 'a2) -> ('a1 t ->
                      'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2) ->
                      'a1 t -> 'a1 t -> bool -> 'a1 coq_R_equal -> 'a2

                    val coq_R_equal_rec :
                      ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                      'a2) -> ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> bool ->
                      'a1 coq_R_equal -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t ->
                      T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
                      T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
                      T_as_UCT.t compare0 -> __ -> __ -> 'a2) -> ('a1 t ->
                      'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2) ->
                      'a1 t -> 'a1 t -> bool -> 'a1 coq_R_equal -> 'a2

                    val equal_rect :
                      ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                      'a2) -> ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
                      'a2) -> ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t compare0 ->
                      __ -> __ -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ ->
                      'a1 t -> __ -> __ -> 'a2) -> 'a1 t -> 'a1 t -> 'a2

                    val equal_rec :
                      ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                      'a2) -> ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
                      'a2) -> ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t -> 'a1 ->
                      (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t compare0 ->
                      __ -> __ -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ ->
                      'a1 t -> __ -> __ -> 'a2) -> 'a1 t -> 'a1 t -> 'a2

                    val coq_R_equal_correct :
                      ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool -> 'a1
                      coq_R_equal

                    val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

                    val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

                    val option_cons :
                      key -> 'a1 option -> (key * 'a1) list -> (key * 'a1)
                      list

                    val map2_l :
                      ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t ->
                      'a3 t

                    val map2_r :
                      ('a1 option -> 'a2 option -> 'a3 option) -> 'a2 t ->
                      'a3 t

                    val map2 :
                      ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t ->
                      'a2 t -> 'a3 t

                    val combine :
                      'a1 t -> 'a2 t -> ('a1 option * 'a2 option) t

                    val fold_right_pair :
                      ('a1 -> 'a2 -> 'a3 -> 'a3) -> ('a1 * 'a2) list -> 'a3
                      -> 'a3

                    val map2_alt :
                      ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t ->
                      'a2 t -> (key * 'a3) list

                    val at_least_one :
                      'a1 option -> 'a2 option -> ('a1 option * 'a2 option)
                      option

                    val at_least_one_then_f :
                      ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 option
                      -> 'a2 option -> 'a3 option
                   end

                  type 'elt coq_R_mem = 'elt R.Defs.SigFM.Raw.Proofs.coq_R_mem =
                  | R_mem_0 of 'elt tree
                  | R_mem_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                     * Z_as_Int.t * bool * 'elt coq_R_mem
                  | R_mem_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                     * Z_as_Int.t
                  | R_mem_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                     * Z_as_Int.t * bool * 'elt coq_R_mem

                  val coq_R_mem_rect :
                    T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key
                    -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
                    bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 tree -> bool
                    -> 'a1 coq_R_mem -> 'a2

                  val coq_R_mem_rec :
                    T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key
                    -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
                    bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 tree -> bool
                    -> 'a1 coq_R_mem -> 'a2

                  type 'elt coq_R_find = 'elt R.Defs.SigFM.Raw.Proofs.coq_R_find =
                  | R_find_0 of 'elt tree
                  | R_find_1 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'elt option * 'elt coq_R_find
                  | R_find_2 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t
                  | R_find_3 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'elt option * 'elt coq_R_find

                  val coq_R_find_rect :
                    T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) ->
                    ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) ->
                    'a1 tree -> 'a1 option -> 'a1 coq_R_find -> 'a2

                  val coq_R_find_rec :
                    T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) ->
                    ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) ->
                    'a1 tree -> 'a1 option -> 'a1 coq_R_find -> 'a2

                  type 'elt coq_R_bal = 'elt R.Defs.SigFM.Raw.Proofs.coq_R_bal =
                  | R_bal_0 of 'elt tree * key * 'elt * 'elt tree
                  | R_bal_1 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                     * key * 'elt * 'elt tree * Z_as_Int.t
                  | R_bal_2 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                     * key * 'elt * 'elt tree * Z_as_Int.t
                  | R_bal_3 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                     * key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t
                  | R_bal_4 of 'elt tree * key * 'elt * 'elt tree
                  | R_bal_5 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                     * key * 'elt * 'elt tree * Z_as_Int.t
                  | R_bal_6 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                     * key * 'elt * 'elt tree * Z_as_Int.t
                  | R_bal_7 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                     * key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t
                  | R_bal_8 of 'elt tree * key * 'elt * 'elt tree

                  val coq_R_bal_rect :
                    ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ ->
                    'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
                    -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                    -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1
                    tree -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree
                    -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key
                    -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
                    -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 ->
                    'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key ->
                    'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2)
                    -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __
                    -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key ->
                    'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree ->
                    key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
                    'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
                    -> __ -> __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree
                    -> 'a1 tree -> 'a1 coq_R_bal -> 'a2

                  val coq_R_bal_rec :
                    ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ ->
                    'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
                    -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                    -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1
                    tree -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree
                    -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key
                    -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
                    -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 ->
                    'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key ->
                    'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2)
                    -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __
                    -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key ->
                    'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree ->
                    key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
                    'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
                    -> __ -> __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree
                    -> 'a1 tree -> 'a1 coq_R_bal -> 'a2

                  type 'elt coq_R_add = 'elt R.Defs.SigFM.Raw.Proofs.coq_R_add =
                  | R_add_0 of 'elt tree
                  | R_add_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                     * Z_as_Int.t * 'elt tree * 'elt coq_R_add
                  | R_add_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                     * Z_as_Int.t
                  | R_add_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                     * Z_as_Int.t * 'elt tree * 'elt coq_R_add

                  val coq_R_add_rect :
                    key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key
                    -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
                    tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 tree -> 'a1
                    tree -> 'a1 coq_R_add -> 'a2

                  val coq_R_add_rec :
                    key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key
                    -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
                    tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 tree -> 'a1
                    tree -> 'a1 coq_R_add -> 'a2

                  type 'elt coq_R_remove_min = 'elt R.Defs.SigFM.Raw.Proofs.coq_R_remove_min =
                  | R_remove_min_0 of 'elt tree * key * 'elt * 'elt tree
                  | R_remove_min_1 of 'elt tree * key * 'elt * 'elt tree
                     * 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t
                     * ('elt tree * (key * 'elt)) * 'elt coq_R_remove_min
                     * 'elt tree * (key * 'elt)

                  val coq_R_remove_min_rect :
                    ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1
                    tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1
                    -> 'a1 tree -> Z_as_Int.t -> __ -> ('a1
                    tree * (key * 'a1)) -> 'a1 coq_R_remove_min -> 'a2 -> 'a1
                    tree -> (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> key ->
                    'a1 -> 'a1 tree -> ('a1 tree * (key * 'a1)) -> 'a1
                    coq_R_remove_min -> 'a2

                  val coq_R_remove_min_rec :
                    ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1
                    tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1
                    -> 'a1 tree -> Z_as_Int.t -> __ -> ('a1
                    tree * (key * 'a1)) -> 'a1 coq_R_remove_min -> 'a2 -> 'a1
                    tree -> (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> key ->
                    'a1 -> 'a1 tree -> ('a1 tree * (key * 'a1)) -> 'a1
                    coq_R_remove_min -> 'a2

                  type 'elt coq_R_merge = 'elt R.Defs.SigFM.Raw.Proofs.coq_R_merge =
                  | R_merge_0 of 'elt tree * 'elt tree
                  | R_merge_1 of 'elt tree * 'elt tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t
                  | R_merge_2 of 'elt tree * 'elt tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree
                     * (key * 'elt) * key * 'elt

                  val coq_R_merge_rect :
                    ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> (key * 'a1) -> __ -> key -> 'a1 -> __ -> 'a2) -> 'a1
                    tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_merge -> 'a2

                  val coq_R_merge_rec :
                    ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> (key * 'a1) -> __ -> key -> 'a1 -> __ -> 'a2) -> 'a1
                    tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_merge -> 'a2

                  type 'elt coq_R_remove = 'elt R.Defs.SigFM.Raw.Proofs.coq_R_remove =
                  | R_remove_0 of 'elt tree
                  | R_remove_1 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'elt tree * 'elt coq_R_remove
                  | R_remove_2 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t
                  | R_remove_3 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'elt tree * 'elt coq_R_remove

                  val coq_R_remove_rect :
                    T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) ->
                    ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) ->
                    'a1 tree -> 'a1 tree -> 'a1 coq_R_remove -> 'a2

                  val coq_R_remove_rec :
                    T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) ->
                    ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) ->
                    'a1 tree -> 'a1 tree -> 'a1 coq_R_remove -> 'a2

                  type 'elt coq_R_concat = 'elt R.Defs.SigFM.Raw.Proofs.coq_R_concat =
                  | R_concat_0 of 'elt tree * 'elt tree
                  | R_concat_1 of 'elt tree * 'elt tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t
                  | R_concat_2 of 'elt tree * 'elt tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree
                     * (key * 'elt)

                  val coq_R_concat_rect :
                    ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> 'a1 tree ->
                    'a1 tree -> 'a1 coq_R_concat -> 'a2

                  val coq_R_concat_rec :
                    ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> 'a1 tree ->
                    'a1 tree -> 'a1 coq_R_concat -> 'a2

                  type 'elt coq_R_split = 'elt R.Defs.SigFM.Raw.Proofs.coq_R_split =
                  | R_split_0 of 'elt tree
                  | R_split_1 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'elt triple
                     * 'elt coq_R_split * 'elt tree * 'elt option * 'elt tree
                  | R_split_2 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t
                  | R_split_3 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'elt triple
                     * 'elt coq_R_split * 'elt tree * 'elt option * 'elt tree

                  val coq_R_split_rect :
                    T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree
                    -> 'a1 option -> 'a1 tree -> __ -> 'a2) -> ('a1 tree ->
                    'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
                    -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 triple
                    -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option ->
                    'a1 tree -> __ -> 'a2) -> 'a1 tree -> 'a1 triple -> 'a1
                    coq_R_split -> 'a2

                  val coq_R_split_rec :
                    T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree
                    -> 'a1 option -> 'a1 tree -> __ -> 'a2) -> ('a1 tree ->
                    'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
                    -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 triple
                    -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option ->
                    'a1 tree -> __ -> 'a2) -> 'a1 tree -> 'a1 triple -> 'a1
                    coq_R_split -> 'a2

                  type ('elt, 'x) coq_R_map_option = ('elt, 'x) R.Defs.SigFM.Raw.Proofs.coq_R_map_option =
                  | R_map_option_0 of 'elt tree
                  | R_map_option_1 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'x * 'x tree
                     * ('elt, 'x) coq_R_map_option * 'x tree
                     * ('elt, 'x) coq_R_map_option
                  | R_map_option_2 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'x tree
                     * ('elt, 'x) coq_R_map_option * 'x tree
                     * ('elt, 'x) coq_R_map_option

                  val coq_R_map_option_rect :
                    (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) ->
                    ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> 'a2 -> __ -> 'a2 tree -> ('a1, 'a2)
                    coq_R_map_option -> 'a3 -> 'a2 tree -> ('a1, 'a2)
                    coq_R_map_option -> 'a3 -> 'a3) -> ('a1 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                    'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2
                    tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> 'a1
                    tree -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3

                  val coq_R_map_option_rec :
                    (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) ->
                    ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> 'a2 -> __ -> 'a2 tree -> ('a1, 'a2)
                    coq_R_map_option -> 'a3 -> 'a2 tree -> ('a1, 'a2)
                    coq_R_map_option -> 'a3 -> 'a3) -> ('a1 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                    'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2
                    tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> 'a1
                    tree -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3

                  type ('elt, 'x0, 'x) coq_R_map2_opt = ('elt, 'x0, 'x) R.Defs.SigFM.Raw.Proofs.coq_R_map2_opt =
                  | R_map2_opt_0 of 'elt tree * 'x0 tree
                  | R_map2_opt_1 of 'elt tree * 'x0 tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t
                  | R_map2_opt_2 of 'elt tree * 'x0 tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t * 'x0 tree * 
                     key * 'x0 * 'x0 tree * Z_as_Int.t * 'x0 tree
                     * 'x0 option * 'x0 tree * 'x * 'x tree
                     * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
                     * ('elt, 'x0, 'x) coq_R_map2_opt
                  | R_map2_opt_3 of 'elt tree * 'x0 tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t * 'x0 tree * 
                     key * 'x0 * 'x0 tree * Z_as_Int.t * 'x0 tree
                     * 'x0 option * 'x0 tree * 'x tree
                     * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
                     * ('elt, 'x0, 'x) coq_R_map2_opt

                  val coq_R_map2_opt_rect :
                    (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree ->
                    'a3 tree) -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2
                    tree -> __ -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                    'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1
                    -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 tree -> key -> 'a2
                    -> 'a2 tree -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2 option
                    -> 'a2 tree -> __ -> 'a3 -> __ -> 'a3 tree -> ('a1, 'a2,
                    'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
                    coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree ->
                    'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    'a2 tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ ->
                    'a2 tree -> 'a2 option -> 'a2 tree -> __ -> __ -> 'a3
                    tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree
                    -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1
                    tree -> 'a2 tree -> 'a3 tree -> ('a1, 'a2, 'a3)
                    coq_R_map2_opt -> 'a4

                  val coq_R_map2_opt_rec :
                    (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree ->
                    'a3 tree) -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2
                    tree -> __ -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                    'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1
                    -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 tree -> key -> 'a2
                    -> 'a2 tree -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2 option
                    -> 'a2 tree -> __ -> 'a3 -> __ -> 'a3 tree -> ('a1, 'a2,
                    'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
                    coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree ->
                    'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    'a2 tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ ->
                    'a2 tree -> 'a2 option -> 'a2 tree -> __ -> __ -> 'a3
                    tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree
                    -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1
                    tree -> 'a2 tree -> 'a3 tree -> ('a1, 'a2, 'a3)
                    coq_R_map2_opt -> 'a4

                  val fold' :
                    (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

                  val flatten_e : 'a1 enumeration -> (key * 'a1) list
                 end
               end

              type 'elt bst =
                'elt Raw.tree
                (* singleton inductive, whose constructor was Bst *)

              val this : 'a1 bst -> 'a1 Raw.tree

              type 'elt t = 'elt bst

              type key = T_as_UCT.t

              val empty : 'a1 t

              val is_empty : 'a1 t -> bool

              val add : key -> 'a1 -> 'a1 t -> 'a1 t

              val remove : key -> 'a1 t -> 'a1 t

              val mem : key -> 'a1 t -> bool

              val find : key -> 'a1 t -> 'a1 option

              val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

              val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

              val map2 :
                ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t ->
                'a3 t

              val elements : 'a1 t -> (key * 'a1) list

              val cardinal : 'a1 t -> nat

              val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

              val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool
             end

            module SigFMF :
             sig
              val eqb : T_as_UCT.t -> T_as_UCT.t -> bool

              val coq_In_dec : 'a1 SigFM.t -> SigFM.key -> bool
             end

            module Strings :
             sig
              type coq_String = R.Ty.coq_Sigma list

              val coq_String_dec : coq_String -> coq_String -> bool

              val rm_empty : coq_String list -> R.Ty.coq_Sigma list list
             end

            module Regexes :
             sig
              type regex = R.Defs.Regexes.regex =
              | EmptySet
              | EmptyStr
              | Char of R.Ty.coq_Sigma
              | App of regex * regex
              | Union of regex * regex
              | Star of regex

              val regex_rect :
                'a1 -> 'a1 -> (R.Ty.coq_Sigma -> 'a1) -> (regex -> 'a1 ->
                regex -> 'a1 -> 'a1) -> (regex -> 'a1 -> regex -> 'a1 -> 'a1)
                -> (regex -> 'a1 -> 'a1) -> regex -> 'a1

              val regex_rec :
                'a1 -> 'a1 -> (R.Ty.coq_Sigma -> 'a1) -> (regex -> 'a1 ->
                regex -> 'a1 -> 'a1) -> (regex -> 'a1 -> regex -> 'a1 -> 'a1)
                -> (regex -> 'a1 -> 'a1) -> regex -> 'a1

              val regex_dec : regex -> regex -> bool

              val regex_eq : regex -> regex -> bool

              val nullable' : regex -> bool

              val nullable : regex -> bool

              val derivative : R.Ty.coq_Sigma -> regex -> regex

              val derivative_list : R.Ty.coq_Sigma list -> regex -> regex

              val re_compare : regex -> regex -> comparison
             end

            module Coq_regex_as_UCT :
             sig
              type t = Regexes.regex

              val compare : Regexes.regex -> Regexes.regex -> comparison
             end

            module Coq_regex_as_UOT :
             sig
              type t = Coq_regex_as_UCT.t

              val compare : t -> t -> t compare0

              val eq_dec : t -> t -> bool
             end

            module Coq_reFS :
             sig
              module X' :
               sig
                type t = Coq_regex_as_UCT.t

                val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                val compare :
                  Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> comparison
               end

              module MSet :
               sig
                module Raw :
                 sig
                  type elt = Coq_regex_as_UCT.t

                  type tree = R.Defs.Coq_reFS.MSet.Raw.tree =
                  | Leaf
                  | Node of Z_as_Int.t * tree * Coq_regex_as_UCT.t * tree

                  val empty : tree

                  val is_empty : tree -> bool

                  val mem : Coq_regex_as_UCT.t -> tree -> bool

                  val min_elt : tree -> elt option

                  val max_elt : tree -> elt option

                  val choose : tree -> elt option

                  val fold : (elt -> 'a1 -> 'a1) -> tree -> 'a1 -> 'a1

                  val elements_aux :
                    Coq_regex_as_UCT.t list -> tree -> Coq_regex_as_UCT.t list

                  val elements : tree -> Coq_regex_as_UCT.t list

                  val rev_elements_aux :
                    Coq_regex_as_UCT.t list -> tree -> Coq_regex_as_UCT.t list

                  val rev_elements : tree -> Coq_regex_as_UCT.t list

                  val cardinal : tree -> nat

                  val maxdepth : tree -> nat

                  val mindepth : tree -> nat

                  val for_all : (elt -> bool) -> tree -> bool

                  val exists_ : (elt -> bool) -> tree -> bool

                  type enumeration = R.Defs.Coq_reFS.MSet.Raw.enumeration =
                  | End
                  | More of elt * tree * enumeration

                  val cons : tree -> enumeration -> enumeration

                  val compare_more :
                    Coq_regex_as_UCT.t -> (enumeration -> comparison) ->
                    enumeration -> comparison

                  val compare_cont :
                    tree -> (enumeration -> comparison) -> enumeration ->
                    comparison

                  val compare_end : enumeration -> comparison

                  val compare : tree -> tree -> comparison

                  val equal : tree -> tree -> bool

                  val subsetl :
                    (tree -> bool) -> Coq_regex_as_UCT.t -> tree -> bool

                  val subsetr :
                    (tree -> bool) -> Coq_regex_as_UCT.t -> tree -> bool

                  val subset : tree -> tree -> bool

                  type t = tree

                  val height : t -> Z_as_Int.t

                  val singleton : Coq_regex_as_UCT.t -> tree

                  val create : t -> Coq_regex_as_UCT.t -> t -> tree

                  val assert_false : t -> Coq_regex_as_UCT.t -> t -> tree

                  val bal : t -> Coq_regex_as_UCT.t -> t -> tree

                  val add : Coq_regex_as_UCT.t -> tree -> tree

                  val join : tree -> elt -> t -> t

                  val remove_min : tree -> elt -> t -> t * elt

                  val merge : tree -> tree -> tree

                  val remove : Coq_regex_as_UCT.t -> tree -> tree

                  val concat : tree -> tree -> tree

                  type triple = R.Defs.Coq_reFS.MSet.Raw.triple = { t_left : 
                                                                    t;
                                                                    t_in : 
                                                                    bool;
                                                                    t_right : 
                                                                    t }

                  val t_left : triple -> t

                  val t_in : triple -> bool

                  val t_right : triple -> t

                  val split : Coq_regex_as_UCT.t -> tree -> triple

                  val inter : tree -> tree -> tree

                  val diff : tree -> tree -> tree

                  val union : tree -> tree -> tree

                  val filter : (elt -> bool) -> tree -> tree

                  val partition : (elt -> bool) -> t -> t * t

                  val ltb_tree : Coq_regex_as_UCT.t -> tree -> bool

                  val gtb_tree : Coq_regex_as_UCT.t -> tree -> bool

                  val isok : tree -> bool

                  module MX :
                   sig
                    module OrderTac :
                     sig
                      module OTF :
                       sig
                        type t = Coq_regex_as_UCT.t

                        val compare :
                          Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t ->
                          comparison

                        val eq_dec :
                          Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                       end

                      module TO :
                       sig
                        type t = Coq_regex_as_UCT.t

                        val compare :
                          Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t ->
                          comparison

                        val eq_dec :
                          Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                       end
                     end

                    val eq_dec :
                      Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                    val lt_dec :
                      Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                    val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                   end

                  type coq_R_min_elt = R.Defs.Coq_reFS.MSet.Raw.coq_R_min_elt =
                  | R_min_elt_0 of tree
                  | R_min_elt_1 of tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree
                  | R_min_elt_2 of tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * elt option * coq_R_min_elt

                  type coq_R_max_elt = R.Defs.Coq_reFS.MSet.Raw.coq_R_max_elt =
                  | R_max_elt_0 of tree
                  | R_max_elt_1 of tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree
                  | R_max_elt_2 of tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * elt option * coq_R_max_elt

                  module L :
                   sig
                    module MO :
                     sig
                      module OrderTac :
                       sig
                        module OTF :
                         sig
                          type t = Coq_regex_as_UCT.t

                          val compare :
                            Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t ->
                            comparison

                          val eq_dec :
                            Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                         end

                        module TO :
                         sig
                          type t = Coq_regex_as_UCT.t

                          val compare :
                            Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t ->
                            comparison

                          val eq_dec :
                            Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                         end
                       end

                      val eq_dec :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                      val lt_dec :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                      val eqb :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                     end
                   end

                  val flatten_e : enumeration -> elt list

                  type coq_R_bal = R.Defs.Coq_reFS.MSet.Raw.coq_R_bal =
                  | R_bal_0 of t * Coq_regex_as_UCT.t * t
                  | R_bal_1 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * 
                     tree * Coq_regex_as_UCT.t * tree
                  | R_bal_2 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * 
                     tree * Coq_regex_as_UCT.t * tree
                  | R_bal_3 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * 
                     tree * Coq_regex_as_UCT.t * tree * Z_as_Int.t * 
                     tree * Coq_regex_as_UCT.t * tree
                  | R_bal_4 of t * Coq_regex_as_UCT.t * t
                  | R_bal_5 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * 
                     tree * Coq_regex_as_UCT.t * tree
                  | R_bal_6 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * 
                     tree * Coq_regex_as_UCT.t * tree
                  | R_bal_7 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * 
                     tree * Coq_regex_as_UCT.t * tree * Z_as_Int.t * 
                     tree * Coq_regex_as_UCT.t * tree
                  | R_bal_8 of t * Coq_regex_as_UCT.t * t

                  type coq_R_remove_min = R.Defs.Coq_reFS.MSet.Raw.coq_R_remove_min =
                  | R_remove_min_0 of tree * elt * t
                  | R_remove_min_1 of tree * elt * t * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * (t * elt)
                     * coq_R_remove_min * t * elt

                  type coq_R_merge = R.Defs.Coq_reFS.MSet.Raw.coq_R_merge =
                  | R_merge_0 of tree * tree
                  | R_merge_1 of tree * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree
                  | R_merge_2 of tree * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * t * elt

                  type coq_R_concat = R.Defs.Coq_reFS.MSet.Raw.coq_R_concat =
                  | R_concat_0 of tree * tree
                  | R_concat_1 of tree * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree
                  | R_concat_2 of tree * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * t * elt

                  type coq_R_inter = R.Defs.Coq_reFS.MSet.Raw.coq_R_inter =
                  | R_inter_0 of tree * tree
                  | R_inter_1 of tree * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree
                  | R_inter_2 of tree * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * t * bool * t * tree
                     * coq_R_inter * tree * coq_R_inter
                  | R_inter_3 of tree * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * t * bool * t * tree
                     * coq_R_inter * tree * coq_R_inter

                  type coq_R_diff = R.Defs.Coq_reFS.MSet.Raw.coq_R_diff =
                  | R_diff_0 of tree * tree
                  | R_diff_1 of tree * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree
                  | R_diff_2 of tree * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * t * bool * t * tree
                     * coq_R_diff * tree * coq_R_diff
                  | R_diff_3 of tree * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * t * bool * t * tree
                     * coq_R_diff * tree * coq_R_diff

                  type coq_R_union = R.Defs.Coq_reFS.MSet.Raw.coq_R_union =
                  | R_union_0 of tree * tree
                  | R_union_1 of tree * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree
                  | R_union_2 of tree * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                     * Coq_regex_as_UCT.t * tree * t * bool * t * tree
                     * coq_R_union * tree * coq_R_union
                 end

                module E :
                 sig
                  type t = Coq_regex_as_UCT.t

                  val compare :
                    Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> comparison

                  val eq_dec :
                    Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                 end

                type elt = Coq_regex_as_UCT.t

                type t_ =
                  Raw.t
                  (* singleton inductive, whose constructor was Mkt *)

                val this : t_ -> Raw.t

                type t = t_

                val mem : elt -> t -> bool

                val add : elt -> t -> t

                val remove : elt -> t -> t

                val singleton : elt -> t

                val union : t -> t -> t

                val inter : t -> t -> t

                val diff : t -> t -> t

                val equal : t -> t -> bool

                val subset : t -> t -> bool

                val empty : t

                val is_empty : t -> bool

                val elements : t -> elt list

                val choose : t -> elt option

                val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

                val cardinal : t -> nat

                val filter : (elt -> bool) -> t -> t

                val for_all : (elt -> bool) -> t -> bool

                val exists_ : (elt -> bool) -> t -> bool

                val partition : (elt -> bool) -> t -> t * t

                val eq_dec : t -> t -> bool

                val compare : t -> t -> comparison

                val min_elt : t -> elt option

                val max_elt : t -> elt option
               end

              type elt = Coq_regex_as_UCT.t

              type t = MSet.t

              val empty : t

              val is_empty : t -> bool

              val mem : elt -> t -> bool

              val add : elt -> t -> t

              val singleton : elt -> t

              val remove : elt -> t -> t

              val union : t -> t -> t

              val inter : t -> t -> t

              val diff : t -> t -> t

              val eq_dec : t -> t -> bool

              val equal : t -> t -> bool

              val subset : t -> t -> bool

              val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

              val for_all : (elt -> bool) -> t -> bool

              val exists_ : (elt -> bool) -> t -> bool

              val filter : (elt -> bool) -> t -> t

              val partition : (elt -> bool) -> t -> t * t

              val cardinal : t -> nat

              val elements : t -> elt list

              val choose : t -> elt option

              module MF :
               sig
                val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
               end

              val min_elt : t -> elt option

              val max_elt : t -> elt option

              val compare : t -> t -> t compare0

              module E :
               sig
                type t = Coq_regex_as_UCT.t

                val compare :
                  Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t ->
                  Coq_regex_as_UCT.t compare0

                val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
               end
             end

            module Coq_reFSF :
             sig
              val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
             end

            module Coq_reFM :
             sig
              module E :
               sig
                type t = Coq_regex_as_UCT.t

                val compare :
                  Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t ->
                  Coq_regex_as_UCT.t compare0

                val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
               end

              module Raw :
               sig
                type key = Coq_regex_as_UCT.t

                type 'elt tree = 'elt R.Defs.Coq_reFM.Raw.tree =
                | Leaf
                | Node of 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t

                val tree_rect :
                  'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
                  Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

                val tree_rec :
                  'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
                  Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

                val height : 'a1 tree -> Z_as_Int.t

                val cardinal : 'a1 tree -> nat

                val empty : 'a1 tree

                val is_empty : 'a1 tree -> bool

                val mem : Coq_regex_as_UCT.t -> 'a1 tree -> bool

                val find : Coq_regex_as_UCT.t -> 'a1 tree -> 'a1 option

                val create : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

                val assert_false :
                  'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

                val bal : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

                val add : key -> 'a1 -> 'a1 tree -> 'a1 tree

                val remove_min :
                  'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree * (key * 'a1)

                val merge : 'a1 tree -> 'a1 tree -> 'a1 tree

                val remove : Coq_regex_as_UCT.t -> 'a1 tree -> 'a1 tree

                val join : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

                type 'elt triple = 'elt R.Defs.Coq_reFM.Raw.triple = { 
                t_left : 'elt tree; t_opt : 'elt option; t_right : 'elt tree }

                val t_left : 'a1 triple -> 'a1 tree

                val t_opt : 'a1 triple -> 'a1 option

                val t_right : 'a1 triple -> 'a1 tree

                val split : Coq_regex_as_UCT.t -> 'a1 tree -> 'a1 triple

                val concat : 'a1 tree -> 'a1 tree -> 'a1 tree

                val elements_aux :
                  (key * 'a1) list -> 'a1 tree -> (key * 'a1) list

                val elements : 'a1 tree -> (key * 'a1) list

                val fold :
                  (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

                type 'elt enumeration = 'elt R.Defs.Coq_reFM.Raw.enumeration =
                | End
                | More of key * 'elt * 'elt tree * 'elt enumeration

                val enumeration_rect :
                  'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 ->
                  'a2) -> 'a1 enumeration -> 'a2

                val enumeration_rec :
                  'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 ->
                  'a2) -> 'a1 enumeration -> 'a2

                val cons : 'a1 tree -> 'a1 enumeration -> 'a1 enumeration

                val equal_more :
                  ('a1 -> 'a1 -> bool) -> Coq_regex_as_UCT.t -> 'a1 -> ('a1
                  enumeration -> bool) -> 'a1 enumeration -> bool

                val equal_cont :
                  ('a1 -> 'a1 -> bool) -> 'a1 tree -> ('a1 enumeration ->
                  bool) -> 'a1 enumeration -> bool

                val equal_end : 'a1 enumeration -> bool

                val equal :
                  ('a1 -> 'a1 -> bool) -> 'a1 tree -> 'a1 tree -> bool

                val map : ('a1 -> 'a2) -> 'a1 tree -> 'a2 tree

                val mapi : (key -> 'a1 -> 'a2) -> 'a1 tree -> 'a2 tree

                val map_option :
                  (key -> 'a1 -> 'a2 option) -> 'a1 tree -> 'a2 tree

                val map2_opt :
                  (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree ->
                  'a3 tree) -> ('a2 tree -> 'a3 tree) -> 'a1 tree -> 'a2 tree
                  -> 'a3 tree

                val map2 :
                  ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 tree -> 'a2
                  tree -> 'a3 tree

                module Proofs :
                 sig
                  module MX :
                   sig
                    module TO :
                     sig
                      type t = Coq_regex_as_UCT.t
                     end

                    module IsTO :
                     sig
                     end

                    module OrderTac :
                     sig
                     end

                    val eq_dec :
                      Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                    val lt_dec :
                      Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                    val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                   end

                  module PX :
                   sig
                    module MO :
                     sig
                      module TO :
                       sig
                        type t = Coq_regex_as_UCT.t
                       end

                      module IsTO :
                       sig
                       end

                      module OrderTac :
                       sig
                       end

                      val eq_dec :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                      val lt_dec :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                      val eqb :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                     end
                   end

                  module L :
                   sig
                    module MX :
                     sig
                      module TO :
                       sig
                        type t = Coq_regex_as_UCT.t
                       end

                      module IsTO :
                       sig
                       end

                      module OrderTac :
                       sig
                       end

                      val eq_dec :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                      val lt_dec :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                      val eqb :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                     end

                    module PX :
                     sig
                      module MO :
                       sig
                        module TO :
                         sig
                          type t = Coq_regex_as_UCT.t
                         end

                        module IsTO :
                         sig
                         end

                        module OrderTac :
                         sig
                         end

                        val eq_dec :
                          Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                        val lt_dec :
                          Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                        val eqb :
                          Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                       end
                     end

                    type key = Coq_regex_as_UCT.t

                    type 'elt t = (Coq_regex_as_UCT.t * 'elt) list

                    val empty : 'a1 t

                    val is_empty : 'a1 t -> bool

                    val mem : key -> 'a1 t -> bool

                    type 'elt coq_R_mem = 'elt R.Defs.Coq_reFM.Raw.Proofs.L.coq_R_mem =
                    | R_mem_0 of 'elt t
                    | R_mem_1 of 'elt t * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list
                    | R_mem_2 of 'elt t * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list
                    | R_mem_3 of 'elt t * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list * bool
                       * 'elt coq_R_mem

                    val coq_R_mem_rect :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2
                      -> 'a2) -> 'a1 t -> bool -> 'a1 coq_R_mem -> 'a2

                    val coq_R_mem_rec :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2
                      -> 'a2) -> 'a1 t -> bool -> 'a1 coq_R_mem -> 'a2

                    val mem_rect :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val mem_rec :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val coq_R_mem_correct :
                      key -> 'a1 t -> bool -> 'a1 coq_R_mem

                    val find : key -> 'a1 t -> 'a1 option

                    type 'elt coq_R_find = 'elt R.Defs.Coq_reFM.Raw.Proofs.L.coq_R_find =
                    | R_find_0 of 'elt t
                    | R_find_1 of 'elt t * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list
                    | R_find_2 of 'elt t * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list
                    | R_find_3 of 'elt t * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list * 'elt option
                       * 'elt coq_R_find

                    val coq_R_find_rect :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find
                      -> 'a2 -> 'a2) -> 'a1 t -> 'a1 option -> 'a1 coq_R_find
                      -> 'a2

                    val coq_R_find_rec :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find
                      -> 'a2 -> 'a2) -> 'a1 t -> 'a1 option -> 'a1 coq_R_find
                      -> 'a2

                    val find_rect :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val find_rec :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val coq_R_find_correct :
                      key -> 'a1 t -> 'a1 option -> 'a1 coq_R_find

                    val add : key -> 'a1 -> 'a1 t -> 'a1 t

                    type 'elt coq_R_add = 'elt R.Defs.Coq_reFM.Raw.Proofs.L.coq_R_add =
                    | R_add_0 of 'elt t
                    | R_add_1 of 'elt t * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list
                    | R_add_2 of 'elt t * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list
                    | R_add_3 of 'elt t * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list * 'elt t
                       * 'elt coq_R_add

                    val coq_R_add_rect :
                      key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_add -> 'a2
                      -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_add -> 'a2

                    val coq_R_add_rec :
                      key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_add -> 'a2
                      -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_add -> 'a2

                    val add_rect :
                      key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val add_rec :
                      key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val coq_R_add_correct :
                      key -> 'a1 -> 'a1 t -> 'a1 t -> 'a1 coq_R_add

                    val remove : key -> 'a1 t -> 'a1 t

                    type 'elt coq_R_remove = 'elt R.Defs.Coq_reFM.Raw.Proofs.L.coq_R_remove =
                    | R_remove_0 of 'elt t
                    | R_remove_1 of 'elt t * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list
                    | R_remove_2 of 'elt t * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list
                    | R_remove_3 of 'elt t * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list * 'elt t
                       * 'elt coq_R_remove

                    val coq_R_remove_rect :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_remove ->
                      'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove -> 'a2

                    val coq_R_remove_rec :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_remove ->
                      'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove -> 'a2

                    val remove_rect :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val remove_rec :
                      key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                    val coq_R_remove_correct :
                      key -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove

                    val elements : 'a1 t -> 'a1 t

                    val fold :
                      (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

                    type ('elt, 'a) coq_R_fold = ('elt, 'a) R.Defs.Coq_reFM.Raw.Proofs.L.coq_R_fold =
                    | R_fold_0 of 'elt t * 'a
                    | R_fold_1 of 'elt t * 'a * Coq_regex_as_UCT.t * 
                       'elt * (Coq_regex_as_UCT.t * 'elt) list * 'a
                       * ('elt, 'a) coq_R_fold

                    val coq_R_fold_rect :
                      (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ ->
                      'a3) -> ('a1 t -> 'a2 -> Coq_regex_as_UCT.t -> 'a1 ->
                      (Coq_regex_as_UCT.t * 'a1) list -> __ -> 'a2 -> ('a1,
                      'a2) coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a2
                      -> ('a1, 'a2) coq_R_fold -> 'a3

                    val coq_R_fold_rec :
                      (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ ->
                      'a3) -> ('a1 t -> 'a2 -> Coq_regex_as_UCT.t -> 'a1 ->
                      (Coq_regex_as_UCT.t * 'a1) list -> __ -> 'a2 -> ('a1,
                      'a2) coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a2
                      -> ('a1, 'a2) coq_R_fold -> 'a3

                    val fold_rect :
                      (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ ->
                      'a3) -> ('a1 t -> 'a2 -> Coq_regex_as_UCT.t -> 'a1 ->
                      (Coq_regex_as_UCT.t * 'a1) list -> __ -> 'a3 -> 'a3) ->
                      'a1 t -> 'a2 -> 'a3

                    val fold_rec :
                      (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ ->
                      'a3) -> ('a1 t -> 'a2 -> Coq_regex_as_UCT.t -> 'a1 ->
                      (Coq_regex_as_UCT.t * 'a1) list -> __ -> 'a3 -> 'a3) ->
                      'a1 t -> 'a2 -> 'a3

                    val coq_R_fold_correct :
                      (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2 ->
                      ('a1, 'a2) coq_R_fold

                    val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool

                    type 'elt coq_R_equal = 'elt R.Defs.Coq_reFM.Raw.Proofs.L.coq_R_equal =
                    | R_equal_0 of 'elt t * 'elt t
                    | R_equal_1 of 'elt t * 'elt t * Coq_regex_as_UCT.t
                       * 'elt * (Coq_regex_as_UCT.t * 'elt) list
                       * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list * bool
                       * 'elt coq_R_equal
                    | R_equal_2 of 'elt t * 'elt t * Coq_regex_as_UCT.t
                       * 'elt * (Coq_regex_as_UCT.t * 'elt) list
                       * Coq_regex_as_UCT.t * 'elt
                       * (Coq_regex_as_UCT.t * 'elt) list
                       * Coq_regex_as_UCT.t compare0
                    | R_equal_3 of 'elt t * 'elt t * 'elt t * 'elt t

                    val coq_R_equal_rect :
                      ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                      'a2) -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                      (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> bool -> 'a1 coq_R_equal ->
                      'a2 -> 'a2) -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t ->
                      'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> Coq_regex_as_UCT.t compare0 -> __ -> __
                      -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t ->
                      __ -> __ -> 'a2) -> 'a1 t -> 'a1 t -> bool -> 'a1
                      coq_R_equal -> 'a2

                    val coq_R_equal_rec :
                      ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                      'a2) -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                      (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> bool -> 'a1 coq_R_equal ->
                      'a2 -> 'a2) -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t ->
                      'a1 -> (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> Coq_regex_as_UCT.t compare0 -> __ -> __
                      -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t ->
                      __ -> __ -> 'a2) -> 'a1 t -> 'a1 t -> bool -> 'a1
                      coq_R_equal -> 'a2

                    val equal_rect :
                      ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                      'a2) -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                      (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2 -> 'a2) -> ('a1 t -> 'a1
                      t -> Coq_regex_as_UCT.t -> 'a1 ->
                      (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> Coq_regex_as_UCT.t compare0 -> __ -> __
                      -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t ->
                      __ -> __ -> 'a2) -> 'a1 t -> 'a1 t -> 'a2

                    val equal_rec :
                      ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                      'a2) -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                      (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> __ -> __ -> 'a2 -> 'a2) -> ('a1 t -> 'a1
                      t -> Coq_regex_as_UCT.t -> 'a1 ->
                      (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                      Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                      list -> __ -> Coq_regex_as_UCT.t compare0 -> __ -> __
                      -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t ->
                      __ -> __ -> 'a2) -> 'a1 t -> 'a1 t -> 'a2

                    val coq_R_equal_correct :
                      ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool -> 'a1
                      coq_R_equal

                    val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

                    val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

                    val option_cons :
                      key -> 'a1 option -> (key * 'a1) list -> (key * 'a1)
                      list

                    val map2_l :
                      ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t ->
                      'a3 t

                    val map2_r :
                      ('a1 option -> 'a2 option -> 'a3 option) -> 'a2 t ->
                      'a3 t

                    val map2 :
                      ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t ->
                      'a2 t -> 'a3 t

                    val combine :
                      'a1 t -> 'a2 t -> ('a1 option * 'a2 option) t

                    val fold_right_pair :
                      ('a1 -> 'a2 -> 'a3 -> 'a3) -> ('a1 * 'a2) list -> 'a3
                      -> 'a3

                    val map2_alt :
                      ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t ->
                      'a2 t -> (key * 'a3) list

                    val at_least_one :
                      'a1 option -> 'a2 option -> ('a1 option * 'a2 option)
                      option

                    val at_least_one_then_f :
                      ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 option
                      -> 'a2 option -> 'a3 option
                   end

                  type 'elt coq_R_mem = 'elt R.Defs.Coq_reFM.Raw.Proofs.coq_R_mem =
                  | R_mem_0 of 'elt tree
                  | R_mem_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                     * Z_as_Int.t * bool * 'elt coq_R_mem
                  | R_mem_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                     * Z_as_Int.t
                  | R_mem_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                     * Z_as_Int.t * bool * 'elt coq_R_mem

                  val coq_R_mem_rect :
                    Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2)
                    -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 tree
                    -> bool -> 'a1 coq_R_mem -> 'a2

                  val coq_R_mem_rec :
                    Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2)
                    -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 tree
                    -> bool -> 'a1 coq_R_mem -> 'a2

                  type 'elt coq_R_find = 'elt R.Defs.Coq_reFM.Raw.Proofs.coq_R_find =
                  | R_find_0 of 'elt tree
                  | R_find_1 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'elt option * 'elt coq_R_find
                  | R_find_2 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t
                  | R_find_3 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'elt option * 'elt coq_R_find

                  val coq_R_find_rect :
                    Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2
                    -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
                    tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree
                    -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                    -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 ->
                    'a2) -> 'a1 tree -> 'a1 option -> 'a1 coq_R_find -> 'a2

                  val coq_R_find_rec :
                    Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2
                    -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
                    tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree
                    -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                    -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 ->
                    'a2) -> 'a1 tree -> 'a1 option -> 'a1 coq_R_find -> 'a2

                  type 'elt coq_R_bal = 'elt R.Defs.Coq_reFM.Raw.Proofs.coq_R_bal =
                  | R_bal_0 of 'elt tree * key * 'elt * 'elt tree
                  | R_bal_1 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                     * key * 'elt * 'elt tree * Z_as_Int.t
                  | R_bal_2 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                     * key * 'elt * 'elt tree * Z_as_Int.t
                  | R_bal_3 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                     * key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t
                  | R_bal_4 of 'elt tree * key * 'elt * 'elt tree
                  | R_bal_5 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                     * key * 'elt * 'elt tree * Z_as_Int.t
                  | R_bal_6 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                     * key * 'elt * 'elt tree * Z_as_Int.t
                  | R_bal_7 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                     * key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t
                  | R_bal_8 of 'elt tree * key * 'elt * 'elt tree

                  val coq_R_bal_rect :
                    ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ ->
                    'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
                    -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                    -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1
                    tree -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree
                    -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key
                    -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
                    -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 ->
                    'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key ->
                    'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2)
                    -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __
                    -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key ->
                    'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree ->
                    key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
                    'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
                    -> __ -> __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree
                    -> 'a1 tree -> 'a1 coq_R_bal -> 'a2

                  val coq_R_bal_rec :
                    ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ ->
                    'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
                    -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                    -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1
                    tree -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree
                    -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key
                    -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
                    -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 ->
                    'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key ->
                    'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2)
                    -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __
                    -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key ->
                    'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree ->
                    key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
                    'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
                    -> __ -> __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree
                    -> 'a1 tree -> 'a1 coq_R_bal -> 'a2

                  type 'elt coq_R_add = 'elt R.Defs.Coq_reFM.Raw.Proofs.coq_R_add =
                  | R_add_0 of 'elt tree
                  | R_add_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                     * Z_as_Int.t * 'elt tree * 'elt coq_R_add
                  | R_add_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                     * Z_as_Int.t
                  | R_add_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                     * Z_as_Int.t * 'elt tree * 'elt coq_R_add

                  val coq_R_add_rect :
                    key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key
                    -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
                    tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 tree -> 'a1
                    tree -> 'a1 coq_R_add -> 'a2

                  val coq_R_add_rec :
                    key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key
                    -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
                    tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 tree -> 'a1
                    tree -> 'a1 coq_R_add -> 'a2

                  type 'elt coq_R_remove_min = 'elt R.Defs.Coq_reFM.Raw.Proofs.coq_R_remove_min =
                  | R_remove_min_0 of 'elt tree * key * 'elt * 'elt tree
                  | R_remove_min_1 of 'elt tree * key * 'elt * 'elt tree
                     * 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t
                     * ('elt tree * (key * 'elt)) * 'elt coq_R_remove_min
                     * 'elt tree * (key * 'elt)

                  val coq_R_remove_min_rect :
                    ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1
                    tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1
                    -> 'a1 tree -> Z_as_Int.t -> __ -> ('a1
                    tree * (key * 'a1)) -> 'a1 coq_R_remove_min -> 'a2 -> 'a1
                    tree -> (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> key ->
                    'a1 -> 'a1 tree -> ('a1 tree * (key * 'a1)) -> 'a1
                    coq_R_remove_min -> 'a2

                  val coq_R_remove_min_rec :
                    ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1
                    tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1
                    -> 'a1 tree -> Z_as_Int.t -> __ -> ('a1
                    tree * (key * 'a1)) -> 'a1 coq_R_remove_min -> 'a2 -> 'a1
                    tree -> (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> key ->
                    'a1 -> 'a1 tree -> ('a1 tree * (key * 'a1)) -> 'a1
                    coq_R_remove_min -> 'a2

                  type 'elt coq_R_merge = 'elt R.Defs.Coq_reFM.Raw.Proofs.coq_R_merge =
                  | R_merge_0 of 'elt tree * 'elt tree
                  | R_merge_1 of 'elt tree * 'elt tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t
                  | R_merge_2 of 'elt tree * 'elt tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree
                     * (key * 'elt) * key * 'elt

                  val coq_R_merge_rect :
                    ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> (key * 'a1) -> __ -> key -> 'a1 -> __ -> 'a2) -> 'a1
                    tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_merge -> 'a2

                  val coq_R_merge_rec :
                    ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> (key * 'a1) -> __ -> key -> 'a1 -> __ -> 'a2) -> 'a1
                    tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_merge -> 'a2

                  type 'elt coq_R_remove = 'elt R.Defs.Coq_reFM.Raw.Proofs.coq_R_remove =
                  | R_remove_0 of 'elt tree
                  | R_remove_1 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'elt tree * 'elt coq_R_remove
                  | R_remove_2 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t
                  | R_remove_3 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'elt tree * 'elt coq_R_remove

                  val coq_R_remove_rect :
                    Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2
                    -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
                    tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree
                    -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                    -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 ->
                    'a2) -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_remove -> 'a2

                  val coq_R_remove_rec :
                    Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2
                    -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
                    tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree
                    -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                    -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 ->
                    'a2) -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_remove -> 'a2

                  type 'elt coq_R_concat = 'elt R.Defs.Coq_reFM.Raw.Proofs.coq_R_concat =
                  | R_concat_0 of 'elt tree * 'elt tree
                  | R_concat_1 of 'elt tree * 'elt tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t
                  | R_concat_2 of 'elt tree * 'elt tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree
                     * (key * 'elt)

                  val coq_R_concat_rect :
                    ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> 'a1 tree ->
                    'a1 tree -> 'a1 coq_R_concat -> 'a2

                  val coq_R_concat_rec :
                    ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree
                    -> (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> 'a1 tree ->
                    'a1 tree -> 'a1 coq_R_concat -> 'a2

                  type 'elt coq_R_split = 'elt R.Defs.Coq_reFM.Raw.Proofs.coq_R_split =
                  | R_split_0 of 'elt tree
                  | R_split_1 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'elt triple
                     * 'elt coq_R_split * 'elt tree * 'elt option * 'elt tree
                  | R_split_2 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t
                  | R_split_3 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'elt triple
                     * 'elt coq_R_split * 'elt tree * 'elt option * 'elt tree

                  val coq_R_split_rect :
                    Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2
                    -> 'a1 tree -> 'a1 option -> 'a1 tree -> __ -> 'a2) ->
                    ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree
                    -> 'a1 option -> 'a1 tree -> __ -> 'a2) -> 'a1 tree ->
                    'a1 triple -> 'a1 coq_R_split -> 'a2

                  val coq_R_split_rec :
                    Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1
                    tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
                    -> __ -> __ -> __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2
                    -> 'a1 tree -> 'a1 option -> 'a1 tree -> __ -> 'a2) ->
                    ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
                    tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __
                    -> __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree
                    -> 'a1 option -> 'a1 tree -> __ -> 'a2) -> 'a1 tree ->
                    'a1 triple -> 'a1 coq_R_split -> 'a2

                  type ('elt, 'x) coq_R_map_option = ('elt, 'x) R.Defs.Coq_reFM.Raw.Proofs.coq_R_map_option =
                  | R_map_option_0 of 'elt tree
                  | R_map_option_1 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'x * 'x tree
                     * ('elt, 'x) coq_R_map_option * 'x tree
                     * ('elt, 'x) coq_R_map_option
                  | R_map_option_2 of 'elt tree * 'elt tree * key * 'elt
                     * 'elt tree * Z_as_Int.t * 'x tree
                     * ('elt, 'x) coq_R_map_option * 'x tree
                     * ('elt, 'x) coq_R_map_option

                  val coq_R_map_option_rect :
                    (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) ->
                    ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> 'a2 -> __ -> 'a2 tree -> ('a1, 'a2)
                    coq_R_map_option -> 'a3 -> 'a2 tree -> ('a1, 'a2)
                    coq_R_map_option -> 'a3 -> 'a3) -> ('a1 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                    'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2
                    tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> 'a1
                    tree -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3

                  val coq_R_map_option_rec :
                    (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) ->
                    ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                    Z_as_Int.t -> __ -> 'a2 -> __ -> 'a2 tree -> ('a1, 'a2)
                    coq_R_map_option -> 'a3 -> 'a2 tree -> ('a1, 'a2)
                    coq_R_map_option -> 'a3 -> 'a3) -> ('a1 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                    'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2
                    tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> 'a1
                    tree -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3

                  type ('elt, 'x0, 'x) coq_R_map2_opt = ('elt, 'x0, 'x) R.Defs.Coq_reFM.Raw.Proofs.coq_R_map2_opt =
                  | R_map2_opt_0 of 'elt tree * 'x0 tree
                  | R_map2_opt_1 of 'elt tree * 'x0 tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t
                  | R_map2_opt_2 of 'elt tree * 'x0 tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t * 'x0 tree * 
                     key * 'x0 * 'x0 tree * Z_as_Int.t * 'x0 tree
                     * 'x0 option * 'x0 tree * 'x * 'x tree
                     * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
                     * ('elt, 'x0, 'x) coq_R_map2_opt
                  | R_map2_opt_3 of 'elt tree * 'x0 tree * 'elt tree * 
                     key * 'elt * 'elt tree * Z_as_Int.t * 'x0 tree * 
                     key * 'x0 * 'x0 tree * Z_as_Int.t * 'x0 tree
                     * 'x0 option * 'x0 tree * 'x tree
                     * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
                     * ('elt, 'x0, 'x) coq_R_map2_opt

                  val coq_R_map2_opt_rect :
                    (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree ->
                    'a3 tree) -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2
                    tree -> __ -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                    'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1
                    -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 tree -> key -> 'a2
                    -> 'a2 tree -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2 option
                    -> 'a2 tree -> __ -> 'a3 -> __ -> 'a3 tree -> ('a1, 'a2,
                    'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
                    coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree ->
                    'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    'a2 tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ ->
                    'a2 tree -> 'a2 option -> 'a2 tree -> __ -> __ -> 'a3
                    tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree
                    -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1
                    tree -> 'a2 tree -> 'a3 tree -> ('a1, 'a2, 'a3)
                    coq_R_map2_opt -> 'a4

                  val coq_R_map2_opt_rec :
                    (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree ->
                    'a3 tree) -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2
                    tree -> __ -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree
                    -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                    'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1
                    -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2 tree -> key -> 'a2
                    -> 'a2 tree -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2 option
                    -> 'a2 tree -> __ -> 'a3 -> __ -> 'a3 tree -> ('a1, 'a2,
                    'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
                    coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree ->
                    'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                    'a2 tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ ->
                    'a2 tree -> 'a2 option -> 'a2 tree -> __ -> __ -> 'a3
                    tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree
                    -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1
                    tree -> 'a2 tree -> 'a3 tree -> ('a1, 'a2, 'a3)
                    coq_R_map2_opt -> 'a4

                  val fold' :
                    (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

                  val flatten_e : 'a1 enumeration -> (key * 'a1) list
                 end
               end

              type 'elt bst =
                'elt Raw.tree
                (* singleton inductive, whose constructor was Bst *)

              val this : 'a1 bst -> 'a1 Raw.tree

              type 'elt t = 'elt bst

              type key = Coq_regex_as_UCT.t

              val empty : 'a1 t

              val is_empty : 'a1 t -> bool

              val add : key -> 'a1 -> 'a1 t -> 'a1 t

              val remove : key -> 'a1 t -> 'a1 t

              val mem : key -> 'a1 t -> bool

              val find : key -> 'a1 t -> 'a1 option

              val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

              val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

              val map2 :
                ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t ->
                'a3 t

              val elements : 'a1 t -> (key * 'a1) list

              val cardinal : 'a1 t -> nat

              val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

              val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool
             end

            module Coq_reFMF :
             sig
              val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

              val coq_In_dec : 'a1 Coq_reFM.t -> Coq_reFM.key -> bool
             end

            module MatchSpec :
             sig
             end

            module MatchSpecLemmas :
             sig
             end

            module Notations :
             sig
             end

            module Helpers :
             sig
              val coq_Plus : Regexes.regex -> Regexes.regex

              val coq_IterUnion : Regexes.regex list -> Regexes.regex

              val coq_IterApp : Regexes.regex list -> Regexes.regex

              val coq_Optional : Regexes.regex -> Regexes.regex

              val coq_REString : Strings.coq_String -> Regexes.regex
             end
           end

          module Sigma_as_UOT :
           sig
            type t = R.Defs.T_as_UCT.t

            val compare : t -> t -> t compare0

            val eq_dec : t -> t -> bool
           end

          module Coq_regex_as_UOT :
           sig
            type t = R.Defs.Coq_regex_as_UCT.t

            val compare : t -> t -> t compare0

            val eq_dec : t -> t -> bool
           end

          module Coq_pair_as_UOT :
           sig
            module FA :
             sig
             end

            module FB :
             sig
             end

            type t = R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t

            val compare :
              t -> t -> (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t)
              compare0

            val eq_dec : t -> t -> bool
           end

          module FM :
           sig
            module E :
             sig
              type t = R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t

              val compare :
                (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
                (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
                (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) compare0

              val eq_dec :
                (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
                (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> bool
             end

            module Raw :
             sig
              type key = R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t

              type 'elt tree =
              | Leaf
              | Node of 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t

              val tree_rect :
                'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
                Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

              val tree_rec :
                'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
                Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

              val height : 'a1 tree -> Z_as_Int.t

              val cardinal : 'a1 tree -> nat

              val empty : 'a1 tree

              val is_empty : 'a1 tree -> bool

              val mem :
                (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 tree
                -> bool

              val find :
                (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 tree
                -> 'a1 option

              val create : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

              val assert_false :
                'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

              val bal : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

              val add : key -> 'a1 -> 'a1 tree -> 'a1 tree

              val remove_min :
                'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree * (key * 'a1)

              val merge : 'a1 tree -> 'a1 tree -> 'a1 tree

              val remove :
                (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 tree
                -> 'a1 tree

              val join : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

              type 'elt triple = { t_left : 'elt tree; t_opt : 'elt option;
                                   t_right : 'elt tree }

              val t_left : 'a1 triple -> 'a1 tree

              val t_opt : 'a1 triple -> 'a1 option

              val t_right : 'a1 triple -> 'a1 tree

              val split :
                (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 tree
                -> 'a1 triple

              val concat : 'a1 tree -> 'a1 tree -> 'a1 tree

              val elements_aux :
                (key * 'a1) list -> 'a1 tree -> (key * 'a1) list

              val elements : 'a1 tree -> (key * 'a1) list

              val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

              type 'elt enumeration =
              | End
              | More of key * 'elt * 'elt tree * 'elt enumeration

              val enumeration_rect :
                'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 ->
                'a2) -> 'a1 enumeration -> 'a2

              val enumeration_rec :
                'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 ->
                'a2) -> 'a1 enumeration -> 'a2

              val cons : 'a1 tree -> 'a1 enumeration -> 'a1 enumeration

              val equal_more :
                ('a1 -> 'a1 -> bool) ->
                (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                ('a1 enumeration -> bool) -> 'a1 enumeration -> bool

              val equal_cont :
                ('a1 -> 'a1 -> bool) -> 'a1 tree -> ('a1 enumeration -> bool)
                -> 'a1 enumeration -> bool

              val equal_end : 'a1 enumeration -> bool

              val equal : ('a1 -> 'a1 -> bool) -> 'a1 tree -> 'a1 tree -> bool

              val map : ('a1 -> 'a2) -> 'a1 tree -> 'a2 tree

              val mapi : (key -> 'a1 -> 'a2) -> 'a1 tree -> 'a2 tree

              val map_option :
                (key -> 'a1 -> 'a2 option) -> 'a1 tree -> 'a2 tree

              val map2_opt :
                (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3
                tree) -> ('a2 tree -> 'a3 tree) -> 'a1 tree -> 'a2 tree ->
                'a3 tree

              val map2 :
                ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 tree -> 'a2
                tree -> 'a3 tree

              module Proofs :
               sig
                module MX :
                 sig
                  module TO :
                   sig
                    type t = R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t
                   end

                  module IsTO :
                   sig
                   end

                  module OrderTac :
                   sig
                   end

                  val eq_dec :
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> bool

                  val lt_dec :
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> bool

                  val eqb :
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> bool
                 end

                module PX :
                 sig
                  module MO :
                   sig
                    module TO :
                     sig
                      type t = R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t
                     end

                    module IsTO :
                     sig
                     end

                    module OrderTac :
                     sig
                     end

                    val eq_dec :
                      (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
                      (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> bool

                    val lt_dec :
                      (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
                      (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> bool

                    val eqb :
                      (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
                      (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> bool
                   end
                 end

                module L :
                 sig
                  module MX :
                   sig
                    module TO :
                     sig
                      type t = R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t
                     end

                    module IsTO :
                     sig
                     end

                    module OrderTac :
                     sig
                     end

                    val eq_dec :
                      (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
                      (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> bool

                    val lt_dec :
                      (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
                      (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> bool

                    val eqb :
                      (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
                      (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> bool
                   end

                  module PX :
                   sig
                    module MO :
                     sig
                      module TO :
                       sig
                        type t = R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t
                       end

                      module IsTO :
                       sig
                       end

                      module OrderTac :
                       sig
                       end

                      val eq_dec :
                        (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
                        (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
                        bool

                      val lt_dec :
                        (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
                        (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
                        bool

                      val eqb :
                        (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
                        (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
                        bool
                     end
                   end

                  type key = R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t

                  type 'elt t =
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt)
                    list

                  val empty : 'a1 t

                  val is_empty : 'a1 t -> bool

                  val mem : key -> 'a1 t -> bool

                  type 'elt coq_R_mem =
                  | R_mem_0 of 'elt t
                  | R_mem_1 of 'elt t
                     * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 
                     'elt
                     * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt)
                       list
                  | R_mem_2 of 'elt t
                     * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 
                     'elt
                     * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt)
                       list
                  | R_mem_3 of 'elt t
                     * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 
                     'elt
                     * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt)
                       list * bool * 'elt coq_R_mem

                  val coq_R_mem_rect :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 ->
                    'a2) -> 'a1 t -> bool -> 'a1 coq_R_mem -> 'a2

                  val coq_R_mem_rec :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 ->
                    'a2) -> 'a1 t -> bool -> 'a1 coq_R_mem -> 'a2

                  val mem_rect :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                  val mem_rec :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                  val coq_R_mem_correct :
                    key -> 'a1 t -> bool -> 'a1 coq_R_mem

                  val find : key -> 'a1 t -> 'a1 option

                  type 'elt coq_R_find =
                  | R_find_0 of 'elt t
                  | R_find_1 of 'elt t
                     * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 
                     'elt
                     * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt)
                       list
                  | R_find_2 of 'elt t
                     * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 
                     'elt
                     * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt)
                       list
                  | R_find_3 of 'elt t
                     * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 
                     'elt
                     * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt)
                       list * 'elt option * 'elt coq_R_find

                  val coq_R_find_rect :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find ->
                    'a2 -> 'a2) -> 'a1 t -> 'a1 option -> 'a1 coq_R_find ->
                    'a2

                  val coq_R_find_rec :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find ->
                    'a2 -> 'a2) -> 'a1 t -> 'a1 option -> 'a1 coq_R_find ->
                    'a2

                  val find_rect :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                  val find_rec :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                  val coq_R_find_correct :
                    key -> 'a1 t -> 'a1 option -> 'a1 coq_R_find

                  val add : key -> 'a1 -> 'a1 t -> 'a1 t

                  type 'elt coq_R_add =
                  | R_add_0 of 'elt t
                  | R_add_1 of 'elt t
                     * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 
                     'elt
                     * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt)
                       list
                  | R_add_2 of 'elt t
                     * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 
                     'elt
                     * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt)
                       list
                  | R_add_3 of 'elt t
                     * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 
                     'elt
                     * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt)
                       list * 'elt t * 'elt coq_R_add

                  val coq_R_add_rect :
                    key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_add -> 'a2
                    -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_add -> 'a2

                  val coq_R_add_rec :
                    key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_add -> 'a2
                    -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_add -> 'a2

                  val add_rect :
                    key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                  val add_rec :
                    key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                  val coq_R_add_correct :
                    key -> 'a1 -> 'a1 t -> 'a1 t -> 'a1 coq_R_add

                  val remove : key -> 'a1 t -> 'a1 t

                  type 'elt coq_R_remove =
                  | R_remove_0 of 'elt t
                  | R_remove_1 of 'elt t
                     * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 
                     'elt
                     * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt)
                       list
                  | R_remove_2 of 'elt t
                     * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 
                     'elt
                     * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt)
                       list
                  | R_remove_3 of 'elt t
                     * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 
                     'elt
                     * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt)
                       list * 'elt t * 'elt coq_R_remove

                  val coq_R_remove_rect :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_remove ->
                    'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove -> 'a2

                  val coq_R_remove_rec :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_remove ->
                    'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove -> 'a2

                  val remove_rect :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                  val remove_rec :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                  val coq_R_remove_correct :
                    key -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove

                  val elements : 'a1 t -> 'a1 t

                  val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

                  type ('elt, 'a) coq_R_fold =
                  | R_fold_0 of 'elt t * 'a
                  | R_fold_1 of 'elt t * 'a
                     * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 
                     'elt
                     * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt)
                       list * 'a * ('elt, 'a) coq_R_fold

                  val coq_R_fold_rect :
                    (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3)
                    -> ('a1 t -> 'a2 ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> 'a2 -> ('a1, 'a2) coq_R_fold -> 'a3 -> 'a3)
                    -> 'a1 t -> 'a2 -> 'a2 -> ('a1, 'a2) coq_R_fold -> 'a3

                  val coq_R_fold_rec :
                    (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3)
                    -> ('a1 t -> 'a2 ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> 'a2 -> ('a1, 'a2) coq_R_fold -> 'a3 -> 'a3)
                    -> 'a1 t -> 'a2 -> 'a2 -> ('a1, 'a2) coq_R_fold -> 'a3

                  val fold_rect :
                    (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3)
                    -> ('a1 t -> 'a2 ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a3

                  val fold_rec :
                    (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3)
                    -> ('a1 t -> 'a2 ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a3

                  val coq_R_fold_correct :
                    (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2 ->
                    ('a1, 'a2) coq_R_fold

                  val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool

                  type 'elt coq_R_equal =
                  | R_equal_0 of 'elt t * 'elt t
                  | R_equal_1 of 'elt t * 'elt t
                     * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 
                     'elt
                     * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt)
                       list * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t)
                     * 'elt
                     * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt)
                       list * bool * 'elt coq_R_equal
                  | R_equal_2 of 'elt t * 'elt t
                     * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 
                     'elt
                     * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt)
                       list * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t)
                     * 'elt
                     * ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'elt)
                       list
                     * (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t)
                       compare0
                  | R_equal_3 of 'elt t * 'elt t * 'elt t * 'elt t

                  val coq_R_equal_rect :
                    ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                    'a2) -> ('a1 t -> 'a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> bool -> 'a1 coq_R_equal -> 'a2
                    -> 'a2) -> ('a1 t -> 'a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) compare0
                    -> __ -> __ -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ ->
                    'a1 t -> __ -> __ -> 'a2) -> 'a1 t -> 'a1 t -> bool ->
                    'a1 coq_R_equal -> 'a2

                  val coq_R_equal_rec :
                    ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                    'a2) -> ('a1 t -> 'a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> bool -> 'a1 coq_R_equal -> 'a2
                    -> 'a2) -> ('a1 t -> 'a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) compare0
                    -> __ -> __ -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ ->
                    'a1 t -> __ -> __ -> 'a2) -> 'a1 t -> 'a1 t -> bool ->
                    'a1 coq_R_equal -> 'a2

                  val equal_rect :
                    ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                    'a2) -> ('a1 t -> 'a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t
                    -> (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1
                    ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) compare0
                    -> __ -> __ -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ ->
                    'a1 t -> __ -> __ -> 'a2) -> 'a1 t -> 'a1 t -> 'a2

                  val equal_rec :
                    ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                    'a2) -> ('a1 t -> 'a1 t ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ -> __ -> __ -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t
                    -> (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1
                    ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> 'a1 ->
                    ((R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) * 'a1)
                    list -> __ ->
                    (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) compare0
                    -> __ -> __ -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ ->
                    'a1 t -> __ -> __ -> 'a2) -> 'a1 t -> 'a1 t -> 'a2

                  val coq_R_equal_correct :
                    ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool -> 'a1
                    coq_R_equal

                  val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

                  val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

                  val option_cons :
                    key -> 'a1 option -> (key * 'a1) list -> (key * 'a1) list

                  val map2_l :
                    ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a3 t

                  val map2_r :
                    ('a1 option -> 'a2 option -> 'a3 option) -> 'a2 t -> 'a3 t

                  val map2 :
                    ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2
                    t -> 'a3 t

                  val combine : 'a1 t -> 'a2 t -> ('a1 option * 'a2 option) t

                  val fold_right_pair :
                    ('a1 -> 'a2 -> 'a3 -> 'a3) -> ('a1 * 'a2) list -> 'a3 ->
                    'a3

                  val map2_alt :
                    ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2
                    t -> (key * 'a3) list

                  val at_least_one :
                    'a1 option -> 'a2 option -> ('a1 option * 'a2 option)
                    option

                  val at_least_one_then_f :
                    ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 option ->
                    'a2 option -> 'a3 option
                 end

                type 'elt coq_R_mem =
                | R_mem_0 of 'elt tree
                | R_mem_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t * bool * 'elt coq_R_mem
                | R_mem_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t
                | R_mem_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t * bool * 'elt coq_R_mem

                val coq_R_mem_rect :
                  (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> ('a1
                  tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
                  -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> bool -> 'a1
                  coq_R_mem -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree -> key ->
                  'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) ->
                  ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem ->
                  'a2 -> 'a2) -> 'a1 tree -> bool -> 'a1 coq_R_mem -> 'a2

                val coq_R_mem_rec :
                  (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> ('a1
                  tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
                  -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> bool -> 'a1
                  coq_R_mem -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree -> key ->
                  'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) ->
                  ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem ->
                  'a2 -> 'a2) -> 'a1 tree -> bool -> 'a1 coq_R_mem -> 'a2

                type 'elt coq_R_find =
                | R_find_0 of 'elt tree
                | R_find_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t * 'elt option * 'elt coq_R_find
                | R_find_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t
                | R_find_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t * 'elt option * 'elt coq_R_find

                val coq_R_find_rect :
                  (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> ('a1
                  tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
                  -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 option
                  -> 'a1 coq_R_find -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree
                  -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __
                  -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree
                  -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 option -> 'a1
                  coq_R_find -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 option -> 'a1
                  coq_R_find -> 'a2

                val coq_R_find_rec :
                  (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> ('a1
                  tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
                  -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 option
                  -> 'a1 coq_R_find -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree
                  -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __
                  -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree
                  -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 option -> 'a1
                  coq_R_find -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 option -> 'a1
                  coq_R_find -> 'a2

                type 'elt coq_R_bal =
                | R_bal_0 of 'elt tree * key * 'elt * 'elt tree
                | R_bal_1 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                   * key * 'elt * 'elt tree * Z_as_Int.t
                | R_bal_2 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                   * key * 'elt * 'elt tree * Z_as_Int.t
                | R_bal_3 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                   * key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * 
                   key * 'elt * 'elt tree * Z_as_Int.t
                | R_bal_4 of 'elt tree * key * 'elt * 'elt tree
                | R_bal_5 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                   * key * 'elt * 'elt tree * Z_as_Int.t
                | R_bal_6 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                   * key * 'elt * 'elt tree * Z_as_Int.t
                | R_bal_7 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                   * key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * 
                   key * 'elt * 'elt tree * Z_as_Int.t
                | R_bal_8 of 'elt tree * key * 'elt * 'elt tree

                val coq_R_bal_rect :
                  ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ ->
                  'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ ->
                  'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                  __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree ->
                  __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree ->
                  key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key ->
                  'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree
                  -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2) ->
                  ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __
                  -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __
                  -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key ->
                  'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key
                  -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> __ ->
                  'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ ->
                  __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 ->
                  'a1 tree -> Z_as_Int.t -> __ -> 'a2) -> ('a1 tree -> key ->
                  'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a2) -> 'a1 tree
                  -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_bal ->
                  'a2

                val coq_R_bal_rec :
                  ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ ->
                  'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ ->
                  'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                  __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree ->
                  __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree ->
                  key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key ->
                  'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree
                  -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2) ->
                  ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __
                  -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __
                  -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key ->
                  'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key
                  -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> __ ->
                  'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ ->
                  __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 ->
                  'a1 tree -> Z_as_Int.t -> __ -> 'a2) -> ('a1 tree -> key ->
                  'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a2) -> 'a1 tree
                  -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_bal ->
                  'a2

                type 'elt coq_R_add =
                | R_add_0 of 'elt tree
                | R_add_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t * 'elt tree * 'elt coq_R_add
                | R_add_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t
                | R_add_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t * 'elt tree * 'elt coq_R_add

                val coq_R_add_rect :
                  key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                  __ -> 'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1 tree
                  -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                  -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
                  -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree ->
                  'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1
                  coq_R_add -> 'a2

                val coq_R_add_rec :
                  key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                  __ -> 'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1 tree
                  -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                  -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
                  -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree ->
                  'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1
                  coq_R_add -> 'a2

                type 'elt coq_R_remove_min =
                | R_remove_min_0 of 'elt tree * key * 'elt * 'elt tree
                | R_remove_min_1 of 'elt tree * key * 'elt * 'elt tree
                   * 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t
                   * ('elt tree * (key * 'elt)) * 'elt coq_R_remove_min
                   * 'elt tree * (key * 'elt)

                val coq_R_remove_min_rect :
                  ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1
                  tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1 ->
                  'a1 tree -> Z_as_Int.t -> __ -> ('a1 tree * (key * 'a1)) ->
                  'a1 coq_R_remove_min -> 'a2 -> 'a1 tree -> (key * 'a1) ->
                  __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> ('a1
                  tree * (key * 'a1)) -> 'a1 coq_R_remove_min -> 'a2

                val coq_R_remove_min_rec :
                  ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1
                  tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1 ->
                  'a1 tree -> Z_as_Int.t -> __ -> ('a1 tree * (key * 'a1)) ->
                  'a1 coq_R_remove_min -> 'a2 -> 'a1 tree -> (key * 'a1) ->
                  __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> ('a1
                  tree * (key * 'a1)) -> 'a1 coq_R_remove_min -> 'a2

                type 'elt coq_R_merge =
                | R_merge_0 of 'elt tree * 'elt tree
                | R_merge_1 of 'elt tree * 'elt tree * 'elt tree * key * 
                   'elt * 'elt tree * Z_as_Int.t
                | R_merge_2 of 'elt tree * 'elt tree * 'elt tree * key * 
                   'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 
                   'elt * 'elt tree * Z_as_Int.t * 'elt tree * (key * 'elt)
                   * key * 'elt

                val coq_R_merge_rect :
                  ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
                  __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree ->
                  (key * 'a1) -> __ -> key -> 'a1 -> __ -> 'a2) -> 'a1 tree
                  -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_merge -> 'a2

                val coq_R_merge_rec :
                  ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
                  __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree ->
                  (key * 'a1) -> __ -> key -> 'a1 -> __ -> 'a2) -> 'a1 tree
                  -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_merge -> 'a2

                type 'elt coq_R_remove =
                | R_remove_0 of 'elt tree
                | R_remove_1 of 'elt tree * 'elt tree * key * 'elt
                   * 'elt tree * Z_as_Int.t * 'elt tree * 'elt coq_R_remove
                | R_remove_2 of 'elt tree * 'elt tree * key * 'elt
                   * 'elt tree * Z_as_Int.t
                | R_remove_3 of 'elt tree * 'elt tree * key * 'elt
                   * 'elt tree * Z_as_Int.t * 'elt tree * 'elt coq_R_remove

                val coq_R_remove_rect :
                  (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> ('a1
                  tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
                  -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree ->
                  'a1 coq_R_remove -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
                  'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> 'a1
                  coq_R_remove -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1
                  coq_R_remove -> 'a2

                val coq_R_remove_rec :
                  (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> ('a1
                  tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
                  -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree ->
                  'a1 coq_R_remove -> 'a2 -> 'a2) -> ('a1 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
                  'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> 'a1
                  coq_R_remove -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1
                  coq_R_remove -> 'a2

                type 'elt coq_R_concat =
                | R_concat_0 of 'elt tree * 'elt tree
                | R_concat_1 of 'elt tree * 'elt tree * 'elt tree * key
                   * 'elt * 'elt tree * Z_as_Int.t
                | R_concat_2 of 'elt tree * 'elt tree * 'elt tree * key
                   * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 
                   'elt * 'elt tree * Z_as_Int.t * 'elt tree * (key * 'elt)

                val coq_R_concat_rect :
                  ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
                  __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree ->
                  (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1
                  tree -> 'a1 coq_R_concat -> 'a2

                val coq_R_concat_rec :
                  ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
                  __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree ->
                  (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1
                  tree -> 'a1 coq_R_concat -> 'a2

                type 'elt coq_R_split =
                | R_split_0 of 'elt tree
                | R_split_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t * 'elt triple * 'elt coq_R_split * 'elt tree
                   * 'elt option * 'elt tree
                | R_split_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t
                | R_split_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t * 'elt triple * 'elt coq_R_split * 'elt tree
                   * 'elt option * 'elt tree

                val coq_R_split_rect :
                  (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> ('a1
                  tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
                  -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 triple
                  -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option -> 'a1
                  tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
                  -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1
                  tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
                  __ -> __ -> __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 ->
                  'a1 tree -> 'a1 option -> 'a1 tree -> __ -> 'a2) -> 'a1
                  tree -> 'a1 triple -> 'a1 coq_R_split -> 'a2

                val coq_R_split_rec :
                  (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> ('a1
                  tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
                  -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 triple
                  -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option -> 'a1
                  tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
                  -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1
                  tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
                  __ -> __ -> __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 ->
                  'a1 tree -> 'a1 option -> 'a1 tree -> __ -> 'a2) -> 'a1
                  tree -> 'a1 triple -> 'a1 coq_R_split -> 'a2

                type ('elt, 'x) coq_R_map_option =
                | R_map_option_0 of 'elt tree
                | R_map_option_1 of 'elt tree * 'elt tree * key * 'elt
                   * 'elt tree * Z_as_Int.t * 'x * 'x tree
                   * ('elt, 'x) coq_R_map_option * 'x tree
                   * ('elt, 'x) coq_R_map_option
                | R_map_option_2 of 'elt tree * 'elt tree * key * 'elt
                   * 'elt tree * Z_as_Int.t * 'x tree
                   * ('elt, 'x) coq_R_map_option * 'x tree
                   * ('elt, 'x) coq_R_map_option

                val coq_R_map_option_rect :
                  (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) ->
                  ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> 'a2 -> __ -> 'a2 tree -> ('a1, 'a2)
                  coq_R_map_option -> 'a3 -> 'a2 tree -> ('a1, 'a2)
                  coq_R_map_option -> 'a3 -> 'a3) -> ('a1 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a2
                  tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2 tree ->
                  ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> 'a1 tree ->
                  'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3

                val coq_R_map_option_rec :
                  (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) ->
                  ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> 'a2 -> __ -> 'a2 tree -> ('a1, 'a2)
                  coq_R_map_option -> 'a3 -> 'a2 tree -> ('a1, 'a2)
                  coq_R_map_option -> 'a3 -> 'a3) -> ('a1 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a2
                  tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2 tree ->
                  ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> 'a1 tree ->
                  'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3

                type ('elt, 'x0, 'x) coq_R_map2_opt =
                | R_map2_opt_0 of 'elt tree * 'x0 tree
                | R_map2_opt_1 of 'elt tree * 'x0 tree * 'elt tree * 
                   key * 'elt * 'elt tree * Z_as_Int.t
                | R_map2_opt_2 of 'elt tree * 'x0 tree * 'elt tree * 
                   key * 'elt * 'elt tree * Z_as_Int.t * 'x0 tree * key * 
                   'x0 * 'x0 tree * Z_as_Int.t * 'x0 tree * 'x0 option
                   * 'x0 tree * 'x * 'x tree * ('elt, 'x0, 'x) coq_R_map2_opt
                   * 'x tree * ('elt, 'x0, 'x) coq_R_map2_opt
                | R_map2_opt_3 of 'elt tree * 'x0 tree * 'elt tree * 
                   key * 'elt * 'elt tree * Z_as_Int.t * 'x0 tree * key * 
                   'x0 * 'x0 tree * Z_as_Int.t * 'x0 tree * 'x0 option
                   * 'x0 tree * 'x tree * ('elt, 'x0, 'x) coq_R_map2_opt
                   * 'x tree * ('elt, 'x0, 'x) coq_R_map2_opt

                val coq_R_map2_opt_rect :
                  (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree ->
                  'a3 tree) -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2
                  tree -> __ -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a4) ->
                  ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree
                  -> Z_as_Int.t -> __ -> 'a2 tree -> key -> 'a2 -> 'a2 tree
                  -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2 option -> 'a2 tree
                  -> __ -> 'a3 -> __ -> 'a3 tree -> ('a1, 'a2, 'a3)
                  coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
                  coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree ->
                  'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                  'a2 tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ ->
                  'a2 tree -> 'a2 option -> 'a2 tree -> __ -> __ -> 'a3 tree
                  -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree ->
                  ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1 tree
                  -> 'a2 tree -> 'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt
                  -> 'a4

                val coq_R_map2_opt_rec :
                  (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree ->
                  'a3 tree) -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2
                  tree -> __ -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a4) ->
                  ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree
                  -> Z_as_Int.t -> __ -> 'a2 tree -> key -> 'a2 -> 'a2 tree
                  -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2 option -> 'a2 tree
                  -> __ -> 'a3 -> __ -> 'a3 tree -> ('a1, 'a2, 'a3)
                  coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
                  coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree ->
                  'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                  'a2 tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ ->
                  'a2 tree -> 'a2 option -> 'a2 tree -> __ -> __ -> 'a3 tree
                  -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree ->
                  ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1 tree
                  -> 'a2 tree -> 'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt
                  -> 'a4

                val fold' :
                  (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

                val flatten_e : 'a1 enumeration -> (key * 'a1) list
               end
             end

            type 'elt bst =
              'elt Raw.tree
              (* singleton inductive, whose constructor was Bst *)

            val this : 'a1 bst -> 'a1 Raw.tree

            type 'elt t = 'elt bst

            type key = R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t

            val empty : 'a1 t

            val is_empty : 'a1 t -> bool

            val add : key -> 'a1 -> 'a1 t -> 'a1 t

            val remove : key -> 'a1 t -> 'a1 t

            val mem : key -> 'a1 t -> bool

            val find : key -> 'a1 t -> 'a1 option

            val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

            val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

            val map2 :
              ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t ->
              'a3 t

            val elements : 'a1 t -> (key * 'a1) list

            val cardinal : 'a1 t -> nat

            val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

            val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool
           end

          module FMF :
           sig
            val eqb :
              (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) ->
              (R.Defs.Coq_regex_as_UCT.t * R.Defs.T_as_UCT.t) -> bool

            val coq_In_dec : 'a1 FM.t -> FM.key -> bool
           end

          module Coq_reFS :
           sig
            module X' :
             sig
              type t = R.Defs.Coq_regex_as_UCT.t

              val eq_dec :
                R.Defs.Coq_regex_as_UCT.t -> R.Defs.Coq_regex_as_UCT.t -> bool

              val compare :
                R.Defs.Coq_regex_as_UCT.t -> R.Defs.Coq_regex_as_UCT.t ->
                comparison
             end

            module MSet :
             sig
              module Raw :
               sig
                type elt = R.Defs.Coq_regex_as_UCT.t

                type tree = R.Defs.Coq_reFS.MSet.Raw.tree =
                | Leaf
                | Node of Z_as_Int.t * tree * R.Defs.Coq_regex_as_UCT.t * tree

                val empty : tree

                val is_empty : tree -> bool

                val mem : R.Defs.Coq_regex_as_UCT.t -> tree -> bool

                val min_elt : tree -> elt option

                val max_elt : tree -> elt option

                val choose : tree -> elt option

                val fold : (elt -> 'a1 -> 'a1) -> tree -> 'a1 -> 'a1

                val elements_aux :
                  R.Defs.Coq_regex_as_UCT.t list -> tree ->
                  R.Defs.Coq_regex_as_UCT.t list

                val elements : tree -> R.Defs.Coq_regex_as_UCT.t list

                val rev_elements_aux :
                  R.Defs.Coq_regex_as_UCT.t list -> tree ->
                  R.Defs.Coq_regex_as_UCT.t list

                val rev_elements : tree -> R.Defs.Coq_regex_as_UCT.t list

                val cardinal : tree -> nat

                val maxdepth : tree -> nat

                val mindepth : tree -> nat

                val for_all : (elt -> bool) -> tree -> bool

                val exists_ : (elt -> bool) -> tree -> bool

                type enumeration = R.Defs.Coq_reFS.MSet.Raw.enumeration =
                | End
                | More of elt * tree * enumeration

                val cons : tree -> enumeration -> enumeration

                val compare_more :
                  R.Defs.Coq_regex_as_UCT.t -> (enumeration -> comparison) ->
                  enumeration -> comparison

                val compare_cont :
                  tree -> (enumeration -> comparison) -> enumeration ->
                  comparison

                val compare_end : enumeration -> comparison

                val compare : tree -> tree -> comparison

                val equal : tree -> tree -> bool

                val subsetl :
                  (tree -> bool) -> R.Defs.Coq_regex_as_UCT.t -> tree -> bool

                val subsetr :
                  (tree -> bool) -> R.Defs.Coq_regex_as_UCT.t -> tree -> bool

                val subset : tree -> tree -> bool

                type t = tree

                val height : t -> Z_as_Int.t

                val singleton : R.Defs.Coq_regex_as_UCT.t -> tree

                val create : t -> R.Defs.Coq_regex_as_UCT.t -> t -> tree

                val assert_false : t -> R.Defs.Coq_regex_as_UCT.t -> t -> tree

                val bal : t -> R.Defs.Coq_regex_as_UCT.t -> t -> tree

                val add : R.Defs.Coq_regex_as_UCT.t -> tree -> tree

                val join : tree -> elt -> t -> t

                val remove_min : tree -> elt -> t -> t * elt

                val merge : tree -> tree -> tree

                val remove : R.Defs.Coq_regex_as_UCT.t -> tree -> tree

                val concat : tree -> tree -> tree

                type triple = R.Defs.Coq_reFS.MSet.Raw.triple = { t_left : 
                                                                  t;
                                                                  t_in : 
                                                                  bool;
                                                                  t_right : 
                                                                  t }

                val t_left : triple -> t

                val t_in : triple -> bool

                val t_right : triple -> t

                val split : R.Defs.Coq_regex_as_UCT.t -> tree -> triple

                val inter : tree -> tree -> tree

                val diff : tree -> tree -> tree

                val union : tree -> tree -> tree

                val filter : (elt -> bool) -> tree -> tree

                val partition : (elt -> bool) -> t -> t * t

                val ltb_tree : R.Defs.Coq_regex_as_UCT.t -> tree -> bool

                val gtb_tree : R.Defs.Coq_regex_as_UCT.t -> tree -> bool

                val isok : tree -> bool

                module MX :
                 sig
                  module OrderTac :
                   sig
                    module OTF :
                     sig
                      type t = R.Defs.Coq_regex_as_UCT.t

                      val compare :
                        R.Defs.Coq_regex_as_UCT.t ->
                        R.Defs.Coq_regex_as_UCT.t -> comparison

                      val eq_dec :
                        R.Defs.Coq_regex_as_UCT.t ->
                        R.Defs.Coq_regex_as_UCT.t -> bool
                     end

                    module TO :
                     sig
                      type t = R.Defs.Coq_regex_as_UCT.t

                      val compare :
                        R.Defs.Coq_regex_as_UCT.t ->
                        R.Defs.Coq_regex_as_UCT.t -> comparison

                      val eq_dec :
                        R.Defs.Coq_regex_as_UCT.t ->
                        R.Defs.Coq_regex_as_UCT.t -> bool
                     end
                   end

                  val eq_dec :
                    R.Defs.Coq_regex_as_UCT.t -> R.Defs.Coq_regex_as_UCT.t ->
                    bool

                  val lt_dec :
                    R.Defs.Coq_regex_as_UCT.t -> R.Defs.Coq_regex_as_UCT.t ->
                    bool

                  val eqb :
                    R.Defs.Coq_regex_as_UCT.t -> R.Defs.Coq_regex_as_UCT.t ->
                    bool
                 end

                type coq_R_min_elt = R.Defs.Coq_reFS.MSet.Raw.coq_R_min_elt =
                | R_min_elt_0 of tree
                | R_min_elt_1 of tree * Z_as_Int.t * tree
                   * R.Defs.Coq_regex_as_UCT.t * tree
                | R_min_elt_2 of tree * Z_as_Int.t * tree
                   * R.Defs.Coq_regex_as_UCT.t * tree * Z_as_Int.t * 
                   tree * R.Defs.Coq_regex_as_UCT.t * tree * elt option
                   * coq_R_min_elt

                type coq_R_max_elt = R.Defs.Coq_reFS.MSet.Raw.coq_R_max_elt =
                | R_max_elt_0 of tree
                | R_max_elt_1 of tree * Z_as_Int.t * tree
                   * R.Defs.Coq_regex_as_UCT.t * tree
                | R_max_elt_2 of tree * Z_as_Int.t * tree
                   * R.Defs.Coq_regex_as_UCT.t * tree * Z_as_Int.t * 
                   tree * R.Defs.Coq_regex_as_UCT.t * tree * elt option
                   * coq_R_max_elt

                module L :
                 sig
                  module MO :
                   sig
                    module OrderTac :
                     sig
                      module OTF :
                       sig
                        type t = R.Defs.Coq_regex_as_UCT.t

                        val compare :
                          R.Defs.Coq_regex_as_UCT.t ->
                          R.Defs.Coq_regex_as_UCT.t -> comparison

                        val eq_dec :
                          R.Defs.Coq_regex_as_UCT.t ->
                          R.Defs.Coq_regex_as_UCT.t -> bool
                       end

                      module TO :
                       sig
                        type t = R.Defs.Coq_regex_as_UCT.t

                        val compare :
                          R.Defs.Coq_regex_as_UCT.t ->
                          R.Defs.Coq_regex_as_UCT.t -> comparison

                        val eq_dec :
                          R.Defs.Coq_regex_as_UCT.t ->
                          R.Defs.Coq_regex_as_UCT.t -> bool
                       end
                     end

                    val eq_dec :
                      R.Defs.Coq_regex_as_UCT.t -> R.Defs.Coq_regex_as_UCT.t
                      -> bool

                    val lt_dec :
                      R.Defs.Coq_regex_as_UCT.t -> R.Defs.Coq_regex_as_UCT.t
                      -> bool

                    val eqb :
                      R.Defs.Coq_regex_as_UCT.t -> R.Defs.Coq_regex_as_UCT.t
                      -> bool
                   end
                 end

                val flatten_e : enumeration -> elt list

                type coq_R_bal = R.Defs.Coq_reFS.MSet.Raw.coq_R_bal =
                | R_bal_0 of t * R.Defs.Coq_regex_as_UCT.t * t
                | R_bal_1 of t * R.Defs.Coq_regex_as_UCT.t * t * Z_as_Int.t
                   * tree * R.Defs.Coq_regex_as_UCT.t * tree
                | R_bal_2 of t * R.Defs.Coq_regex_as_UCT.t * t * Z_as_Int.t
                   * tree * R.Defs.Coq_regex_as_UCT.t * tree
                | R_bal_3 of t * R.Defs.Coq_regex_as_UCT.t * t * Z_as_Int.t
                   * tree * R.Defs.Coq_regex_as_UCT.t * tree * Z_as_Int.t
                   * tree * R.Defs.Coq_regex_as_UCT.t * tree
                | R_bal_4 of t * R.Defs.Coq_regex_as_UCT.t * t
                | R_bal_5 of t * R.Defs.Coq_regex_as_UCT.t * t * Z_as_Int.t
                   * tree * R.Defs.Coq_regex_as_UCT.t * tree
                | R_bal_6 of t * R.Defs.Coq_regex_as_UCT.t * t * Z_as_Int.t
                   * tree * R.Defs.Coq_regex_as_UCT.t * tree
                | R_bal_7 of t * R.Defs.Coq_regex_as_UCT.t * t * Z_as_Int.t
                   * tree * R.Defs.Coq_regex_as_UCT.t * tree * Z_as_Int.t
                   * tree * R.Defs.Coq_regex_as_UCT.t * tree
                | R_bal_8 of t * R.Defs.Coq_regex_as_UCT.t * t

                type coq_R_remove_min = R.Defs.Coq_reFS.MSet.Raw.coq_R_remove_min =
                | R_remove_min_0 of tree * elt * t
                | R_remove_min_1 of tree * elt * t * Z_as_Int.t * tree
                   * R.Defs.Coq_regex_as_UCT.t * tree * (t * elt)
                   * coq_R_remove_min * t * elt

                type coq_R_merge = R.Defs.Coq_reFS.MSet.Raw.coq_R_merge =
                | R_merge_0 of tree * tree
                | R_merge_1 of tree * tree * Z_as_Int.t * tree
                   * R.Defs.Coq_regex_as_UCT.t * tree
                | R_merge_2 of tree * tree * Z_as_Int.t * tree
                   * R.Defs.Coq_regex_as_UCT.t * tree * Z_as_Int.t * 
                   tree * R.Defs.Coq_regex_as_UCT.t * tree * t * elt

                type coq_R_concat = R.Defs.Coq_reFS.MSet.Raw.coq_R_concat =
                | R_concat_0 of tree * tree
                | R_concat_1 of tree * tree * Z_as_Int.t * tree
                   * R.Defs.Coq_regex_as_UCT.t * tree
                | R_concat_2 of tree * tree * Z_as_Int.t * tree
                   * R.Defs.Coq_regex_as_UCT.t * tree * Z_as_Int.t * 
                   tree * R.Defs.Coq_regex_as_UCT.t * tree * t * elt

                type coq_R_inter = R.Defs.Coq_reFS.MSet.Raw.coq_R_inter =
                | R_inter_0 of tree * tree
                | R_inter_1 of tree * tree * Z_as_Int.t * tree
                   * R.Defs.Coq_regex_as_UCT.t * tree
                | R_inter_2 of tree * tree * Z_as_Int.t * tree
                   * R.Defs.Coq_regex_as_UCT.t * tree * Z_as_Int.t * 
                   tree * R.Defs.Coq_regex_as_UCT.t * tree * t * bool * 
                   t * tree * coq_R_inter * tree * coq_R_inter
                | R_inter_3 of tree * tree * Z_as_Int.t * tree
                   * R.Defs.Coq_regex_as_UCT.t * tree * Z_as_Int.t * 
                   tree * R.Defs.Coq_regex_as_UCT.t * tree * t * bool * 
                   t * tree * coq_R_inter * tree * coq_R_inter

                type coq_R_diff = R.Defs.Coq_reFS.MSet.Raw.coq_R_diff =
                | R_diff_0 of tree * tree
                | R_diff_1 of tree * tree * Z_as_Int.t * tree
                   * R.Defs.Coq_regex_as_UCT.t * tree
                | R_diff_2 of tree * tree * Z_as_Int.t * tree
                   * R.Defs.Coq_regex_as_UCT.t * tree * Z_as_Int.t * 
                   tree * R.Defs.Coq_regex_as_UCT.t * tree * t * bool * 
                   t * tree * coq_R_diff * tree * coq_R_diff
                | R_diff_3 of tree * tree * Z_as_Int.t * tree
                   * R.Defs.Coq_regex_as_UCT.t * tree * Z_as_Int.t * 
                   tree * R.Defs.Coq_regex_as_UCT.t * tree * t * bool * 
                   t * tree * coq_R_diff * tree * coq_R_diff

                type coq_R_union = R.Defs.Coq_reFS.MSet.Raw.coq_R_union =
                | R_union_0 of tree * tree
                | R_union_1 of tree * tree * Z_as_Int.t * tree
                   * R.Defs.Coq_regex_as_UCT.t * tree
                | R_union_2 of tree * tree * Z_as_Int.t * tree
                   * R.Defs.Coq_regex_as_UCT.t * tree * Z_as_Int.t * 
                   tree * R.Defs.Coq_regex_as_UCT.t * tree * t * bool * 
                   t * tree * coq_R_union * tree * coq_R_union
               end

              module E :
               sig
                type t = R.Defs.Coq_regex_as_UCT.t

                val compare :
                  R.Defs.Coq_regex_as_UCT.t -> R.Defs.Coq_regex_as_UCT.t ->
                  comparison

                val eq_dec :
                  R.Defs.Coq_regex_as_UCT.t -> R.Defs.Coq_regex_as_UCT.t ->
                  bool
               end

              type elt = R.Defs.Coq_regex_as_UCT.t

              type t_ =
                Raw.t
                (* singleton inductive, whose constructor was Mkt *)

              val this : t_ -> Raw.t

              type t = t_

              val mem : elt -> t -> bool

              val add : elt -> t -> t

              val remove : elt -> t -> t

              val singleton : elt -> t

              val union : t -> t -> t

              val inter : t -> t -> t

              val diff : t -> t -> t

              val equal : t -> t -> bool

              val subset : t -> t -> bool

              val empty : t

              val is_empty : t -> bool

              val elements : t -> elt list

              val choose : t -> elt option

              val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

              val cardinal : t -> nat

              val filter : (elt -> bool) -> t -> t

              val for_all : (elt -> bool) -> t -> bool

              val exists_ : (elt -> bool) -> t -> bool

              val partition : (elt -> bool) -> t -> t * t

              val eq_dec : t -> t -> bool

              val compare : t -> t -> comparison

              val min_elt : t -> elt option

              val max_elt : t -> elt option
             end

            type elt = R.Defs.Coq_regex_as_UCT.t

            type t = MSet.t

            val empty : t

            val is_empty : t -> bool

            val mem : elt -> t -> bool

            val add : elt -> t -> t

            val singleton : elt -> t

            val remove : elt -> t -> t

            val union : t -> t -> t

            val inter : t -> t -> t

            val diff : t -> t -> t

            val eq_dec : t -> t -> bool

            val equal : t -> t -> bool

            val subset : t -> t -> bool

            val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

            val for_all : (elt -> bool) -> t -> bool

            val exists_ : (elt -> bool) -> t -> bool

            val filter : (elt -> bool) -> t -> t

            val partition : (elt -> bool) -> t -> t * t

            val cardinal : t -> nat

            val elements : t -> elt list

            val choose : t -> elt option

            module MF :
             sig
              val eqb :
                R.Defs.Coq_regex_as_UCT.t -> R.Defs.Coq_regex_as_UCT.t -> bool
             end

            val min_elt : t -> elt option

            val max_elt : t -> elt option

            val compare : t -> t -> t compare0

            module E :
             sig
              type t = R.Defs.Coq_regex_as_UCT.t

              val compare :
                R.Defs.Coq_regex_as_UCT.t -> R.Defs.Coq_regex_as_UCT.t ->
                R.Defs.Coq_regex_as_UCT.t compare0

              val eq_dec :
                R.Defs.Coq_regex_as_UCT.t -> R.Defs.Coq_regex_as_UCT.t -> bool
             end
           end

          type coq_Table = R.Defs.Regexes.regex FM.t * Coq_reFS.t

          val emptyTable : coq_Table

          val set_Table :
            coq_Table -> R.Defs.Regexes.regex -> R.Ty.coq_Sigma ->
            R.Defs.Regexes.regex -> coq_Table

          val get_Table :
            coq_Table -> R.Defs.Regexes.regex -> R.Ty.coq_Sigma ->
            R.Defs.Regexes.regex option

          val add_state : coq_Table -> R.Defs.Regexes.regex -> coq_Table

          val get_states : coq_Table -> Coq_reFS.t

          val get_eq :
            coq_Table -> R.Defs.Regexes.regex -> R.Defs.Regexes.regex option
         end

        module Defs :
         sig
          module FillTable :
           sig
            val mkIterUnion' :
              R.Defs.Regexes.regex -> R.Defs.Regexes.regex list

            val merge' :
              R.Defs.Regexes.regex list -> R.Defs.Regexes.regex list ->
              R.Defs.Regexes.regex list

            val merge'' :
              R.Defs.Regexes.regex list -> R.Defs.Regexes.regex list ->
              R.Defs.Regexes.regex list

            val merge :
              R.Defs.Regexes.regex list -> R.Defs.Regexes.regex list ->
              R.Defs.Regexes.regex list

            val mkIterApp' : R.Defs.Regexes.regex -> R.Defs.Regexes.regex list

            val canon : R.Defs.Regexes.regex -> R.Defs.Regexes.regex

            val fill_Table_all'' :
              TabTy.coq_Table -> R.Defs.Regexes.regex -> R.Ty.coq_Sigma list
              -> nat -> TabTy.coq_Table

            val fill_Table_all' :
              TabTy.coq_Table -> R.Defs.Regexes.regex -> R.Ty.coq_Sigma list
              -> nat -> TabTy.coq_Table

            val fill_Table_all :
              TabTy.coq_Table -> R.Defs.Regexes.regex -> R.Ty.coq_Sigma list
              -> nat -> TabTy.coq_Table

            val traverse_pos' : positive -> positive

            val traverse_pos : positive -> positive

            val fill_Table_all'_bin :
              TabTy.coq_Table -> R.Defs.Regexes.regex -> R.Ty.coq_Sigma list
              -> positive -> TabTy.coq_Table

            val fill_Table_all_bin :
              TabTy.coq_Table -> R.Defs.Regexes.regex -> R.Ty.coq_Sigma list
              -> positive -> TabTy.coq_Table
           end

          module Spec :
           sig
           end

          module Correct :
           sig
           end

          module Coq_binary :
           sig
           end
         end
       end

      module R :
       sig
        module Ty :
         sig
          type coq_Sigma = ALPHABET.coq_Sigma

          val coq_SigmaEnum : coq_Sigma list

          val coq_Sigma_dec : coq_Sigma -> coq_Sigma -> bool

          val compareT : coq_Sigma -> coq_Sigma -> comparison

          val ascii2Sigma : char -> coq_Sigma
         end

        module Defs :
         sig
          module T_as_UCT :
           sig
            type t = Ty.coq_Sigma

            val compare : Ty.coq_Sigma -> Ty.coq_Sigma -> comparison
           end

          module T_as_UOT :
           sig
            type t = T_as_UCT.t

            val compare : t -> t -> t compare0

            val eq_dec : t -> t -> bool
           end

          module SigFS :
           sig
            module X' :
             sig
              type t = T_as_UCT.t

              val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

              val compare : T_as_UCT.t -> T_as_UCT.t -> comparison
             end

            module MSet :
             sig
              module Raw :
               sig
                type elt = T_as_UCT.t

                type tree = TabT.R.Defs.SigFS.MSet.Raw.tree =
                | Leaf
                | Node of Z_as_Int.t * tree * T_as_UCT.t * tree

                val empty : tree

                val is_empty : tree -> bool

                val mem : T_as_UCT.t -> tree -> bool

                val min_elt : tree -> elt option

                val max_elt : tree -> elt option

                val choose : tree -> elt option

                val fold : (elt -> 'a1 -> 'a1) -> tree -> 'a1 -> 'a1

                val elements_aux : T_as_UCT.t list -> tree -> T_as_UCT.t list

                val elements : tree -> T_as_UCT.t list

                val rev_elements_aux :
                  T_as_UCT.t list -> tree -> T_as_UCT.t list

                val rev_elements : tree -> T_as_UCT.t list

                val cardinal : tree -> nat

                val maxdepth : tree -> nat

                val mindepth : tree -> nat

                val for_all : (elt -> bool) -> tree -> bool

                val exists_ : (elt -> bool) -> tree -> bool

                type enumeration = TabT.R.Defs.SigFS.MSet.Raw.enumeration =
                | End
                | More of elt * tree * enumeration

                val cons : tree -> enumeration -> enumeration

                val compare_more :
                  T_as_UCT.t -> (enumeration -> comparison) -> enumeration ->
                  comparison

                val compare_cont :
                  tree -> (enumeration -> comparison) -> enumeration ->
                  comparison

                val compare_end : enumeration -> comparison

                val compare : tree -> tree -> comparison

                val equal : tree -> tree -> bool

                val subsetl : (tree -> bool) -> T_as_UCT.t -> tree -> bool

                val subsetr : (tree -> bool) -> T_as_UCT.t -> tree -> bool

                val subset : tree -> tree -> bool

                type t = tree

                val height : t -> Z_as_Int.t

                val singleton : T_as_UCT.t -> tree

                val create : t -> T_as_UCT.t -> t -> tree

                val assert_false : t -> T_as_UCT.t -> t -> tree

                val bal : t -> T_as_UCT.t -> t -> tree

                val add : T_as_UCT.t -> tree -> tree

                val join : tree -> elt -> t -> t

                val remove_min : tree -> elt -> t -> t * elt

                val merge : tree -> tree -> tree

                val remove : T_as_UCT.t -> tree -> tree

                val concat : tree -> tree -> tree

                type triple = TabT.R.Defs.SigFS.MSet.Raw.triple = { t_left : 
                                                                    t;
                                                                    t_in : 
                                                                    bool;
                                                                    t_right : 
                                                                    t }

                val t_left : triple -> t

                val t_in : triple -> bool

                val t_right : triple -> t

                val split : T_as_UCT.t -> tree -> triple

                val inter : tree -> tree -> tree

                val diff : tree -> tree -> tree

                val union : tree -> tree -> tree

                val filter : (elt -> bool) -> tree -> tree

                val partition : (elt -> bool) -> t -> t * t

                val ltb_tree : T_as_UCT.t -> tree -> bool

                val gtb_tree : T_as_UCT.t -> tree -> bool

                val isok : tree -> bool

                module MX :
                 sig
                  module OrderTac :
                   sig
                    module OTF :
                     sig
                      type t = T_as_UCT.t

                      val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

                      val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
                     end

                    module TO :
                     sig
                      type t = T_as_UCT.t

                      val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

                      val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
                     end
                   end

                  val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                  val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                  val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
                 end

                type coq_R_min_elt = TabT.R.Defs.SigFS.MSet.Raw.coq_R_min_elt =
                | R_min_elt_0 of tree
                | R_min_elt_1 of tree * Z_as_Int.t * tree * T_as_UCT.t * tree
                | R_min_elt_2 of tree * Z_as_Int.t * tree * T_as_UCT.t * 
                   tree * Z_as_Int.t * tree * T_as_UCT.t * tree * elt option
                   * coq_R_min_elt

                type coq_R_max_elt = TabT.R.Defs.SigFS.MSet.Raw.coq_R_max_elt =
                | R_max_elt_0 of tree
                | R_max_elt_1 of tree * Z_as_Int.t * tree * T_as_UCT.t * tree
                | R_max_elt_2 of tree * Z_as_Int.t * tree * T_as_UCT.t * 
                   tree * Z_as_Int.t * tree * T_as_UCT.t * tree * elt option
                   * coq_R_max_elt

                module L :
                 sig
                  module MO :
                   sig
                    module OrderTac :
                     sig
                      module OTF :
                       sig
                        type t = T_as_UCT.t

                        val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

                        val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
                       end

                      module TO :
                       sig
                        type t = T_as_UCT.t

                        val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

                        val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
                       end
                     end

                    val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                    val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                    val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
                   end
                 end

                val flatten_e : enumeration -> elt list

                type coq_R_bal = TabT.R.Defs.SigFS.MSet.Raw.coq_R_bal =
                | R_bal_0 of t * T_as_UCT.t * t
                | R_bal_1 of t * T_as_UCT.t * t * Z_as_Int.t * tree
                   * T_as_UCT.t * tree
                | R_bal_2 of t * T_as_UCT.t * t * Z_as_Int.t * tree
                   * T_as_UCT.t * tree
                | R_bal_3 of t * T_as_UCT.t * t * Z_as_Int.t * tree
                   * T_as_UCT.t * tree * Z_as_Int.t * tree * T_as_UCT.t * 
                   tree
                | R_bal_4 of t * T_as_UCT.t * t
                | R_bal_5 of t * T_as_UCT.t * t * Z_as_Int.t * tree
                   * T_as_UCT.t * tree
                | R_bal_6 of t * T_as_UCT.t * t * Z_as_Int.t * tree
                   * T_as_UCT.t * tree
                | R_bal_7 of t * T_as_UCT.t * t * Z_as_Int.t * tree
                   * T_as_UCT.t * tree * Z_as_Int.t * tree * T_as_UCT.t * 
                   tree
                | R_bal_8 of t * T_as_UCT.t * t

                type coq_R_remove_min = TabT.R.Defs.SigFS.MSet.Raw.coq_R_remove_min =
                | R_remove_min_0 of tree * elt * t
                | R_remove_min_1 of tree * elt * t * Z_as_Int.t * tree
                   * T_as_UCT.t * tree * (t * elt) * coq_R_remove_min * 
                   t * elt

                type coq_R_merge = TabT.R.Defs.SigFS.MSet.Raw.coq_R_merge =
                | R_merge_0 of tree * tree
                | R_merge_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                   * tree
                | R_merge_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                   * tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * 
                   elt

                type coq_R_concat = TabT.R.Defs.SigFS.MSet.Raw.coq_R_concat =
                | R_concat_0 of tree * tree
                | R_concat_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                   * tree
                | R_concat_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                   * tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * 
                   elt

                type coq_R_inter = TabT.R.Defs.SigFS.MSet.Raw.coq_R_inter =
                | R_inter_0 of tree * tree
                | R_inter_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                   * tree
                | R_inter_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                   * tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * 
                   bool * t * tree * coq_R_inter * tree * coq_R_inter
                | R_inter_3 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                   * tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * 
                   bool * t * tree * coq_R_inter * tree * coq_R_inter

                type coq_R_diff = TabT.R.Defs.SigFS.MSet.Raw.coq_R_diff =
                | R_diff_0 of tree * tree
                | R_diff_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                   * tree
                | R_diff_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                   * tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * 
                   bool * t * tree * coq_R_diff * tree * coq_R_diff
                | R_diff_3 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                   * tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * 
                   bool * t * tree * coq_R_diff * tree * coq_R_diff

                type coq_R_union = TabT.R.Defs.SigFS.MSet.Raw.coq_R_union =
                | R_union_0 of tree * tree
                | R_union_1 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                   * tree
                | R_union_2 of tree * tree * Z_as_Int.t * tree * T_as_UCT.t
                   * tree * Z_as_Int.t * tree * T_as_UCT.t * tree * t * 
                   bool * t * tree * coq_R_union * tree * coq_R_union
               end

              module E :
               sig
                type t = T_as_UCT.t

                val compare : T_as_UCT.t -> T_as_UCT.t -> comparison

                val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
               end

              type elt = T_as_UCT.t

              type t_ =
                Raw.t
                (* singleton inductive, whose constructor was Mkt *)

              val this : t_ -> Raw.t

              type t = t_

              val mem : elt -> t -> bool

              val add : elt -> t -> t

              val remove : elt -> t -> t

              val singleton : elt -> t

              val union : t -> t -> t

              val inter : t -> t -> t

              val diff : t -> t -> t

              val equal : t -> t -> bool

              val subset : t -> t -> bool

              val empty : t

              val is_empty : t -> bool

              val elements : t -> elt list

              val choose : t -> elt option

              val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

              val cardinal : t -> nat

              val filter : (elt -> bool) -> t -> t

              val for_all : (elt -> bool) -> t -> bool

              val exists_ : (elt -> bool) -> t -> bool

              val partition : (elt -> bool) -> t -> t * t

              val eq_dec : t -> t -> bool

              val compare : t -> t -> comparison

              val min_elt : t -> elt option

              val max_elt : t -> elt option
             end

            type elt = T_as_UCT.t

            type t = MSet.t

            val empty : t

            val is_empty : t -> bool

            val mem : elt -> t -> bool

            val add : elt -> t -> t

            val singleton : elt -> t

            val remove : elt -> t -> t

            val union : t -> t -> t

            val inter : t -> t -> t

            val diff : t -> t -> t

            val eq_dec : t -> t -> bool

            val equal : t -> t -> bool

            val subset : t -> t -> bool

            val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

            val for_all : (elt -> bool) -> t -> bool

            val exists_ : (elt -> bool) -> t -> bool

            val filter : (elt -> bool) -> t -> t

            val partition : (elt -> bool) -> t -> t * t

            val cardinal : t -> nat

            val elements : t -> elt list

            val choose : t -> elt option

            module MF :
             sig
              val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
             end

            val min_elt : t -> elt option

            val max_elt : t -> elt option

            val compare : t -> t -> t compare0

            module E :
             sig
              type t = T_as_UCT.t

              val compare : T_as_UCT.t -> T_as_UCT.t -> T_as_UCT.t compare0

              val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
             end
           end

          module SigFSF :
           sig
            val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
           end

          module SigFM :
           sig
            module E :
             sig
              type t = T_as_UCT.t

              val compare : T_as_UCT.t -> T_as_UCT.t -> T_as_UCT.t compare0

              val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool
             end

            module Raw :
             sig
              type key = T_as_UCT.t

              type 'elt tree = 'elt TabT.R.Defs.SigFM.Raw.tree =
              | Leaf
              | Node of 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t

              val tree_rect :
                'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
                Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

              val tree_rec :
                'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
                Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

              val height : 'a1 tree -> Z_as_Int.t

              val cardinal : 'a1 tree -> nat

              val empty : 'a1 tree

              val is_empty : 'a1 tree -> bool

              val mem : T_as_UCT.t -> 'a1 tree -> bool

              val find : T_as_UCT.t -> 'a1 tree -> 'a1 option

              val create : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

              val assert_false :
                'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

              val bal : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

              val add : key -> 'a1 -> 'a1 tree -> 'a1 tree

              val remove_min :
                'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree * (key * 'a1)

              val merge : 'a1 tree -> 'a1 tree -> 'a1 tree

              val remove : T_as_UCT.t -> 'a1 tree -> 'a1 tree

              val join : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

              type 'elt triple = 'elt TabT.R.Defs.SigFM.Raw.triple = { 
              t_left : 'elt tree; t_opt : 'elt option; t_right : 'elt tree }

              val t_left : 'a1 triple -> 'a1 tree

              val t_opt : 'a1 triple -> 'a1 option

              val t_right : 'a1 triple -> 'a1 tree

              val split : T_as_UCT.t -> 'a1 tree -> 'a1 triple

              val concat : 'a1 tree -> 'a1 tree -> 'a1 tree

              val elements_aux :
                (key * 'a1) list -> 'a1 tree -> (key * 'a1) list

              val elements : 'a1 tree -> (key * 'a1) list

              val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

              type 'elt enumeration = 'elt TabT.R.Defs.SigFM.Raw.enumeration =
              | End
              | More of key * 'elt * 'elt tree * 'elt enumeration

              val enumeration_rect :
                'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 ->
                'a2) -> 'a1 enumeration -> 'a2

              val enumeration_rec :
                'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 ->
                'a2) -> 'a1 enumeration -> 'a2

              val cons : 'a1 tree -> 'a1 enumeration -> 'a1 enumeration

              val equal_more :
                ('a1 -> 'a1 -> bool) -> T_as_UCT.t -> 'a1 -> ('a1 enumeration
                -> bool) -> 'a1 enumeration -> bool

              val equal_cont :
                ('a1 -> 'a1 -> bool) -> 'a1 tree -> ('a1 enumeration -> bool)
                -> 'a1 enumeration -> bool

              val equal_end : 'a1 enumeration -> bool

              val equal : ('a1 -> 'a1 -> bool) -> 'a1 tree -> 'a1 tree -> bool

              val map : ('a1 -> 'a2) -> 'a1 tree -> 'a2 tree

              val mapi : (key -> 'a1 -> 'a2) -> 'a1 tree -> 'a2 tree

              val map_option :
                (key -> 'a1 -> 'a2 option) -> 'a1 tree -> 'a2 tree

              val map2_opt :
                (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3
                tree) -> ('a2 tree -> 'a3 tree) -> 'a1 tree -> 'a2 tree ->
                'a3 tree

              val map2 :
                ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 tree -> 'a2
                tree -> 'a3 tree

              module Proofs :
               sig
                module MX :
                 sig
                  module TO :
                   sig
                    type t = T_as_UCT.t
                   end

                  module IsTO :
                   sig
                   end

                  module OrderTac :
                   sig
                   end

                  val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                  val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                  val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
                 end

                module PX :
                 sig
                  module MO :
                   sig
                    module TO :
                     sig
                      type t = T_as_UCT.t
                     end

                    module IsTO :
                     sig
                     end

                    module OrderTac :
                     sig
                     end

                    val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                    val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                    val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
                   end
                 end

                module L :
                 sig
                  module MX :
                   sig
                    module TO :
                     sig
                      type t = T_as_UCT.t
                     end

                    module IsTO :
                     sig
                     end

                    module OrderTac :
                     sig
                     end

                    val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                    val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                    val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
                   end

                  module PX :
                   sig
                    module MO :
                     sig
                      module TO :
                       sig
                        type t = T_as_UCT.t
                       end

                      module IsTO :
                       sig
                       end

                      module OrderTac :
                       sig
                       end

                      val eq_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                      val lt_dec : T_as_UCT.t -> T_as_UCT.t -> bool

                      val eqb : T_as_UCT.t -> T_as_UCT.t -> bool
                     end
                   end

                  type key = T_as_UCT.t

                  type 'elt t = (T_as_UCT.t * 'elt) list

                  val empty : 'a1 t

                  val is_empty : 'a1 t -> bool

                  val mem : key -> 'a1 t -> bool

                  type 'elt coq_R_mem = 'elt TabT.R.Defs.SigFM.Raw.Proofs.L.coq_R_mem =
                  | R_mem_0 of 'elt t
                  | R_mem_1 of 'elt t * T_as_UCT.t * 'elt
                     * (T_as_UCT.t * 'elt) list
                  | R_mem_2 of 'elt t * T_as_UCT.t * 'elt
                     * (T_as_UCT.t * 'elt) list
                  | R_mem_3 of 'elt t * T_as_UCT.t * 'elt
                     * (T_as_UCT.t * 'elt) list * bool * 'elt coq_R_mem

                  val coq_R_mem_rect :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                    'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
                    -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                    -> __ -> __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1
                    -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> bool ->
                    'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 t -> bool -> 'a1
                    coq_R_mem -> 'a2

                  val coq_R_mem_rec :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                    'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
                    -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                    -> __ -> __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1
                    -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> bool ->
                    'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 t -> bool -> 'a1
                    coq_R_mem -> 'a2

                  val mem_rect :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                    'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
                    -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                    -> __ -> __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1
                    -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
                    'a2) -> 'a1 t -> 'a2

                  val mem_rec :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                    'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
                    -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                    -> __ -> __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1
                    -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
                    'a2) -> 'a1 t -> 'a2

                  val coq_R_mem_correct :
                    key -> 'a1 t -> bool -> 'a1 coq_R_mem

                  val find : key -> 'a1 t -> 'a1 option

                  type 'elt coq_R_find = 'elt TabT.R.Defs.SigFM.Raw.Proofs.L.coq_R_find =
                  | R_find_0 of 'elt t
                  | R_find_1 of 'elt t * T_as_UCT.t * 'elt
                     * (T_as_UCT.t * 'elt) list
                  | R_find_2 of 'elt t * T_as_UCT.t * 'elt
                     * (T_as_UCT.t * 'elt) list
                  | R_find_3 of 'elt t * T_as_UCT.t * 'elt
                     * (T_as_UCT.t * 'elt) list * 'elt option
                     * 'elt coq_R_find

                  val coq_R_find_rect :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                    'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
                    -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                    -> __ -> __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1
                    -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1
                    option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> 'a1 t -> 'a1
                    option -> 'a1 coq_R_find -> 'a2

                  val coq_R_find_rec :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                    'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
                    -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                    -> __ -> __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1
                    -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1
                    option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> 'a1 t -> 'a1
                    option -> 'a1 coq_R_find -> 'a2

                  val find_rect :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                    'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
                    -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                    -> __ -> __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1
                    -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
                    'a2) -> 'a1 t -> 'a2

                  val find_rec :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                    'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
                    -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                    -> __ -> __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1
                    -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
                    'a2) -> 'a1 t -> 'a2

                  val coq_R_find_correct :
                    key -> 'a1 t -> 'a1 option -> 'a1 coq_R_find

                  val add : key -> 'a1 -> 'a1 t -> 'a1 t

                  type 'elt coq_R_add = 'elt TabT.R.Defs.SigFM.Raw.Proofs.L.coq_R_add =
                  | R_add_0 of 'elt t
                  | R_add_1 of 'elt t * T_as_UCT.t * 'elt
                     * (T_as_UCT.t * 'elt) list
                  | R_add_2 of 'elt t * T_as_UCT.t * 'elt
                     * (T_as_UCT.t * 'elt) list
                  | R_add_3 of 'elt t * T_as_UCT.t * 'elt
                     * (T_as_UCT.t * 'elt) list * 'elt t * 'elt coq_R_add

                  val coq_R_add_rect :
                    key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __
                    -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                    (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1
                    t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __
                    -> __ -> __ -> 'a1 t -> 'a1 coq_R_add -> 'a2 -> 'a2) ->
                    'a1 t -> 'a1 t -> 'a1 coq_R_add -> 'a2

                  val coq_R_add_rec :
                    key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __
                    -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                    (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1
                    t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __
                    -> __ -> __ -> 'a1 t -> 'a1 coq_R_add -> 'a2 -> 'a2) ->
                    'a1 t -> 'a1 t -> 'a1 coq_R_add -> 'a2

                  val add_rect :
                    key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __
                    -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                    (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1
                    t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __
                    -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                  val add_rec :
                    key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __
                    -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1 ->
                    (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2) -> ('a1
                    t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __
                    -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                  val coq_R_add_correct :
                    key -> 'a1 -> 'a1 t -> 'a1 t -> 'a1 coq_R_add

                  val remove : key -> 'a1 t -> 'a1 t

                  type 'elt coq_R_remove = 'elt TabT.R.Defs.SigFM.Raw.Proofs.L.coq_R_remove =
                  | R_remove_0 of 'elt t
                  | R_remove_1 of 'elt t * T_as_UCT.t * 'elt
                     * (T_as_UCT.t * 'elt) list
                  | R_remove_2 of 'elt t * T_as_UCT.t * 'elt
                     * (T_as_UCT.t * 'elt) list
                  | R_remove_3 of 'elt t * T_as_UCT.t * 'elt
                     * (T_as_UCT.t * 'elt) list * 'elt t * 'elt coq_R_remove

                  val coq_R_remove_rect :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                    'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
                    -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                    -> __ -> __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1
                    -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1 t ->
                    'a1 coq_R_remove -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1
                    coq_R_remove -> 'a2

                  val coq_R_remove_rec :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                    'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
                    -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                    -> __ -> __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1
                    -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a1 t ->
                    'a1 coq_R_remove -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1
                    coq_R_remove -> 'a2

                  val remove_rect :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                    'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
                    -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                    -> __ -> __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1
                    -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
                    'a2) -> 'a1 t -> 'a2

                  val remove_rec :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t ->
                    'a1 -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2)
                    -> ('a1 t -> T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list
                    -> __ -> __ -> __ -> 'a2) -> ('a1 t -> T_as_UCT.t -> 'a1
                    -> (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 ->
                    'a2) -> 'a1 t -> 'a2

                  val coq_R_remove_correct :
                    key -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove

                  val elements : 'a1 t -> 'a1 t

                  val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

                  type ('elt, 'a) coq_R_fold = ('elt, 'a) TabT.R.Defs.SigFM.Raw.Proofs.L.coq_R_fold =
                  | R_fold_0 of 'elt t * 'a
                  | R_fold_1 of 'elt t * 'a * T_as_UCT.t * 'elt
                     * (T_as_UCT.t * 'elt) list * 'a * ('elt, 'a) coq_R_fold

                  val coq_R_fold_rect :
                    (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3)
                    -> ('a1 t -> 'a2 -> T_as_UCT.t -> 'a1 ->
                    (T_as_UCT.t * 'a1) list -> __ -> 'a2 -> ('a1, 'a2)
                    coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a2 -> ('a1,
                    'a2) coq_R_fold -> 'a3

                  val coq_R_fold_rec :
                    (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3)
                    -> ('a1 t -> 'a2 -> T_as_UCT.t -> 'a1 ->
                    (T_as_UCT.t * 'a1) list -> __ -> 'a2 -> ('a1, 'a2)
                    coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a2 -> ('a1,
                    'a2) coq_R_fold -> 'a3

                  val fold_rect :
                    (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3)
                    -> ('a1 t -> 'a2 -> T_as_UCT.t -> 'a1 ->
                    (T_as_UCT.t * 'a1) list -> __ -> 'a3 -> 'a3) -> 'a1 t ->
                    'a2 -> 'a3

                  val fold_rec :
                    (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3)
                    -> ('a1 t -> 'a2 -> T_as_UCT.t -> 'a1 ->
                    (T_as_UCT.t * 'a1) list -> __ -> 'a3 -> 'a3) -> 'a1 t ->
                    'a2 -> 'a3

                  val coq_R_fold_correct :
                    (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2 ->
                    ('a1, 'a2) coq_R_fold

                  val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool

                  type 'elt coq_R_equal = 'elt TabT.R.Defs.SigFM.Raw.Proofs.L.coq_R_equal =
                  | R_equal_0 of 'elt t * 'elt t
                  | R_equal_1 of 'elt t * 'elt t * T_as_UCT.t * 'elt
                     * (T_as_UCT.t * 'elt) list * T_as_UCT.t * 'elt
                     * (T_as_UCT.t * 'elt) list * bool * 'elt coq_R_equal
                  | R_equal_2 of 'elt t * 'elt t * T_as_UCT.t * 'elt
                     * (T_as_UCT.t * 'elt) list * T_as_UCT.t * 'elt
                     * (T_as_UCT.t * 'elt) list * T_as_UCT.t compare0
                  | R_equal_3 of 'elt t * 'elt t * 'elt t * 'elt t

                  val coq_R_equal_rect :
                    ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                    'a2) -> ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 ->
                    (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t -> 'a1 ->
                    (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> bool -> 'a1
                    coq_R_equal -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t ->
                    T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
                    T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
                    T_as_UCT.t compare0 -> __ -> __ -> 'a2) -> ('a1 t -> 'a1
                    t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2) -> 'a1 t ->
                    'a1 t -> bool -> 'a1 coq_R_equal -> 'a2

                  val coq_R_equal_rec :
                    ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                    'a2) -> ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 ->
                    (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t -> 'a1 ->
                    (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> bool -> 'a1
                    coq_R_equal -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t ->
                    T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
                    T_as_UCT.t -> 'a1 -> (T_as_UCT.t * 'a1) list -> __ ->
                    T_as_UCT.t compare0 -> __ -> __ -> 'a2) -> ('a1 t -> 'a1
                    t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2) -> 'a1 t ->
                    'a1 t -> bool -> 'a1 coq_R_equal -> 'a2

                  val equal_rect :
                    ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                    'a2) -> ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 ->
                    (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t -> 'a1 ->
                    (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 -> 'a2)
                    -> ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 ->
                    (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t -> 'a1 ->
                    (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t compare0 ->
                    __ -> __ -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1
                    t -> __ -> __ -> 'a2) -> 'a1 t -> 'a1 t -> 'a2

                  val equal_rec :
                    ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                    'a2) -> ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 ->
                    (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t -> 'a1 ->
                    (T_as_UCT.t * 'a1) list -> __ -> __ -> __ -> 'a2 -> 'a2)
                    -> ('a1 t -> 'a1 t -> T_as_UCT.t -> 'a1 ->
                    (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t -> 'a1 ->
                    (T_as_UCT.t * 'a1) list -> __ -> T_as_UCT.t compare0 ->
                    __ -> __ -> 'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1
                    t -> __ -> __ -> 'a2) -> 'a1 t -> 'a1 t -> 'a2

                  val coq_R_equal_correct :
                    ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool -> 'a1
                    coq_R_equal

                  val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

                  val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

                  val option_cons :
                    key -> 'a1 option -> (key * 'a1) list -> (key * 'a1) list

                  val map2_l :
                    ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a3 t

                  val map2_r :
                    ('a1 option -> 'a2 option -> 'a3 option) -> 'a2 t -> 'a3 t

                  val map2 :
                    ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2
                    t -> 'a3 t

                  val combine : 'a1 t -> 'a2 t -> ('a1 option * 'a2 option) t

                  val fold_right_pair :
                    ('a1 -> 'a2 -> 'a3 -> 'a3) -> ('a1 * 'a2) list -> 'a3 ->
                    'a3

                  val map2_alt :
                    ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2
                    t -> (key * 'a3) list

                  val at_least_one :
                    'a1 option -> 'a2 option -> ('a1 option * 'a2 option)
                    option

                  val at_least_one_then_f :
                    ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 option ->
                    'a2 option -> 'a3 option
                 end

                type 'elt coq_R_mem = 'elt TabT.R.Defs.SigFM.Raw.Proofs.coq_R_mem =
                | R_mem_0 of 'elt tree
                | R_mem_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t * bool * 'elt coq_R_mem
                | R_mem_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t
                | R_mem_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t * bool * 'elt coq_R_mem

                val coq_R_mem_rect :
                  T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                  __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> ('a1 tree ->
                  'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                  __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 ->
                  'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> bool -> 'a1
                  coq_R_mem -> 'a2 -> 'a2) -> 'a1 tree -> bool -> 'a1
                  coq_R_mem -> 'a2

                val coq_R_mem_rec :
                  T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                  __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> ('a1 tree ->
                  'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                  __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 ->
                  'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> bool -> 'a1
                  coq_R_mem -> 'a2 -> 'a2) -> 'a1 tree -> bool -> 'a1
                  coq_R_mem -> 'a2

                type 'elt coq_R_find = 'elt TabT.R.Defs.SigFM.Raw.Proofs.coq_R_find =
                | R_find_0 of 'elt tree
                | R_find_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t * 'elt option * 'elt coq_R_find
                | R_find_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t
                | R_find_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t * 'elt option * 'elt coq_R_find

                val coq_R_find_rect :
                  T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                  __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> ('a1
                  tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
                  __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key ->
                  'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
                  option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> 'a1 tree -> 'a1
                  option -> 'a1 coq_R_find -> 'a2

                val coq_R_find_rec :
                  T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                  __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> ('a1
                  tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
                  __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key ->
                  'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1
                  option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> 'a1 tree -> 'a1
                  option -> 'a1 coq_R_find -> 'a2

                type 'elt coq_R_bal = 'elt TabT.R.Defs.SigFM.Raw.Proofs.coq_R_bal =
                | R_bal_0 of 'elt tree * key * 'elt * 'elt tree
                | R_bal_1 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                   * key * 'elt * 'elt tree * Z_as_Int.t
                | R_bal_2 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                   * key * 'elt * 'elt tree * Z_as_Int.t
                | R_bal_3 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                   * key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * 
                   key * 'elt * 'elt tree * Z_as_Int.t
                | R_bal_4 of 'elt tree * key * 'elt * 'elt tree
                | R_bal_5 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                   * key * 'elt * 'elt tree * Z_as_Int.t
                | R_bal_6 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                   * key * 'elt * 'elt tree * Z_as_Int.t
                | R_bal_7 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                   * key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * 
                   key * 'elt * 'elt tree * Z_as_Int.t
                | R_bal_8 of 'elt tree * key * 'elt * 'elt tree

                val coq_R_bal_rect :
                  ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ ->
                  'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ ->
                  'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                  __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree ->
                  __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree ->
                  key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key ->
                  'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree
                  -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2) ->
                  ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __
                  -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __
                  -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key ->
                  'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key
                  -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> __ ->
                  'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ ->
                  __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 ->
                  'a1 tree -> Z_as_Int.t -> __ -> 'a2) -> ('a1 tree -> key ->
                  'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a2) -> 'a1 tree
                  -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_bal ->
                  'a2

                val coq_R_bal_rec :
                  ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ ->
                  'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ ->
                  'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                  __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree ->
                  __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree ->
                  key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key ->
                  'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree
                  -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2) ->
                  ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __
                  -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __
                  -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key ->
                  'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key
                  -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> __ ->
                  'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ ->
                  __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 ->
                  'a1 tree -> Z_as_Int.t -> __ -> 'a2) -> ('a1 tree -> key ->
                  'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a2) -> 'a1 tree
                  -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_bal ->
                  'a2

                type 'elt coq_R_add = 'elt TabT.R.Defs.SigFM.Raw.Proofs.coq_R_add =
                | R_add_0 of 'elt tree
                | R_add_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t * 'elt tree * 'elt coq_R_add
                | R_add_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t
                | R_add_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t * 'elt tree * 'elt coq_R_add

                val coq_R_add_rect :
                  key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                  __ -> 'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1 tree
                  -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                  -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
                  -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree ->
                  'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1
                  coq_R_add -> 'a2

                val coq_R_add_rec :
                  key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                  __ -> 'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1 tree
                  -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                  -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
                  -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree ->
                  'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1
                  coq_R_add -> 'a2

                type 'elt coq_R_remove_min = 'elt TabT.R.Defs.SigFM.Raw.Proofs.coq_R_remove_min =
                | R_remove_min_0 of 'elt tree * key * 'elt * 'elt tree
                | R_remove_min_1 of 'elt tree * key * 'elt * 'elt tree
                   * 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t
                   * ('elt tree * (key * 'elt)) * 'elt coq_R_remove_min
                   * 'elt tree * (key * 'elt)

                val coq_R_remove_min_rect :
                  ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1
                  tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1 ->
                  'a1 tree -> Z_as_Int.t -> __ -> ('a1 tree * (key * 'a1)) ->
                  'a1 coq_R_remove_min -> 'a2 -> 'a1 tree -> (key * 'a1) ->
                  __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> ('a1
                  tree * (key * 'a1)) -> 'a1 coq_R_remove_min -> 'a2

                val coq_R_remove_min_rec :
                  ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1
                  tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1 ->
                  'a1 tree -> Z_as_Int.t -> __ -> ('a1 tree * (key * 'a1)) ->
                  'a1 coq_R_remove_min -> 'a2 -> 'a1 tree -> (key * 'a1) ->
                  __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> ('a1
                  tree * (key * 'a1)) -> 'a1 coq_R_remove_min -> 'a2

                type 'elt coq_R_merge = 'elt TabT.R.Defs.SigFM.Raw.Proofs.coq_R_merge =
                | R_merge_0 of 'elt tree * 'elt tree
                | R_merge_1 of 'elt tree * 'elt tree * 'elt tree * key * 
                   'elt * 'elt tree * Z_as_Int.t
                | R_merge_2 of 'elt tree * 'elt tree * 'elt tree * key * 
                   'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 
                   'elt * 'elt tree * Z_as_Int.t * 'elt tree * (key * 'elt)
                   * key * 'elt

                val coq_R_merge_rect :
                  ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
                  __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree ->
                  (key * 'a1) -> __ -> key -> 'a1 -> __ -> 'a2) -> 'a1 tree
                  -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_merge -> 'a2

                val coq_R_merge_rec :
                  ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
                  __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree ->
                  (key * 'a1) -> __ -> key -> 'a1 -> __ -> 'a2) -> 'a1 tree
                  -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_merge -> 'a2

                type 'elt coq_R_remove = 'elt TabT.R.Defs.SigFM.Raw.Proofs.coq_R_remove =
                | R_remove_0 of 'elt tree
                | R_remove_1 of 'elt tree * 'elt tree * key * 'elt
                   * 'elt tree * Z_as_Int.t * 'elt tree * 'elt coq_R_remove
                | R_remove_2 of 'elt tree * 'elt tree * key * 'elt
                   * 'elt tree * Z_as_Int.t
                | R_remove_3 of 'elt tree * 'elt tree * key * 'elt
                   * 'elt tree * Z_as_Int.t * 'elt tree * 'elt coq_R_remove

                val coq_R_remove_rect :
                  T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                  __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> ('a1
                  tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
                  __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key ->
                  'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree
                  -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 tree
                  -> 'a1 coq_R_remove -> 'a2

                val coq_R_remove_rec :
                  T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                  __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> ('a1
                  tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
                  __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key ->
                  'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree
                  -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 tree
                  -> 'a1 coq_R_remove -> 'a2

                type 'elt coq_R_concat = 'elt TabT.R.Defs.SigFM.Raw.Proofs.coq_R_concat =
                | R_concat_0 of 'elt tree * 'elt tree
                | R_concat_1 of 'elt tree * 'elt tree * 'elt tree * key
                   * 'elt * 'elt tree * Z_as_Int.t
                | R_concat_2 of 'elt tree * 'elt tree * 'elt tree * key
                   * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 
                   'elt * 'elt tree * Z_as_Int.t * 'elt tree * (key * 'elt)

                val coq_R_concat_rect :
                  ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
                  __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree ->
                  (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1
                  tree -> 'a1 coq_R_concat -> 'a2

                val coq_R_concat_rec :
                  ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
                  __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree ->
                  (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1
                  tree -> 'a1 coq_R_concat -> 'a2

                type 'elt coq_R_split = 'elt TabT.R.Defs.SigFM.Raw.Proofs.coq_R_split =
                | R_split_0 of 'elt tree
                | R_split_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t * 'elt triple * 'elt coq_R_split * 'elt tree
                   * 'elt option * 'elt tree
                | R_split_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t
                | R_split_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t * 'elt triple * 'elt coq_R_split * 'elt tree
                   * 'elt option * 'elt tree

                val coq_R_split_rect :
                  T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                  __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree ->
                  'a1 option -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                  __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
                  tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 triple -> 'a1
                  coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option -> 'a1 tree ->
                  __ -> 'a2) -> 'a1 tree -> 'a1 triple -> 'a1 coq_R_split ->
                  'a2

                val coq_R_split_rec :
                  T_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                  __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree ->
                  'a1 option -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                  __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
                  tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 triple -> 'a1
                  coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option -> 'a1 tree ->
                  __ -> 'a2) -> 'a1 tree -> 'a1 triple -> 'a1 coq_R_split ->
                  'a2

                type ('elt, 'x) coq_R_map_option = ('elt, 'x) TabT.R.Defs.SigFM.Raw.Proofs.coq_R_map_option =
                | R_map_option_0 of 'elt tree
                | R_map_option_1 of 'elt tree * 'elt tree * key * 'elt
                   * 'elt tree * Z_as_Int.t * 'x * 'x tree
                   * ('elt, 'x) coq_R_map_option * 'x tree
                   * ('elt, 'x) coq_R_map_option
                | R_map_option_2 of 'elt tree * 'elt tree * key * 'elt
                   * 'elt tree * Z_as_Int.t * 'x tree
                   * ('elt, 'x) coq_R_map_option * 'x tree
                   * ('elt, 'x) coq_R_map_option

                val coq_R_map_option_rect :
                  (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) ->
                  ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> 'a2 -> __ -> 'a2 tree -> ('a1, 'a2)
                  coq_R_map_option -> 'a3 -> 'a2 tree -> ('a1, 'a2)
                  coq_R_map_option -> 'a3 -> 'a3) -> ('a1 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a2
                  tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2 tree ->
                  ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> 'a1 tree ->
                  'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3

                val coq_R_map_option_rec :
                  (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) ->
                  ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> 'a2 -> __ -> 'a2 tree -> ('a1, 'a2)
                  coq_R_map_option -> 'a3 -> 'a2 tree -> ('a1, 'a2)
                  coq_R_map_option -> 'a3 -> 'a3) -> ('a1 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a2
                  tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2 tree ->
                  ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> 'a1 tree ->
                  'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3

                type ('elt, 'x0, 'x) coq_R_map2_opt = ('elt, 'x0, 'x) TabT.R.Defs.SigFM.Raw.Proofs.coq_R_map2_opt =
                | R_map2_opt_0 of 'elt tree * 'x0 tree
                | R_map2_opt_1 of 'elt tree * 'x0 tree * 'elt tree * 
                   key * 'elt * 'elt tree * Z_as_Int.t
                | R_map2_opt_2 of 'elt tree * 'x0 tree * 'elt tree * 
                   key * 'elt * 'elt tree * Z_as_Int.t * 'x0 tree * key * 
                   'x0 * 'x0 tree * Z_as_Int.t * 'x0 tree * 'x0 option
                   * 'x0 tree * 'x * 'x tree * ('elt, 'x0, 'x) coq_R_map2_opt
                   * 'x tree * ('elt, 'x0, 'x) coq_R_map2_opt
                | R_map2_opt_3 of 'elt tree * 'x0 tree * 'elt tree * 
                   key * 'elt * 'elt tree * Z_as_Int.t * 'x0 tree * key * 
                   'x0 * 'x0 tree * Z_as_Int.t * 'x0 tree * 'x0 option
                   * 'x0 tree * 'x tree * ('elt, 'x0, 'x) coq_R_map2_opt
                   * 'x tree * ('elt, 'x0, 'x) coq_R_map2_opt

                val coq_R_map2_opt_rect :
                  (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree ->
                  'a3 tree) -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2
                  tree -> __ -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a4) ->
                  ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree
                  -> Z_as_Int.t -> __ -> 'a2 tree -> key -> 'a2 -> 'a2 tree
                  -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2 option -> 'a2 tree
                  -> __ -> 'a3 -> __ -> 'a3 tree -> ('a1, 'a2, 'a3)
                  coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
                  coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree ->
                  'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                  'a2 tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ ->
                  'a2 tree -> 'a2 option -> 'a2 tree -> __ -> __ -> 'a3 tree
                  -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree ->
                  ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1 tree
                  -> 'a2 tree -> 'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt
                  -> 'a4

                val coq_R_map2_opt_rec :
                  (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree ->
                  'a3 tree) -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2
                  tree -> __ -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a4) ->
                  ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree
                  -> Z_as_Int.t -> __ -> 'a2 tree -> key -> 'a2 -> 'a2 tree
                  -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2 option -> 'a2 tree
                  -> __ -> 'a3 -> __ -> 'a3 tree -> ('a1, 'a2, 'a3)
                  coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
                  coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree ->
                  'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                  'a2 tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ ->
                  'a2 tree -> 'a2 option -> 'a2 tree -> __ -> __ -> 'a3 tree
                  -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree ->
                  ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1 tree
                  -> 'a2 tree -> 'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt
                  -> 'a4

                val fold' :
                  (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

                val flatten_e : 'a1 enumeration -> (key * 'a1) list
               end
             end

            type 'elt bst =
              'elt Raw.tree
              (* singleton inductive, whose constructor was Bst *)

            val this : 'a1 bst -> 'a1 Raw.tree

            type 'elt t = 'elt bst

            type key = T_as_UCT.t

            val empty : 'a1 t

            val is_empty : 'a1 t -> bool

            val add : key -> 'a1 -> 'a1 t -> 'a1 t

            val remove : key -> 'a1 t -> 'a1 t

            val mem : key -> 'a1 t -> bool

            val find : key -> 'a1 t -> 'a1 option

            val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

            val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

            val map2 :
              ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t ->
              'a3 t

            val elements : 'a1 t -> (key * 'a1) list

            val cardinal : 'a1 t -> nat

            val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

            val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool
           end

          module SigFMF :
           sig
            val eqb : T_as_UCT.t -> T_as_UCT.t -> bool

            val coq_In_dec : 'a1 SigFM.t -> SigFM.key -> bool
           end

          module Strings :
           sig
            type coq_String = Ty.coq_Sigma list

            val coq_String_dec : coq_String -> coq_String -> bool

            val rm_empty : coq_String list -> Ty.coq_Sigma list list
           end

          module Regexes :
           sig
            type regex = TabT.R.Defs.Regexes.regex =
            | EmptySet
            | EmptyStr
            | Char of Ty.coq_Sigma
            | App of regex * regex
            | Union of regex * regex
            | Star of regex

            val regex_rect :
              'a1 -> 'a1 -> (Ty.coq_Sigma -> 'a1) -> (regex -> 'a1 -> regex
              -> 'a1 -> 'a1) -> (regex -> 'a1 -> regex -> 'a1 -> 'a1) ->
              (regex -> 'a1 -> 'a1) -> regex -> 'a1

            val regex_rec :
              'a1 -> 'a1 -> (Ty.coq_Sigma -> 'a1) -> (regex -> 'a1 -> regex
              -> 'a1 -> 'a1) -> (regex -> 'a1 -> regex -> 'a1 -> 'a1) ->
              (regex -> 'a1 -> 'a1) -> regex -> 'a1

            val regex_dec : regex -> regex -> bool

            val regex_eq : regex -> regex -> bool

            val nullable' : regex -> bool

            val nullable : regex -> bool

            val derivative : Ty.coq_Sigma -> regex -> regex

            val derivative_list : Ty.coq_Sigma list -> regex -> regex

            val re_compare : regex -> regex -> comparison
           end

          module Coq_regex_as_UCT :
           sig
            type t = Regexes.regex

            val compare : Regexes.regex -> Regexes.regex -> comparison
           end

          module Coq_regex_as_UOT :
           sig
            type t = Coq_regex_as_UCT.t

            val compare : t -> t -> t compare0

            val eq_dec : t -> t -> bool
           end

          module Coq_reFS :
           sig
            module X' :
             sig
              type t = Coq_regex_as_UCT.t

              val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

              val compare :
                Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> comparison
             end

            module MSet :
             sig
              module Raw :
               sig
                type elt = Coq_regex_as_UCT.t

                type tree = TabT.R.Defs.Coq_reFS.MSet.Raw.tree =
                | Leaf
                | Node of Z_as_Int.t * tree * Coq_regex_as_UCT.t * tree

                val empty : tree

                val is_empty : tree -> bool

                val mem : Coq_regex_as_UCT.t -> tree -> bool

                val min_elt : tree -> elt option

                val max_elt : tree -> elt option

                val choose : tree -> elt option

                val fold : (elt -> 'a1 -> 'a1) -> tree -> 'a1 -> 'a1

                val elements_aux :
                  Coq_regex_as_UCT.t list -> tree -> Coq_regex_as_UCT.t list

                val elements : tree -> Coq_regex_as_UCT.t list

                val rev_elements_aux :
                  Coq_regex_as_UCT.t list -> tree -> Coq_regex_as_UCT.t list

                val rev_elements : tree -> Coq_regex_as_UCT.t list

                val cardinal : tree -> nat

                val maxdepth : tree -> nat

                val mindepth : tree -> nat

                val for_all : (elt -> bool) -> tree -> bool

                val exists_ : (elt -> bool) -> tree -> bool

                type enumeration = TabT.R.Defs.Coq_reFS.MSet.Raw.enumeration =
                | End
                | More of elt * tree * enumeration

                val cons : tree -> enumeration -> enumeration

                val compare_more :
                  Coq_regex_as_UCT.t -> (enumeration -> comparison) ->
                  enumeration -> comparison

                val compare_cont :
                  tree -> (enumeration -> comparison) -> enumeration ->
                  comparison

                val compare_end : enumeration -> comparison

                val compare : tree -> tree -> comparison

                val equal : tree -> tree -> bool

                val subsetl :
                  (tree -> bool) -> Coq_regex_as_UCT.t -> tree -> bool

                val subsetr :
                  (tree -> bool) -> Coq_regex_as_UCT.t -> tree -> bool

                val subset : tree -> tree -> bool

                type t = tree

                val height : t -> Z_as_Int.t

                val singleton : Coq_regex_as_UCT.t -> tree

                val create : t -> Coq_regex_as_UCT.t -> t -> tree

                val assert_false : t -> Coq_regex_as_UCT.t -> t -> tree

                val bal : t -> Coq_regex_as_UCT.t -> t -> tree

                val add : Coq_regex_as_UCT.t -> tree -> tree

                val join : tree -> elt -> t -> t

                val remove_min : tree -> elt -> t -> t * elt

                val merge : tree -> tree -> tree

                val remove : Coq_regex_as_UCT.t -> tree -> tree

                val concat : tree -> tree -> tree

                type triple = TabT.R.Defs.Coq_reFS.MSet.Raw.triple = { 
                t_left : t; t_in : bool; t_right : t }

                val t_left : triple -> t

                val t_in : triple -> bool

                val t_right : triple -> t

                val split : Coq_regex_as_UCT.t -> tree -> triple

                val inter : tree -> tree -> tree

                val diff : tree -> tree -> tree

                val union : tree -> tree -> tree

                val filter : (elt -> bool) -> tree -> tree

                val partition : (elt -> bool) -> t -> t * t

                val ltb_tree : Coq_regex_as_UCT.t -> tree -> bool

                val gtb_tree : Coq_regex_as_UCT.t -> tree -> bool

                val isok : tree -> bool

                module MX :
                 sig
                  module OrderTac :
                   sig
                    module OTF :
                     sig
                      type t = Coq_regex_as_UCT.t

                      val compare :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> comparison

                      val eq_dec :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                     end

                    module TO :
                     sig
                      type t = Coq_regex_as_UCT.t

                      val compare :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> comparison

                      val eq_dec :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                     end
                   end

                  val eq_dec :
                    Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                  val lt_dec :
                    Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                  val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                 end

                type coq_R_min_elt = TabT.R.Defs.Coq_reFS.MSet.Raw.coq_R_min_elt =
                | R_min_elt_0 of tree
                | R_min_elt_1 of tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree
                | R_min_elt_2 of tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree * elt option * coq_R_min_elt

                type coq_R_max_elt = TabT.R.Defs.Coq_reFS.MSet.Raw.coq_R_max_elt =
                | R_max_elt_0 of tree
                | R_max_elt_1 of tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree
                | R_max_elt_2 of tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree * elt option * coq_R_max_elt

                module L :
                 sig
                  module MO :
                   sig
                    module OrderTac :
                     sig
                      module OTF :
                       sig
                        type t = Coq_regex_as_UCT.t

                        val compare :
                          Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t ->
                          comparison

                        val eq_dec :
                          Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                       end

                      module TO :
                       sig
                        type t = Coq_regex_as_UCT.t

                        val compare :
                          Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t ->
                          comparison

                        val eq_dec :
                          Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                       end
                     end

                    val eq_dec :
                      Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                    val lt_dec :
                      Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                    val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                   end
                 end

                val flatten_e : enumeration -> elt list

                type coq_R_bal = TabT.R.Defs.Coq_reFS.MSet.Raw.coq_R_bal =
                | R_bal_0 of t * Coq_regex_as_UCT.t * t
                | R_bal_1 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * 
                   tree * Coq_regex_as_UCT.t * tree
                | R_bal_2 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * 
                   tree * Coq_regex_as_UCT.t * tree
                | R_bal_3 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * 
                   tree * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree
                | R_bal_4 of t * Coq_regex_as_UCT.t * t
                | R_bal_5 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * 
                   tree * Coq_regex_as_UCT.t * tree
                | R_bal_6 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * 
                   tree * Coq_regex_as_UCT.t * tree
                | R_bal_7 of t * Coq_regex_as_UCT.t * t * Z_as_Int.t * 
                   tree * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree
                | R_bal_8 of t * Coq_regex_as_UCT.t * t

                type coq_R_remove_min = TabT.R.Defs.Coq_reFS.MSet.Raw.coq_R_remove_min =
                | R_remove_min_0 of tree * elt * t
                | R_remove_min_1 of tree * elt * t * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree * (t * elt) * coq_R_remove_min
                   * t * elt

                type coq_R_merge = TabT.R.Defs.Coq_reFS.MSet.Raw.coq_R_merge =
                | R_merge_0 of tree * tree
                | R_merge_1 of tree * tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree
                | R_merge_2 of tree * tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree * t * elt

                type coq_R_concat = TabT.R.Defs.Coq_reFS.MSet.Raw.coq_R_concat =
                | R_concat_0 of tree * tree
                | R_concat_1 of tree * tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree
                | R_concat_2 of tree * tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree * t * elt

                type coq_R_inter = TabT.R.Defs.Coq_reFS.MSet.Raw.coq_R_inter =
                | R_inter_0 of tree * tree
                | R_inter_1 of tree * tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree
                | R_inter_2 of tree * tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree * t * bool * t * tree
                   * coq_R_inter * tree * coq_R_inter
                | R_inter_3 of tree * tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree * t * bool * t * tree
                   * coq_R_inter * tree * coq_R_inter

                type coq_R_diff = TabT.R.Defs.Coq_reFS.MSet.Raw.coq_R_diff =
                | R_diff_0 of tree * tree
                | R_diff_1 of tree * tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree
                | R_diff_2 of tree * tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree * t * bool * t * tree
                   * coq_R_diff * tree * coq_R_diff
                | R_diff_3 of tree * tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree * t * bool * t * tree
                   * coq_R_diff * tree * coq_R_diff

                type coq_R_union = TabT.R.Defs.Coq_reFS.MSet.Raw.coq_R_union =
                | R_union_0 of tree * tree
                | R_union_1 of tree * tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree
                | R_union_2 of tree * tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree * Z_as_Int.t * tree
                   * Coq_regex_as_UCT.t * tree * t * bool * t * tree
                   * coq_R_union * tree * coq_R_union
               end

              module E :
               sig
                type t = Coq_regex_as_UCT.t

                val compare :
                  Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> comparison

                val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
               end

              type elt = Coq_regex_as_UCT.t

              type t_ =
                Raw.t
                (* singleton inductive, whose constructor was Mkt *)

              val this : t_ -> Raw.t

              type t = t_

              val mem : elt -> t -> bool

              val add : elt -> t -> t

              val remove : elt -> t -> t

              val singleton : elt -> t

              val union : t -> t -> t

              val inter : t -> t -> t

              val diff : t -> t -> t

              val equal : t -> t -> bool

              val subset : t -> t -> bool

              val empty : t

              val is_empty : t -> bool

              val elements : t -> elt list

              val choose : t -> elt option

              val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

              val cardinal : t -> nat

              val filter : (elt -> bool) -> t -> t

              val for_all : (elt -> bool) -> t -> bool

              val exists_ : (elt -> bool) -> t -> bool

              val partition : (elt -> bool) -> t -> t * t

              val eq_dec : t -> t -> bool

              val compare : t -> t -> comparison

              val min_elt : t -> elt option

              val max_elt : t -> elt option
             end

            type elt = Coq_regex_as_UCT.t

            type t = MSet.t

            val empty : t

            val is_empty : t -> bool

            val mem : elt -> t -> bool

            val add : elt -> t -> t

            val singleton : elt -> t

            val remove : elt -> t -> t

            val union : t -> t -> t

            val inter : t -> t -> t

            val diff : t -> t -> t

            val eq_dec : t -> t -> bool

            val equal : t -> t -> bool

            val subset : t -> t -> bool

            val fold : (elt -> 'a1 -> 'a1) -> t -> 'a1 -> 'a1

            val for_all : (elt -> bool) -> t -> bool

            val exists_ : (elt -> bool) -> t -> bool

            val filter : (elt -> bool) -> t -> t

            val partition : (elt -> bool) -> t -> t * t

            val cardinal : t -> nat

            val elements : t -> elt list

            val choose : t -> elt option

            module MF :
             sig
              val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
             end

            val min_elt : t -> elt option

            val max_elt : t -> elt option

            val compare : t -> t -> t compare0

            module E :
             sig
              type t = Coq_regex_as_UCT.t

              val compare :
                Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t ->
                Coq_regex_as_UCT.t compare0

              val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
             end
           end

          module Coq_reFSF :
           sig
            val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
           end

          module Coq_reFM :
           sig
            module E :
             sig
              type t = Coq_regex_as_UCT.t

              val compare :
                Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t ->
                Coq_regex_as_UCT.t compare0

              val eq_dec : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
             end

            module Raw :
             sig
              type key = Coq_regex_as_UCT.t

              type 'elt tree = 'elt TabT.R.Defs.Coq_reFM.Raw.tree =
              | Leaf
              | Node of 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t

              val tree_rect :
                'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
                Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

              val tree_rec :
                'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
                Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

              val height : 'a1 tree -> Z_as_Int.t

              val cardinal : 'a1 tree -> nat

              val empty : 'a1 tree

              val is_empty : 'a1 tree -> bool

              val mem : Coq_regex_as_UCT.t -> 'a1 tree -> bool

              val find : Coq_regex_as_UCT.t -> 'a1 tree -> 'a1 option

              val create : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

              val assert_false :
                'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

              val bal : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

              val add : key -> 'a1 -> 'a1 tree -> 'a1 tree

              val remove_min :
                'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree * (key * 'a1)

              val merge : 'a1 tree -> 'a1 tree -> 'a1 tree

              val remove : Coq_regex_as_UCT.t -> 'a1 tree -> 'a1 tree

              val join : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

              type 'elt triple = 'elt TabT.R.Defs.Coq_reFM.Raw.triple = { 
              t_left : 'elt tree; t_opt : 'elt option; t_right : 'elt tree }

              val t_left : 'a1 triple -> 'a1 tree

              val t_opt : 'a1 triple -> 'a1 option

              val t_right : 'a1 triple -> 'a1 tree

              val split : Coq_regex_as_UCT.t -> 'a1 tree -> 'a1 triple

              val concat : 'a1 tree -> 'a1 tree -> 'a1 tree

              val elements_aux :
                (key * 'a1) list -> 'a1 tree -> (key * 'a1) list

              val elements : 'a1 tree -> (key * 'a1) list

              val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

              type 'elt enumeration = 'elt TabT.R.Defs.Coq_reFM.Raw.enumeration =
              | End
              | More of key * 'elt * 'elt tree * 'elt enumeration

              val enumeration_rect :
                'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 ->
                'a2) -> 'a1 enumeration -> 'a2

              val enumeration_rec :
                'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 ->
                'a2) -> 'a1 enumeration -> 'a2

              val cons : 'a1 tree -> 'a1 enumeration -> 'a1 enumeration

              val equal_more :
                ('a1 -> 'a1 -> bool) -> Coq_regex_as_UCT.t -> 'a1 -> ('a1
                enumeration -> bool) -> 'a1 enumeration -> bool

              val equal_cont :
                ('a1 -> 'a1 -> bool) -> 'a1 tree -> ('a1 enumeration -> bool)
                -> 'a1 enumeration -> bool

              val equal_end : 'a1 enumeration -> bool

              val equal : ('a1 -> 'a1 -> bool) -> 'a1 tree -> 'a1 tree -> bool

              val map : ('a1 -> 'a2) -> 'a1 tree -> 'a2 tree

              val mapi : (key -> 'a1 -> 'a2) -> 'a1 tree -> 'a2 tree

              val map_option :
                (key -> 'a1 -> 'a2 option) -> 'a1 tree -> 'a2 tree

              val map2_opt :
                (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3
                tree) -> ('a2 tree -> 'a3 tree) -> 'a1 tree -> 'a2 tree ->
                'a3 tree

              val map2 :
                ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 tree -> 'a2
                tree -> 'a3 tree

              module Proofs :
               sig
                module MX :
                 sig
                  module TO :
                   sig
                    type t = Coq_regex_as_UCT.t
                   end

                  module IsTO :
                   sig
                   end

                  module OrderTac :
                   sig
                   end

                  val eq_dec :
                    Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                  val lt_dec :
                    Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                  val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                 end

                module PX :
                 sig
                  module MO :
                   sig
                    module TO :
                     sig
                      type t = Coq_regex_as_UCT.t
                     end

                    module IsTO :
                     sig
                     end

                    module OrderTac :
                     sig
                     end

                    val eq_dec :
                      Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                    val lt_dec :
                      Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                    val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                   end
                 end

                module L :
                 sig
                  module MX :
                   sig
                    module TO :
                     sig
                      type t = Coq_regex_as_UCT.t
                     end

                    module IsTO :
                     sig
                     end

                    module OrderTac :
                     sig
                     end

                    val eq_dec :
                      Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                    val lt_dec :
                      Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                    val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                   end

                  module PX :
                   sig
                    module MO :
                     sig
                      module TO :
                       sig
                        type t = Coq_regex_as_UCT.t
                       end

                      module IsTO :
                       sig
                       end

                      module OrderTac :
                       sig
                       end

                      val eq_dec :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                      val lt_dec :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

                      val eqb :
                        Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool
                     end
                   end

                  type key = Coq_regex_as_UCT.t

                  type 'elt t = (Coq_regex_as_UCT.t * 'elt) list

                  val empty : 'a1 t

                  val is_empty : 'a1 t -> bool

                  val mem : key -> 'a1 t -> bool

                  type 'elt coq_R_mem = 'elt TabT.R.Defs.Coq_reFM.Raw.Proofs.L.coq_R_mem =
                  | R_mem_0 of 'elt t
                  | R_mem_1 of 'elt t * Coq_regex_as_UCT.t * 'elt
                     * (Coq_regex_as_UCT.t * 'elt) list
                  | R_mem_2 of 'elt t * Coq_regex_as_UCT.t * 'elt
                     * (Coq_regex_as_UCT.t * 'elt) list
                  | R_mem_3 of 'elt t * Coq_regex_as_UCT.t * 'elt
                     * (Coq_regex_as_UCT.t * 'elt) list * bool
                     * 'elt coq_R_mem

                  val coq_R_mem_rect :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 ->
                    'a2) -> 'a1 t -> bool -> 'a1 coq_R_mem -> 'a2

                  val coq_R_mem_rec :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 ->
                    'a2) -> 'a1 t -> bool -> 'a1 coq_R_mem -> 'a2

                  val mem_rect :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                  val mem_rec :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                  val coq_R_mem_correct :
                    key -> 'a1 t -> bool -> 'a1 coq_R_mem

                  val find : key -> 'a1 t -> 'a1 option

                  type 'elt coq_R_find = 'elt TabT.R.Defs.Coq_reFM.Raw.Proofs.L.coq_R_find =
                  | R_find_0 of 'elt t
                  | R_find_1 of 'elt t * Coq_regex_as_UCT.t * 'elt
                     * (Coq_regex_as_UCT.t * 'elt) list
                  | R_find_2 of 'elt t * Coq_regex_as_UCT.t * 'elt
                     * (Coq_regex_as_UCT.t * 'elt) list
                  | R_find_3 of 'elt t * Coq_regex_as_UCT.t * 'elt
                     * (Coq_regex_as_UCT.t * 'elt) list * 'elt option
                     * 'elt coq_R_find

                  val coq_R_find_rect :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find ->
                    'a2 -> 'a2) -> 'a1 t -> 'a1 option -> 'a1 coq_R_find ->
                    'a2

                  val coq_R_find_rec :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a1 option -> 'a1 coq_R_find ->
                    'a2 -> 'a2) -> 'a1 t -> 'a1 option -> 'a1 coq_R_find ->
                    'a2

                  val find_rect :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                  val find_rec :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                  val coq_R_find_correct :
                    key -> 'a1 t -> 'a1 option -> 'a1 coq_R_find

                  val add : key -> 'a1 -> 'a1 t -> 'a1 t

                  type 'elt coq_R_add = 'elt TabT.R.Defs.Coq_reFM.Raw.Proofs.L.coq_R_add =
                  | R_add_0 of 'elt t
                  | R_add_1 of 'elt t * Coq_regex_as_UCT.t * 'elt
                     * (Coq_regex_as_UCT.t * 'elt) list
                  | R_add_2 of 'elt t * Coq_regex_as_UCT.t * 'elt
                     * (Coq_regex_as_UCT.t * 'elt) list
                  | R_add_3 of 'elt t * Coq_regex_as_UCT.t * 'elt
                     * (Coq_regex_as_UCT.t * 'elt) list * 'elt t
                     * 'elt coq_R_add

                  val coq_R_add_rect :
                    key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_add -> 'a2
                    -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_add -> 'a2

                  val coq_R_add_rec :
                    key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_add -> 'a2
                    -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_add -> 'a2

                  val add_rect :
                    key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                  val add_rec :
                    key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                  val coq_R_add_correct :
                    key -> 'a1 -> 'a1 t -> 'a1 t -> 'a1 coq_R_add

                  val remove : key -> 'a1 t -> 'a1 t

                  type 'elt coq_R_remove = 'elt TabT.R.Defs.Coq_reFM.Raw.Proofs.L.coq_R_remove =
                  | R_remove_0 of 'elt t
                  | R_remove_1 of 'elt t * Coq_regex_as_UCT.t * 'elt
                     * (Coq_regex_as_UCT.t * 'elt) list
                  | R_remove_2 of 'elt t * Coq_regex_as_UCT.t * 'elt
                     * (Coq_regex_as_UCT.t * 'elt) list
                  | R_remove_3 of 'elt t * Coq_regex_as_UCT.t * 'elt
                     * (Coq_regex_as_UCT.t * 'elt) list * 'elt t
                     * 'elt coq_R_remove

                  val coq_R_remove_rect :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_remove ->
                    'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove -> 'a2

                  val coq_R_remove_rec :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a1 t -> 'a1 coq_R_remove ->
                    'a2 -> 'a2) -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove -> 'a2

                  val remove_rect :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                  val remove_rec :
                    key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2) -> ('a1 t ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2 -> 'a2) -> 'a1 t -> 'a2

                  val coq_R_remove_correct :
                    key -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove

                  val elements : 'a1 t -> 'a1 t

                  val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

                  type ('elt, 'a) coq_R_fold = ('elt, 'a) TabT.R.Defs.Coq_reFM.Raw.Proofs.L.coq_R_fold =
                  | R_fold_0 of 'elt t * 'a
                  | R_fold_1 of 'elt t * 'a * Coq_regex_as_UCT.t * 'elt
                     * (Coq_regex_as_UCT.t * 'elt) list * 'a
                     * ('elt, 'a) coq_R_fold

                  val coq_R_fold_rect :
                    (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3)
                    -> ('a1 t -> 'a2 -> Coq_regex_as_UCT.t -> 'a1 ->
                    (Coq_regex_as_UCT.t * 'a1) list -> __ -> 'a2 -> ('a1,
                    'a2) coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a2 ->
                    ('a1, 'a2) coq_R_fold -> 'a3

                  val coq_R_fold_rec :
                    (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3)
                    -> ('a1 t -> 'a2 -> Coq_regex_as_UCT.t -> 'a1 ->
                    (Coq_regex_as_UCT.t * 'a1) list -> __ -> 'a2 -> ('a1,
                    'a2) coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a2 ->
                    ('a1, 'a2) coq_R_fold -> 'a3

                  val fold_rect :
                    (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3)
                    -> ('a1 t -> 'a2 -> Coq_regex_as_UCT.t -> 'a1 ->
                    (Coq_regex_as_UCT.t * 'a1) list -> __ -> 'a3 -> 'a3) ->
                    'a1 t -> 'a2 -> 'a3

                  val fold_rec :
                    (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3)
                    -> ('a1 t -> 'a2 -> Coq_regex_as_UCT.t -> 'a1 ->
                    (Coq_regex_as_UCT.t * 'a1) list -> __ -> 'a3 -> 'a3) ->
                    'a1 t -> 'a2 -> 'a3

                  val coq_R_fold_correct :
                    (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2 ->
                    ('a1, 'a2) coq_R_fold

                  val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool

                  type 'elt coq_R_equal = 'elt TabT.R.Defs.Coq_reFM.Raw.Proofs.L.coq_R_equal =
                  | R_equal_0 of 'elt t * 'elt t
                  | R_equal_1 of 'elt t * 'elt t * Coq_regex_as_UCT.t * 
                     'elt * (Coq_regex_as_UCT.t * 'elt) list
                     * Coq_regex_as_UCT.t * 'elt
                     * (Coq_regex_as_UCT.t * 'elt) list * bool
                     * 'elt coq_R_equal
                  | R_equal_2 of 'elt t * 'elt t * Coq_regex_as_UCT.t * 
                     'elt * (Coq_regex_as_UCT.t * 'elt) list
                     * Coq_regex_as_UCT.t * 'elt
                     * (Coq_regex_as_UCT.t * 'elt) list
                     * Coq_regex_as_UCT.t compare0
                  | R_equal_3 of 'elt t * 'elt t * 'elt t * 'elt t

                  val coq_R_equal_rect :
                    ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                    'a2) -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                    (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> bool -> 'a1 coq_R_equal -> 'a2
                    -> 'a2) -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1
                    -> (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> Coq_regex_as_UCT.t compare0 -> __ -> __ ->
                    'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ ->
                    __ -> 'a2) -> 'a1 t -> 'a1 t -> bool -> 'a1 coq_R_equal
                    -> 'a2

                  val coq_R_equal_rec :
                    ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                    'a2) -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                    (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> bool -> 'a1 coq_R_equal -> 'a2
                    -> 'a2) -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1
                    -> (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> Coq_regex_as_UCT.t compare0 -> __ -> __ ->
                    'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ ->
                    __ -> 'a2) -> 'a1 t -> 'a1 t -> bool -> 'a1 coq_R_equal
                    -> 'a2

                  val equal_rect :
                    ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                    'a2) -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                    (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t
                    -> Coq_regex_as_UCT.t -> 'a1 ->
                    (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> Coq_regex_as_UCT.t compare0 -> __ -> __ ->
                    'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ ->
                    __ -> 'a2) -> 'a1 t -> 'a1 t -> 'a2

                  val equal_rec :
                    ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ ->
                    'a2) -> ('a1 t -> 'a1 t -> Coq_regex_as_UCT.t -> 'a1 ->
                    (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> __ -> __ -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t
                    -> Coq_regex_as_UCT.t -> 'a1 ->
                    (Coq_regex_as_UCT.t * 'a1) list -> __ ->
                    Coq_regex_as_UCT.t -> 'a1 -> (Coq_regex_as_UCT.t * 'a1)
                    list -> __ -> Coq_regex_as_UCT.t compare0 -> __ -> __ ->
                    'a2) -> ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ ->
                    __ -> 'a2) -> 'a1 t -> 'a1 t -> 'a2

                  val coq_R_equal_correct :
                    ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool -> 'a1
                    coq_R_equal

                  val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

                  val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

                  val option_cons :
                    key -> 'a1 option -> (key * 'a1) list -> (key * 'a1) list

                  val map2_l :
                    ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a3 t

                  val map2_r :
                    ('a1 option -> 'a2 option -> 'a3 option) -> 'a2 t -> 'a3 t

                  val map2 :
                    ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2
                    t -> 'a3 t

                  val combine : 'a1 t -> 'a2 t -> ('a1 option * 'a2 option) t

                  val fold_right_pair :
                    ('a1 -> 'a2 -> 'a3 -> 'a3) -> ('a1 * 'a2) list -> 'a3 ->
                    'a3

                  val map2_alt :
                    ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2
                    t -> (key * 'a3) list

                  val at_least_one :
                    'a1 option -> 'a2 option -> ('a1 option * 'a2 option)
                    option

                  val at_least_one_then_f :
                    ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 option ->
                    'a2 option -> 'a3 option
                 end

                type 'elt coq_R_mem = 'elt TabT.R.Defs.Coq_reFM.Raw.Proofs.coq_R_mem =
                | R_mem_0 of 'elt tree
                | R_mem_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t * bool * 'elt coq_R_mem
                | R_mem_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t
                | R_mem_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t * bool * 'elt coq_R_mem

                val coq_R_mem_rect :
                  Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree
                  -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                  -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> ('a1
                  tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
                  __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key ->
                  'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> bool ->
                  'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 tree -> bool -> 'a1
                  coq_R_mem -> 'a2

                val coq_R_mem_rec :
                  Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree
                  -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                  -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> ('a1
                  tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
                  __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key ->
                  'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> bool ->
                  'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 tree -> bool -> 'a1
                  coq_R_mem -> 'a2

                type 'elt coq_R_find = 'elt TabT.R.Defs.Coq_reFM.Raw.Proofs.coq_R_find =
                | R_find_0 of 'elt tree
                | R_find_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t * 'elt option * 'elt coq_R_find
                | R_find_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t
                | R_find_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t * 'elt option * 'elt coq_R_find

                val coq_R_find_rect :
                  Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree
                  -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                  -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2)
                  -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                  __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> 'a1
                  tree -> 'a1 option -> 'a1 coq_R_find -> 'a2

                val coq_R_find_rec :
                  Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree
                  -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                  -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2)
                  -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                  __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> 'a1
                  tree -> 'a1 option -> 'a1 coq_R_find -> 'a2

                type 'elt coq_R_bal = 'elt TabT.R.Defs.Coq_reFM.Raw.Proofs.coq_R_bal =
                | R_bal_0 of 'elt tree * key * 'elt * 'elt tree
                | R_bal_1 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                   * key * 'elt * 'elt tree * Z_as_Int.t
                | R_bal_2 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                   * key * 'elt * 'elt tree * Z_as_Int.t
                | R_bal_3 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                   * key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * 
                   key * 'elt * 'elt tree * Z_as_Int.t
                | R_bal_4 of 'elt tree * key * 'elt * 'elt tree
                | R_bal_5 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                   * key * 'elt * 'elt tree * Z_as_Int.t
                | R_bal_6 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                   * key * 'elt * 'elt tree * Z_as_Int.t
                | R_bal_7 of 'elt tree * key * 'elt * 'elt tree * 'elt tree
                   * key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * 
                   key * 'elt * 'elt tree * Z_as_Int.t
                | R_bal_8 of 'elt tree * key * 'elt * 'elt tree

                val coq_R_bal_rect :
                  ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ ->
                  'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ ->
                  'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                  __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree ->
                  __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree ->
                  key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key ->
                  'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree
                  -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2) ->
                  ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __
                  -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __
                  -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key ->
                  'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key
                  -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> __ ->
                  'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ ->
                  __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 ->
                  'a1 tree -> Z_as_Int.t -> __ -> 'a2) -> ('a1 tree -> key ->
                  'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a2) -> 'a1 tree
                  -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_bal ->
                  'a2

                val coq_R_bal_rec :
                  ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ ->
                  'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ ->
                  'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                  __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree ->
                  __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> __ -> 'a2) -> ('a1 tree ->
                  key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree -> key ->
                  'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree
                  -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a2) ->
                  ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __
                  -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __
                  -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key ->
                  'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key
                  -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> __ ->
                  'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ ->
                  __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 ->
                  'a1 tree -> Z_as_Int.t -> __ -> 'a2) -> ('a1 tree -> key ->
                  'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a2) -> 'a1 tree
                  -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_bal ->
                  'a2

                type 'elt coq_R_add = 'elt TabT.R.Defs.Coq_reFM.Raw.Proofs.coq_R_add =
                | R_add_0 of 'elt tree
                | R_add_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t * 'elt tree * 'elt coq_R_add
                | R_add_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t
                | R_add_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t * 'elt tree * 'elt coq_R_add

                val coq_R_add_rect :
                  key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                  __ -> 'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1 tree
                  -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                  -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
                  -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree ->
                  'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1
                  coq_R_add -> 'a2

                val coq_R_add_rec :
                  key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                  __ -> 'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1 tree
                  -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                  -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
                  -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree ->
                  'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1
                  coq_R_add -> 'a2

                type 'elt coq_R_remove_min = 'elt TabT.R.Defs.Coq_reFM.Raw.Proofs.coq_R_remove_min =
                | R_remove_min_0 of 'elt tree * key * 'elt * 'elt tree
                | R_remove_min_1 of 'elt tree * key * 'elt * 'elt tree
                   * 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t
                   * ('elt tree * (key * 'elt)) * 'elt coq_R_remove_min
                   * 'elt tree * (key * 'elt)

                val coq_R_remove_min_rect :
                  ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1
                  tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1 ->
                  'a1 tree -> Z_as_Int.t -> __ -> ('a1 tree * (key * 'a1)) ->
                  'a1 coq_R_remove_min -> 'a2 -> 'a1 tree -> (key * 'a1) ->
                  __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> ('a1
                  tree * (key * 'a1)) -> 'a1 coq_R_remove_min -> 'a2

                val coq_R_remove_min_rec :
                  ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1
                  tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1 ->
                  'a1 tree -> Z_as_Int.t -> __ -> ('a1 tree * (key * 'a1)) ->
                  'a1 coq_R_remove_min -> 'a2 -> 'a1 tree -> (key * 'a1) ->
                  __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> ('a1
                  tree * (key * 'a1)) -> 'a1 coq_R_remove_min -> 'a2

                type 'elt coq_R_merge = 'elt TabT.R.Defs.Coq_reFM.Raw.Proofs.coq_R_merge =
                | R_merge_0 of 'elt tree * 'elt tree
                | R_merge_1 of 'elt tree * 'elt tree * 'elt tree * key * 
                   'elt * 'elt tree * Z_as_Int.t
                | R_merge_2 of 'elt tree * 'elt tree * 'elt tree * key * 
                   'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 
                   'elt * 'elt tree * Z_as_Int.t * 'elt tree * (key * 'elt)
                   * key * 'elt

                val coq_R_merge_rect :
                  ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
                  __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree ->
                  (key * 'a1) -> __ -> key -> 'a1 -> __ -> 'a2) -> 'a1 tree
                  -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_merge -> 'a2

                val coq_R_merge_rec :
                  ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
                  __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree ->
                  (key * 'a1) -> __ -> key -> 'a1 -> __ -> 'a2) -> 'a1 tree
                  -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_merge -> 'a2

                type 'elt coq_R_remove = 'elt TabT.R.Defs.Coq_reFM.Raw.Proofs.coq_R_remove =
                | R_remove_0 of 'elt tree
                | R_remove_1 of 'elt tree * 'elt tree * key * 'elt
                   * 'elt tree * Z_as_Int.t * 'elt tree * 'elt coq_R_remove
                | R_remove_2 of 'elt tree * 'elt tree * key * 'elt
                   * 'elt tree * Z_as_Int.t
                | R_remove_3 of 'elt tree * 'elt tree * key * 'elt
                   * 'elt tree * Z_as_Int.t * 'elt tree * 'elt coq_R_remove

                val coq_R_remove_rect :
                  Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree
                  -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                  -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2)
                  -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                  __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> 'a1
                  tree -> 'a1 tree -> 'a1 coq_R_remove -> 'a2

                val coq_R_remove_rec :
                  Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree
                  -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                  -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2)
                  -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
                  __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> 'a1
                  tree -> 'a1 tree -> 'a1 coq_R_remove -> 'a2

                type 'elt coq_R_concat = 'elt TabT.R.Defs.Coq_reFM.Raw.Proofs.coq_R_concat =
                | R_concat_0 of 'elt tree * 'elt tree
                | R_concat_1 of 'elt tree * 'elt tree * 'elt tree * key
                   * 'elt * 'elt tree * Z_as_Int.t
                | R_concat_2 of 'elt tree * 'elt tree * 'elt tree * key
                   * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 
                   'elt * 'elt tree * Z_as_Int.t * 'elt tree * (key * 'elt)

                val coq_R_concat_rect :
                  ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
                  __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree ->
                  (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1
                  tree -> 'a1 coq_R_concat -> 'a2

                val coq_R_concat_rec :
                  ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
                  tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
                  __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> 'a1 tree ->
                  (key * 'a1) -> __ -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1
                  tree -> 'a1 coq_R_concat -> 'a2

                type 'elt coq_R_split = 'elt TabT.R.Defs.Coq_reFM.Raw.Proofs.coq_R_split =
                | R_split_0 of 'elt tree
                | R_split_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t * 'elt triple * 'elt coq_R_split * 'elt tree
                   * 'elt option * 'elt tree
                | R_split_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t
                | R_split_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
                   * Z_as_Int.t * 'elt triple * 'elt coq_R_split * 'elt tree
                   * 'elt option * 'elt tree

                val coq_R_split_rect :
                  Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree
                  -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                  -> __ -> __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1
                  tree -> 'a1 option -> 'a1 tree -> __ -> 'a2) -> ('a1 tree
                  -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                  -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
                  -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 triple
                  -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option -> 'a1
                  tree -> __ -> 'a2) -> 'a1 tree -> 'a1 triple -> 'a1
                  coq_R_split -> 'a2

                val coq_R_split_rec :
                  Coq_regex_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1 tree
                  -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                  -> __ -> __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1
                  tree -> 'a1 option -> 'a1 tree -> __ -> 'a2) -> ('a1 tree
                  -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
                  -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1
                  -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 triple
                  -> 'a1 coq_R_split -> 'a2 -> 'a1 tree -> 'a1 option -> 'a1
                  tree -> __ -> 'a2) -> 'a1 tree -> 'a1 triple -> 'a1
                  coq_R_split -> 'a2

                type ('elt, 'x) coq_R_map_option = ('elt, 'x) TabT.R.Defs.Coq_reFM.Raw.Proofs.coq_R_map_option =
                | R_map_option_0 of 'elt tree
                | R_map_option_1 of 'elt tree * 'elt tree * key * 'elt
                   * 'elt tree * Z_as_Int.t * 'x * 'x tree
                   * ('elt, 'x) coq_R_map_option * 'x tree
                   * ('elt, 'x) coq_R_map_option
                | R_map_option_2 of 'elt tree * 'elt tree * key * 'elt
                   * 'elt tree * Z_as_Int.t * 'x tree
                   * ('elt, 'x) coq_R_map_option * 'x tree
                   * ('elt, 'x) coq_R_map_option

                val coq_R_map_option_rect :
                  (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) ->
                  ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> 'a2 -> __ -> 'a2 tree -> ('a1, 'a2)
                  coq_R_map_option -> 'a3 -> 'a2 tree -> ('a1, 'a2)
                  coq_R_map_option -> 'a3 -> 'a3) -> ('a1 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a2
                  tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2 tree ->
                  ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> 'a1 tree ->
                  'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3

                val coq_R_map_option_rec :
                  (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) ->
                  ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
                  Z_as_Int.t -> __ -> 'a2 -> __ -> 'a2 tree -> ('a1, 'a2)
                  coq_R_map_option -> 'a3 -> 'a2 tree -> ('a1, 'a2)
                  coq_R_map_option -> 'a3 -> 'a3) -> ('a1 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a2
                  tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a2 tree ->
                  ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) -> 'a1 tree ->
                  'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3

                type ('elt, 'x0, 'x) coq_R_map2_opt = ('elt, 'x0, 'x) TabT.R.Defs.Coq_reFM.Raw.Proofs.coq_R_map2_opt =
                | R_map2_opt_0 of 'elt tree * 'x0 tree
                | R_map2_opt_1 of 'elt tree * 'x0 tree * 'elt tree * 
                   key * 'elt * 'elt tree * Z_as_Int.t
                | R_map2_opt_2 of 'elt tree * 'x0 tree * 'elt tree * 
                   key * 'elt * 'elt tree * Z_as_Int.t * 'x0 tree * key * 
                   'x0 * 'x0 tree * Z_as_Int.t * 'x0 tree * 'x0 option
                   * 'x0 tree * 'x * 'x tree * ('elt, 'x0, 'x) coq_R_map2_opt
                   * 'x tree * ('elt, 'x0, 'x) coq_R_map2_opt
                | R_map2_opt_3 of 'elt tree * 'x0 tree * 'elt tree * 
                   key * 'elt * 'elt tree * Z_as_Int.t * 'x0 tree * key * 
                   'x0 * 'x0 tree * Z_as_Int.t * 'x0 tree * 'x0 option
                   * 'x0 tree * 'x tree * ('elt, 'x0, 'x) coq_R_map2_opt
                   * 'x tree * ('elt, 'x0, 'x) coq_R_map2_opt

                val coq_R_map2_opt_rect :
                  (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree ->
                  'a3 tree) -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2
                  tree -> __ -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a4) ->
                  ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree
                  -> Z_as_Int.t -> __ -> 'a2 tree -> key -> 'a2 -> 'a2 tree
                  -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2 option -> 'a2 tree
                  -> __ -> 'a3 -> __ -> 'a3 tree -> ('a1, 'a2, 'a3)
                  coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
                  coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree ->
                  'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                  'a2 tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ ->
                  'a2 tree -> 'a2 option -> 'a2 tree -> __ -> __ -> 'a3 tree
                  -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree ->
                  ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1 tree
                  -> 'a2 tree -> 'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt
                  -> 'a4

                val coq_R_map2_opt_rec :
                  (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree ->
                  'a3 tree) -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2
                  tree -> __ -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree ->
                  key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a4) ->
                  ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree
                  -> Z_as_Int.t -> __ -> 'a2 tree -> key -> 'a2 -> 'a2 tree
                  -> Z_as_Int.t -> __ -> 'a2 tree -> 'a2 option -> 'a2 tree
                  -> __ -> 'a3 -> __ -> 'a3 tree -> ('a1, 'a2, 'a3)
                  coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2, 'a3)
                  coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree -> 'a2 tree ->
                  'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
                  'a2 tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ ->
                  'a2 tree -> 'a2 option -> 'a2 tree -> __ -> __ -> 'a3 tree
                  -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree ->
                  ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1 tree
                  -> 'a2 tree -> 'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt
                  -> 'a4

                val fold' :
                  (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

                val flatten_e : 'a1 enumeration -> (key * 'a1) list
               end
             end

            type 'elt bst =
              'elt Raw.tree
              (* singleton inductive, whose constructor was Bst *)

            val this : 'a1 bst -> 'a1 Raw.tree

            type 'elt t = 'elt bst

            type key = Coq_regex_as_UCT.t

            val empty : 'a1 t

            val is_empty : 'a1 t -> bool

            val add : key -> 'a1 -> 'a1 t -> 'a1 t

            val remove : key -> 'a1 t -> 'a1 t

            val mem : key -> 'a1 t -> bool

            val find : key -> 'a1 t -> 'a1 option

            val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

            val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

            val map2 :
              ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t ->
              'a3 t

            val elements : 'a1 t -> (key * 'a1) list

            val cardinal : 'a1 t -> nat

            val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

            val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool
           end

          module Coq_reFMF :
           sig
            val eqb : Coq_regex_as_UCT.t -> Coq_regex_as_UCT.t -> bool

            val coq_In_dec : 'a1 Coq_reFM.t -> Coq_reFM.key -> bool
           end

          module MatchSpec :
           sig
           end

          module MatchSpecLemmas :
           sig
           end

          module Notations :
           sig
           end

          module Helpers :
           sig
            val coq_Plus : Regexes.regex -> Regexes.regex

            val coq_IterUnion : Regexes.regex list -> Regexes.regex

            val coq_IterApp : Regexes.regex list -> Regexes.regex

            val coq_Optional : Regexes.regex -> Regexes.regex

            val coq_REString : Strings.coq_String -> Regexes.regex
           end
         end
       end

      module Ty :
       sig
        module D :
         sig
          module CoreDefs :
           sig
            val char_set :
              TabT.R.Defs.Regexes.regex -> TabT.R.Ty.coq_Sigma list

            val regex_depth : TabT.R.Defs.Regexes.regex -> nat

            val regex_length : TabT.R.Defs.Regexes.regex -> nat

            val coq_Brzozowski_bound' : nat -> positive

            val coq_Brzozowski_bound : TabT.R.Defs.Regexes.regex -> positive

            val fin_states : TabT.R.Defs.Coq_reFS.t -> TabT.R.Defs.Coq_reFS.t

            type coq_DFA =
              (TabT.R.Defs.Regexes.regex * TabT.TabTy.coq_Table) * TabT.R.Defs.Coq_reFS.t

            val defDFA : coq_DFA

            val coq_DFAtransition : TabT.R.Ty.coq_Sigma -> coq_DFA -> coq_DFA

            val coq_DFAtransition_list :
              TabT.R.Ty.coq_Sigma list -> coq_DFA -> coq_DFA

            val coq_DFAaccepting : coq_DFA -> bool

            val coq_DFAaccepts :
              TabT.R.Defs.Strings.coq_String -> coq_DFA -> bool

            val regex2dfa : TabT.R.Defs.Regexes.regex -> coq_DFA

            val dfa2regex : coq_DFA -> TabT.R.Defs.Regexes.regex
           end

          module Correct :
           sig
            module Mat :
             sig
              val exp_matchb :
                TabT.R.Defs.Strings.coq_String -> TabT.R.Defs.Regexes.regex
                -> bool
             end
           end
         end

        type coq_Label = LABELS.coq_Label

        val defLabel : coq_Label

        val coq_Label_eq_dec : coq_Label -> coq_Label -> bool

        type coq_Pointer = R.Defs.Regexes.regex

        val defPointer : coq_Pointer

        type coq_Delta = TabT.TabTy.coq_Table * TabT.R.Defs.Coq_reFS.t

        val defDelta : TabT.TabTy.coq_Table * TabT.TabTy.Coq_reFS.t

        type coq_State = coq_Pointer * coq_Delta

        val defState :
          coq_Pointer * (TabT.TabTy.coq_Table * TabT.TabTy.Coq_reFS.t)

        val transition : R.Ty.coq_Sigma -> coq_State -> coq_State

        val transition_list : R.Ty.coq_Sigma list -> coq_State -> coq_State

        val accepts : R.Defs.Strings.coq_String -> coq_State -> bool

        val accepting : coq_State -> bool

        val init_state : R.Defs.Regexes.regex -> coq_State

        val init_state_inv : coq_State -> R.Defs.Regexes.regex

        val pointer_compare : coq_Pointer -> coq_Pointer -> comparison

        val pos2list : positive -> bool list

        val list2pos : bool list -> positive

        val int2list : z -> bool list

        val list2int : bool list -> z

        type index = z

        val index0 : index

        val index_eq_dec : index -> index -> bool

        val init_index : nat -> index

        val index2list : index -> bool list

        val list2index : bool list -> index

        val incr : index -> index

        val decr : index -> index
       end

      module Defs :
       sig
        module Pointer_as_UCT :
         sig
          type t = Ty.coq_Pointer

          val compare : Ty.coq_Pointer -> Ty.coq_Pointer -> comparison

          val coq_Pointer_eq_dec : Ty.coq_Pointer -> Ty.coq_Pointer -> bool
         end

        module Coredefs :
         sig
          type coq_Prefix = R.Defs.Strings.coq_String

          type coq_Suffix = R.Defs.Strings.coq_String

          type coq_Token = Ty.coq_Label * coq_Prefix

          type coq_Rule = Ty.coq_Label * R.Defs.Regexes.regex

          type sRule = Ty.coq_Label * Ty.coq_State
         end

        module MaxMunchSpec :
         sig
         end

        module Corollaries :
         sig
          val ru_dec : Coredefs.coq_Rule -> Coredefs.coq_Rule -> bool
         end
       end
     end

    module MemTy :
     sig
      module Pointer_as_UOT :
       sig
        type t = STT.Defs.Pointer_as_UCT.t

        val compare : t -> t -> t compare0

        val eq_dec : t -> t -> bool
       end

      module FM :
       sig
        module E :
         sig
          type t = STT.Defs.Pointer_as_UCT.t

          val compare :
            STT.Defs.Pointer_as_UCT.t -> STT.Defs.Pointer_as_UCT.t ->
            STT.Defs.Pointer_as_UCT.t compare0

          val eq_dec :
            STT.Defs.Pointer_as_UCT.t -> STT.Defs.Pointer_as_UCT.t -> bool
         end

        module Raw :
         sig
          type key = STT.Defs.Pointer_as_UCT.t

          type 'elt tree =
          | Leaf
          | Node of 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t

          val tree_rect :
            'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
            Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

          val tree_rec :
            'a2 -> ('a1 tree -> 'a2 -> key -> 'a1 -> 'a1 tree -> 'a2 ->
            Z_as_Int.t -> 'a2) -> 'a1 tree -> 'a2

          val height : 'a1 tree -> Z_as_Int.t

          val cardinal : 'a1 tree -> nat

          val empty : 'a1 tree

          val is_empty : 'a1 tree -> bool

          val mem : STT.Defs.Pointer_as_UCT.t -> 'a1 tree -> bool

          val find : STT.Defs.Pointer_as_UCT.t -> 'a1 tree -> 'a1 option

          val create : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

          val assert_false : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

          val bal : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

          val add : key -> 'a1 -> 'a1 tree -> 'a1 tree

          val remove_min :
            'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree * (key * 'a1)

          val merge : 'a1 tree -> 'a1 tree -> 'a1 tree

          val remove : STT.Defs.Pointer_as_UCT.t -> 'a1 tree -> 'a1 tree

          val join : 'a1 tree -> key -> 'a1 -> 'a1 tree -> 'a1 tree

          type 'elt triple = { t_left : 'elt tree; t_opt : 'elt option;
                               t_right : 'elt tree }

          val t_left : 'a1 triple -> 'a1 tree

          val t_opt : 'a1 triple -> 'a1 option

          val t_right : 'a1 triple -> 'a1 tree

          val split : STT.Defs.Pointer_as_UCT.t -> 'a1 tree -> 'a1 triple

          val concat : 'a1 tree -> 'a1 tree -> 'a1 tree

          val elements_aux : (key * 'a1) list -> 'a1 tree -> (key * 'a1) list

          val elements : 'a1 tree -> (key * 'a1) list

          val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

          type 'elt enumeration =
          | End
          | More of key * 'elt * 'elt tree * 'elt enumeration

          val enumeration_rect :
            'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 -> 'a2)
            -> 'a1 enumeration -> 'a2

          val enumeration_rec :
            'a2 -> (key -> 'a1 -> 'a1 tree -> 'a1 enumeration -> 'a2 -> 'a2)
            -> 'a1 enumeration -> 'a2

          val cons : 'a1 tree -> 'a1 enumeration -> 'a1 enumeration

          val equal_more :
            ('a1 -> 'a1 -> bool) -> STT.Defs.Pointer_as_UCT.t -> 'a1 -> ('a1
            enumeration -> bool) -> 'a1 enumeration -> bool

          val equal_cont :
            ('a1 -> 'a1 -> bool) -> 'a1 tree -> ('a1 enumeration -> bool) ->
            'a1 enumeration -> bool

          val equal_end : 'a1 enumeration -> bool

          val equal : ('a1 -> 'a1 -> bool) -> 'a1 tree -> 'a1 tree -> bool

          val map : ('a1 -> 'a2) -> 'a1 tree -> 'a2 tree

          val mapi : (key -> 'a1 -> 'a2) -> 'a1 tree -> 'a2 tree

          val map_option : (key -> 'a1 -> 'a2 option) -> 'a1 tree -> 'a2 tree

          val map2_opt :
            (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3
            tree) -> ('a2 tree -> 'a3 tree) -> 'a1 tree -> 'a2 tree -> 'a3
            tree

          val map2 :
            ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 tree -> 'a2 tree
            -> 'a3 tree

          module Proofs :
           sig
            module MX :
             sig
              module TO :
               sig
                type t = STT.Defs.Pointer_as_UCT.t
               end

              module IsTO :
               sig
               end

              module OrderTac :
               sig
               end

              val eq_dec :
                STT.Defs.Pointer_as_UCT.t -> STT.Defs.Pointer_as_UCT.t -> bool

              val lt_dec :
                STT.Defs.Pointer_as_UCT.t -> STT.Defs.Pointer_as_UCT.t -> bool

              val eqb :
                STT.Defs.Pointer_as_UCT.t -> STT.Defs.Pointer_as_UCT.t -> bool
             end

            module PX :
             sig
              module MO :
               sig
                module TO :
                 sig
                  type t = STT.Defs.Pointer_as_UCT.t
                 end

                module IsTO :
                 sig
                 end

                module OrderTac :
                 sig
                 end

                val eq_dec :
                  STT.Defs.Pointer_as_UCT.t -> STT.Defs.Pointer_as_UCT.t ->
                  bool

                val lt_dec :
                  STT.Defs.Pointer_as_UCT.t -> STT.Defs.Pointer_as_UCT.t ->
                  bool

                val eqb :
                  STT.Defs.Pointer_as_UCT.t -> STT.Defs.Pointer_as_UCT.t ->
                  bool
               end
             end

            module L :
             sig
              module MX :
               sig
                module TO :
                 sig
                  type t = STT.Defs.Pointer_as_UCT.t
                 end

                module IsTO :
                 sig
                 end

                module OrderTac :
                 sig
                 end

                val eq_dec :
                  STT.Defs.Pointer_as_UCT.t -> STT.Defs.Pointer_as_UCT.t ->
                  bool

                val lt_dec :
                  STT.Defs.Pointer_as_UCT.t -> STT.Defs.Pointer_as_UCT.t ->
                  bool

                val eqb :
                  STT.Defs.Pointer_as_UCT.t -> STT.Defs.Pointer_as_UCT.t ->
                  bool
               end

              module PX :
               sig
                module MO :
                 sig
                  module TO :
                   sig
                    type t = STT.Defs.Pointer_as_UCT.t
                   end

                  module IsTO :
                   sig
                   end

                  module OrderTac :
                   sig
                   end

                  val eq_dec :
                    STT.Defs.Pointer_as_UCT.t -> STT.Defs.Pointer_as_UCT.t ->
                    bool

                  val lt_dec :
                    STT.Defs.Pointer_as_UCT.t -> STT.Defs.Pointer_as_UCT.t ->
                    bool

                  val eqb :
                    STT.Defs.Pointer_as_UCT.t -> STT.Defs.Pointer_as_UCT.t ->
                    bool
                 end
               end

              type key = STT.Defs.Pointer_as_UCT.t

              type 'elt t = (STT.Defs.Pointer_as_UCT.t * 'elt) list

              val empty : 'a1 t

              val is_empty : 'a1 t -> bool

              val mem : key -> 'a1 t -> bool

              type 'elt coq_R_mem =
              | R_mem_0 of 'elt t
              | R_mem_1 of 'elt t * STT.Defs.Pointer_as_UCT.t * 'elt
                 * (STT.Defs.Pointer_as_UCT.t * 'elt) list
              | R_mem_2 of 'elt t * STT.Defs.Pointer_as_UCT.t * 'elt
                 * (STT.Defs.Pointer_as_UCT.t * 'elt) list
              | R_mem_3 of 'elt t * STT.Defs.Pointer_as_UCT.t * 'elt
                 * (STT.Defs.Pointer_as_UCT.t * 'elt) list * bool
                 * 'elt coq_R_mem

              val coq_R_mem_rect :
                key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 t -> bool -> 'a1
                coq_R_mem -> 'a2

              val coq_R_mem_rec :
                key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> 'a1 t -> bool -> 'a1
                coq_R_mem -> 'a2

              val mem_rect :
                key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2 -> 'a2) -> 'a1 t -> 'a2

              val mem_rec :
                key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2 -> 'a2) -> 'a1 t -> 'a2

              val coq_R_mem_correct : key -> 'a1 t -> bool -> 'a1 coq_R_mem

              val find : key -> 'a1 t -> 'a1 option

              type 'elt coq_R_find =
              | R_find_0 of 'elt t
              | R_find_1 of 'elt t * STT.Defs.Pointer_as_UCT.t * 'elt
                 * (STT.Defs.Pointer_as_UCT.t * 'elt) list
              | R_find_2 of 'elt t * STT.Defs.Pointer_as_UCT.t * 'elt
                 * (STT.Defs.Pointer_as_UCT.t * 'elt) list
              | R_find_3 of 'elt t * STT.Defs.Pointer_as_UCT.t * 'elt
                 * (STT.Defs.Pointer_as_UCT.t * 'elt) list * 'elt option
                 * 'elt coq_R_find

              val coq_R_find_rect :
                key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> 'a1 t -> 'a1
                option -> 'a1 coq_R_find -> 'a2

              val coq_R_find_rec :
                key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) -> 'a1 t -> 'a1
                option -> 'a1 coq_R_find -> 'a2

              val find_rect :
                key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2 -> 'a2) -> 'a1 t -> 'a2

              val find_rec :
                key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2 -> 'a2) -> 'a1 t -> 'a2

              val coq_R_find_correct :
                key -> 'a1 t -> 'a1 option -> 'a1 coq_R_find

              val add : key -> 'a1 -> 'a1 t -> 'a1 t

              type 'elt coq_R_add =
              | R_add_0 of 'elt t
              | R_add_1 of 'elt t * STT.Defs.Pointer_as_UCT.t * 'elt
                 * (STT.Defs.Pointer_as_UCT.t * 'elt) list
              | R_add_2 of 'elt t * STT.Defs.Pointer_as_UCT.t * 'elt
                 * (STT.Defs.Pointer_as_UCT.t * 'elt) list
              | R_add_3 of 'elt t * STT.Defs.Pointer_as_UCT.t * 'elt
                 * (STT.Defs.Pointer_as_UCT.t * 'elt) list * 'elt t
                 * 'elt coq_R_add

              val coq_R_add_rect :
                key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a1 t -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t ->
                'a1 coq_R_add -> 'a2

              val coq_R_add_rec :
                key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a1 t -> 'a1 coq_R_add -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t ->
                'a1 coq_R_add -> 'a2

              val add_rect :
                key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2 -> 'a2) -> 'a1 t -> 'a2

              val add_rec :
                key -> 'a1 -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2 -> 'a2) -> 'a1 t -> 'a2

              val coq_R_add_correct :
                key -> 'a1 -> 'a1 t -> 'a1 t -> 'a1 coq_R_add

              val remove : key -> 'a1 t -> 'a1 t

              type 'elt coq_R_remove =
              | R_remove_0 of 'elt t
              | R_remove_1 of 'elt t * STT.Defs.Pointer_as_UCT.t * 'elt
                 * (STT.Defs.Pointer_as_UCT.t * 'elt) list
              | R_remove_2 of 'elt t * STT.Defs.Pointer_as_UCT.t * 'elt
                 * (STT.Defs.Pointer_as_UCT.t * 'elt) list
              | R_remove_3 of 'elt t * STT.Defs.Pointer_as_UCT.t * 'elt
                 * (STT.Defs.Pointer_as_UCT.t * 'elt) list * 'elt t
                 * 'elt coq_R_remove

              val coq_R_remove_rect :
                key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a1 t -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t ->
                'a1 coq_R_remove -> 'a2

              val coq_R_remove_rec :
                key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a1 t -> 'a1 coq_R_remove -> 'a2 -> 'a2) -> 'a1 t -> 'a1 t ->
                'a1 coq_R_remove -> 'a2

              val remove_rect :
                key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2 -> 'a2) -> 'a1 t -> 'a2

              val remove_rec :
                key -> ('a1 t -> __ -> 'a2) -> ('a1 t ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2) -> ('a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2 -> 'a2) -> 'a1 t -> 'a2

              val coq_R_remove_correct :
                key -> 'a1 t -> 'a1 t -> 'a1 coq_R_remove

              val elements : 'a1 t -> 'a1 t

              val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

              type ('elt, 'a) coq_R_fold =
              | R_fold_0 of 'elt t * 'a
              | R_fold_1 of 'elt t * 'a * STT.Defs.Pointer_as_UCT.t * 
                 'elt * (STT.Defs.Pointer_as_UCT.t * 'elt) list * 'a
                 * ('elt, 'a) coq_R_fold

              val coq_R_fold_rect :
                (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) ->
                ('a1 t -> 'a2 -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> 'a2 -> ('a1,
                'a2) coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a2 ->
                ('a1, 'a2) coq_R_fold -> 'a3

              val coq_R_fold_rec :
                (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) ->
                ('a1 t -> 'a2 -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> 'a2 -> ('a1,
                'a2) coq_R_fold -> 'a3 -> 'a3) -> 'a1 t -> 'a2 -> 'a2 ->
                ('a1, 'a2) coq_R_fold -> 'a3

              val fold_rect :
                (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) ->
                ('a1 t -> 'a2 -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> 'a3 -> 'a3)
                -> 'a1 t -> 'a2 -> 'a3

              val fold_rec :
                (key -> 'a1 -> 'a2 -> 'a2) -> ('a1 t -> 'a2 -> __ -> 'a3) ->
                ('a1 t -> 'a2 -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> 'a3 -> 'a3)
                -> 'a1 t -> 'a2 -> 'a3

              val coq_R_fold_correct :
                (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2 -> ('a1,
                'a2) coq_R_fold

              val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool

              type 'elt coq_R_equal =
              | R_equal_0 of 'elt t * 'elt t
              | R_equal_1 of 'elt t * 'elt t * STT.Defs.Pointer_as_UCT.t
                 * 'elt * (STT.Defs.Pointer_as_UCT.t * 'elt) list
                 * STT.Defs.Pointer_as_UCT.t * 'elt
                 * (STT.Defs.Pointer_as_UCT.t * 'elt) list * bool
                 * 'elt coq_R_equal
              | R_equal_2 of 'elt t * 'elt t * STT.Defs.Pointer_as_UCT.t
                 * 'elt * (STT.Defs.Pointer_as_UCT.t * 'elt) list
                 * STT.Defs.Pointer_as_UCT.t * 'elt
                 * (STT.Defs.Pointer_as_UCT.t * 'elt) list
                 * STT.Defs.Pointer_as_UCT.t compare0
              | R_equal_3 of 'elt t * 'elt t * 'elt t * 'elt t

              val coq_R_equal_rect :
                ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2)
                -> ('a1 t -> 'a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                bool -> 'a1 coq_R_equal -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ ->
                STT.Defs.Pointer_as_UCT.t compare0 -> __ -> __ -> 'a2) ->
                ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2)
                -> 'a1 t -> 'a1 t -> bool -> 'a1 coq_R_equal -> 'a2

              val coq_R_equal_rec :
                ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2)
                -> ('a1 t -> 'a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                bool -> 'a1 coq_R_equal -> 'a2 -> 'a2) -> ('a1 t -> 'a1 t ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ ->
                STT.Defs.Pointer_as_UCT.t compare0 -> __ -> __ -> 'a2) ->
                ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2)
                -> 'a1 t -> 'a1 t -> bool -> 'a1 coq_R_equal -> 'a2

              val equal_rect :
                ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2)
                -> ('a1 t -> 'a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2 -> 'a2) -> ('a1 t -> 'a1 t -> STT.Defs.Pointer_as_UCT.t
                -> 'a1 -> (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ ->
                STT.Defs.Pointer_as_UCT.t compare0 -> __ -> __ -> 'a2) ->
                ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2)
                -> 'a1 t -> 'a1 t -> 'a2

              val equal_rec :
                ('a1 -> 'a1 -> bool) -> ('a1 t -> 'a1 t -> __ -> __ -> 'a2)
                -> ('a1 t -> 'a1 t -> STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ -> __ -> __ ->
                'a2 -> 'a2) -> ('a1 t -> 'a1 t -> STT.Defs.Pointer_as_UCT.t
                -> 'a1 -> (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ ->
                STT.Defs.Pointer_as_UCT.t -> 'a1 ->
                (STT.Defs.Pointer_as_UCT.t * 'a1) list -> __ ->
                STT.Defs.Pointer_as_UCT.t compare0 -> __ -> __ -> 'a2) ->
                ('a1 t -> 'a1 t -> 'a1 t -> __ -> 'a1 t -> __ -> __ -> 'a2)
                -> 'a1 t -> 'a1 t -> 'a2

              val coq_R_equal_correct :
                ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool -> 'a1
                coq_R_equal

              val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

              val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

              val option_cons :
                key -> 'a1 option -> (key * 'a1) list -> (key * 'a1) list

              val map2_l :
                ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a3 t

              val map2_r :
                ('a1 option -> 'a2 option -> 'a3 option) -> 'a2 t -> 'a3 t

              val map2 :
                ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t ->
                'a3 t

              val combine : 'a1 t -> 'a2 t -> ('a1 option * 'a2 option) t

              val fold_right_pair :
                ('a1 -> 'a2 -> 'a3 -> 'a3) -> ('a1 * 'a2) list -> 'a3 -> 'a3

              val map2_alt :
                ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t ->
                (key * 'a3) list

              val at_least_one :
                'a1 option -> 'a2 option -> ('a1 option * 'a2 option) option

              val at_least_one_then_f :
                ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 option -> 'a2
                option -> 'a3 option
             end

            type 'elt coq_R_mem =
            | R_mem_0 of 'elt tree
            | R_mem_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t * bool * 'elt coq_R_mem
            | R_mem_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t
            | R_mem_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t * bool * 'elt coq_R_mem

            val coq_R_mem_rect :
              STT.Defs.Pointer_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1
              tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
              -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> ('a1
              tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
              -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 ->
              'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> bool -> 'a1
              coq_R_mem -> 'a2 -> 'a2) -> 'a1 tree -> bool -> 'a1 coq_R_mem
              -> 'a2

            val coq_R_mem_rec :
              STT.Defs.Pointer_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1
              tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
              -> __ -> __ -> bool -> 'a1 coq_R_mem -> 'a2 -> 'a2) -> ('a1
              tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
              -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 ->
              'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> bool -> 'a1
              coq_R_mem -> 'a2 -> 'a2) -> 'a1 tree -> bool -> 'a1 coq_R_mem
              -> 'a2

            type 'elt coq_R_find =
            | R_find_0 of 'elt tree
            | R_find_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t * 'elt option * 'elt coq_R_find
            | R_find_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t
            | R_find_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t * 'elt option * 'elt coq_R_find

            val coq_R_find_rect :
              STT.Defs.Pointer_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1
              tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
              -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) ->
              ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
              -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key ->
              'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 option
              -> 'a1 coq_R_find -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 option ->
              'a1 coq_R_find -> 'a2

            val coq_R_find_rec :
              STT.Defs.Pointer_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1
              tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
              -> __ -> __ -> 'a1 option -> 'a1 coq_R_find -> 'a2 -> 'a2) ->
              ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
              -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key ->
              'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 option
              -> 'a1 coq_R_find -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 option ->
              'a1 coq_R_find -> 'a2

            type 'elt coq_R_bal =
            | R_bal_0 of 'elt tree * key * 'elt * 'elt tree
            | R_bal_1 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
               key * 'elt * 'elt tree * Z_as_Int.t
            | R_bal_2 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
               key * 'elt * 'elt tree * Z_as_Int.t
            | R_bal_3 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
               key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 
               'elt * 'elt tree * Z_as_Int.t
            | R_bal_4 of 'elt tree * key * 'elt * 'elt tree
            | R_bal_5 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
               key * 'elt * 'elt tree * Z_as_Int.t
            | R_bal_6 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
               key * 'elt * 'elt tree * Z_as_Int.t
            | R_bal_7 of 'elt tree * key * 'elt * 'elt tree * 'elt tree * 
               key * 'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 
               'elt * 'elt tree * Z_as_Int.t
            | R_bal_8 of 'elt tree * key * 'elt * 'elt tree

            val coq_R_bal_rect :
              ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> 'a2)
              -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree
              -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
              'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1
              tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __
              -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ ->
              __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
              __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
              __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
              -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1
              tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1
              tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree ->
              key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree ->
              key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> __ ->
              'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __
              -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
              -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
              -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ ->
              __ -> __ -> __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
              'a1 tree -> 'a1 coq_R_bal -> 'a2

            val coq_R_bal_rec :
              ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> 'a2)
              -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1 tree
              -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
              'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> 'a1
              tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __
              -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ ->
              __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ ->
              __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
              __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __
              -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1
              tree -> __ -> __ -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1
              tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a2) -> ('a1 tree ->
              key -> 'a1 -> 'a1 tree -> __ -> __ -> __ -> __ -> 'a1 tree ->
              key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> __ ->
              'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> __ -> __
              -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
              -> __ -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
              -> __ -> 'a2) -> ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ ->
              __ -> __ -> __ -> 'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
              'a1 tree -> 'a1 coq_R_bal -> 'a2

            type 'elt coq_R_add =
            | R_add_0 of 'elt tree
            | R_add_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t * 'elt tree * 'elt coq_R_add
            | R_add_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t
            | R_add_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t * 'elt tree * 'elt coq_R_add

            val coq_R_add_rect :
              key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree
              -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
              'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1 tree -> 'a1
              tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __
              -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
              Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_add ->
              'a2 -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_add -> 'a2

            val coq_R_add_rec :
              key -> 'a1 -> ('a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree
              -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ ->
              'a1 tree -> 'a1 coq_R_add -> 'a2 -> 'a2) -> ('a1 tree -> 'a1
              tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __
              -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
              Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree -> 'a1 coq_R_add ->
              'a2 -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_add -> 'a2

            type 'elt coq_R_remove_min =
            | R_remove_min_0 of 'elt tree * key * 'elt * 'elt tree
            | R_remove_min_1 of 'elt tree * key * 'elt * 'elt tree
               * 'elt tree * key * 'elt * 'elt tree * Z_as_Int.t
               * ('elt tree * (key * 'elt)) * 'elt coq_R_remove_min
               * 'elt tree * (key * 'elt)

            val coq_R_remove_min_rect :
              ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1 tree
              -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree
              -> Z_as_Int.t -> __ -> ('a1 tree * (key * 'a1)) -> 'a1
              coq_R_remove_min -> 'a2 -> 'a1 tree -> (key * 'a1) -> __ ->
              'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> ('a1
              tree * (key * 'a1)) -> 'a1 coq_R_remove_min -> 'a2

            val coq_R_remove_min_rec :
              ('a1 tree -> key -> 'a1 -> 'a1 tree -> __ -> 'a2) -> ('a1 tree
              -> key -> 'a1 -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree
              -> Z_as_Int.t -> __ -> ('a1 tree * (key * 'a1)) -> 'a1
              coq_R_remove_min -> 'a2 -> 'a1 tree -> (key * 'a1) -> __ ->
              'a2) -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> ('a1
              tree * (key * 'a1)) -> 'a1 coq_R_remove_min -> 'a2

            type 'elt coq_R_merge =
            | R_merge_0 of 'elt tree * 'elt tree
            | R_merge_1 of 'elt tree * 'elt tree * 'elt tree * key * 
               'elt * 'elt tree * Z_as_Int.t
            | R_merge_2 of 'elt tree * 'elt tree * 'elt tree * key * 
               'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 'elt
               * 'elt tree * Z_as_Int.t * 'elt tree * (key * 'elt) * 
               key * 'elt

            val coq_R_merge_rect :
              ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
              'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
              'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
              tree -> Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree
              -> Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> key ->
              'a1 -> __ -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 tree -> 'a1
              coq_R_merge -> 'a2

            val coq_R_merge_rec :
              ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
              'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
              'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
              tree -> Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree
              -> Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> key ->
              'a1 -> __ -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1 tree -> 'a1
              coq_R_merge -> 'a2

            type 'elt coq_R_remove =
            | R_remove_0 of 'elt tree
            | R_remove_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t * 'elt tree * 'elt coq_R_remove
            | R_remove_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t
            | R_remove_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t * 'elt tree * 'elt coq_R_remove

            val coq_R_remove_rect :
              STT.Defs.Pointer_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1
              tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
              -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) ->
              ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
              -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key ->
              'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree ->
              'a1 coq_R_remove -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1
              coq_R_remove -> 'a2

            val coq_R_remove_rec :
              STT.Defs.Pointer_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1
              tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
              -> __ -> __ -> 'a1 tree -> 'a1 coq_R_remove -> 'a2 -> 'a2) ->
              ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
              -> __ -> __ -> __ -> 'a2) -> ('a1 tree -> 'a1 tree -> key ->
              'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __ -> 'a1 tree ->
              'a1 coq_R_remove -> 'a2 -> 'a2) -> 'a1 tree -> 'a1 tree -> 'a1
              coq_R_remove -> 'a2

            type 'elt coq_R_concat =
            | R_concat_0 of 'elt tree * 'elt tree
            | R_concat_1 of 'elt tree * 'elt tree * 'elt tree * key * 
               'elt * 'elt tree * Z_as_Int.t
            | R_concat_2 of 'elt tree * 'elt tree * 'elt tree * key * 
               'elt * 'elt tree * Z_as_Int.t * 'elt tree * key * 'elt
               * 'elt tree * Z_as_Int.t * 'elt tree * (key * 'elt)

            val coq_R_concat_rect :
              ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
              'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
              'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
              tree -> Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree
              -> Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> 'a2) ->
              'a1 tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_concat -> 'a2

            val coq_R_concat_rec :
              ('a1 tree -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1 tree ->
              'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ ->
              'a2) -> ('a1 tree -> 'a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1
              tree -> Z_as_Int.t -> __ -> 'a1 tree -> key -> 'a1 -> 'a1 tree
              -> Z_as_Int.t -> __ -> 'a1 tree -> (key * 'a1) -> __ -> 'a2) ->
              'a1 tree -> 'a1 tree -> 'a1 tree -> 'a1 coq_R_concat -> 'a2

            type 'elt coq_R_split =
            | R_split_0 of 'elt tree
            | R_split_1 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t * 'elt triple * 'elt coq_R_split * 'elt tree
               * 'elt option * 'elt tree
            | R_split_2 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t
            | R_split_3 of 'elt tree * 'elt tree * key * 'elt * 'elt tree
               * Z_as_Int.t * 'elt triple * 'elt coq_R_split * 'elt tree
               * 'elt option * 'elt tree

            val coq_R_split_rect :
              STT.Defs.Pointer_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1
              tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
              -> __ -> __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree
              -> 'a1 option -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
              tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __
              -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
              Z_as_Int.t -> __ -> __ -> __ -> 'a1 triple -> 'a1 coq_R_split
              -> 'a2 -> 'a1 tree -> 'a1 option -> 'a1 tree -> __ -> 'a2) ->
              'a1 tree -> 'a1 triple -> 'a1 coq_R_split -> 'a2

            val coq_R_split_rec :
              STT.Defs.Pointer_as_UCT.t -> ('a1 tree -> __ -> 'a2) -> ('a1
              tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
              -> __ -> __ -> 'a1 triple -> 'a1 coq_R_split -> 'a2 -> 'a1 tree
              -> 'a1 option -> 'a1 tree -> __ -> 'a2) -> ('a1 tree -> 'a1
              tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __ -> __ -> __
              -> 'a2) -> ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree ->
              Z_as_Int.t -> __ -> __ -> __ -> 'a1 triple -> 'a1 coq_R_split
              -> 'a2 -> 'a1 tree -> 'a1 option -> 'a1 tree -> __ -> 'a2) ->
              'a1 tree -> 'a1 triple -> 'a1 coq_R_split -> 'a2

            type ('elt, 'x) coq_R_map_option =
            | R_map_option_0 of 'elt tree
            | R_map_option_1 of 'elt tree * 'elt tree * key * 'elt
               * 'elt tree * Z_as_Int.t * 'x * 'x tree
               * ('elt, 'x) coq_R_map_option * 'x tree
               * ('elt, 'x) coq_R_map_option
            | R_map_option_2 of 'elt tree * 'elt tree * key * 'elt
               * 'elt tree * Z_as_Int.t * 'x tree
               * ('elt, 'x) coq_R_map_option * 'x tree
               * ('elt, 'x) coq_R_map_option

            val coq_R_map_option_rect :
              (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) -> ('a1
              tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
              -> 'a2 -> __ -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3
              -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) ->
              ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
              -> __ -> __ -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3
              -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) ->
              'a1 tree -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3

            val coq_R_map_option_rec :
              (key -> 'a1 -> 'a2 option) -> ('a1 tree -> __ -> 'a3) -> ('a1
              tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
              -> 'a2 -> __ -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3
              -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) ->
              ('a1 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t
              -> __ -> __ -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3
              -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3 -> 'a3) ->
              'a1 tree -> 'a2 tree -> ('a1, 'a2) coq_R_map_option -> 'a3

            type ('elt, 'x0, 'x) coq_R_map2_opt =
            | R_map2_opt_0 of 'elt tree * 'x0 tree
            | R_map2_opt_1 of 'elt tree * 'x0 tree * 'elt tree * key * 
               'elt * 'elt tree * Z_as_Int.t
            | R_map2_opt_2 of 'elt tree * 'x0 tree * 'elt tree * key * 
               'elt * 'elt tree * Z_as_Int.t * 'x0 tree * key * 'x0
               * 'x0 tree * Z_as_Int.t * 'x0 tree * 'x0 option * 'x0 tree
               * 'x * 'x tree * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
               * ('elt, 'x0, 'x) coq_R_map2_opt
            | R_map2_opt_3 of 'elt tree * 'x0 tree * 'elt tree * key * 
               'elt * 'elt tree * Z_as_Int.t * 'x0 tree * key * 'x0
               * 'x0 tree * Z_as_Int.t * 'x0 tree * 'x0 option * 'x0 tree
               * 'x tree * ('elt, 'x0, 'x) coq_R_map2_opt * 'x tree
               * ('elt, 'x0, 'x) coq_R_map2_opt

            val coq_R_map2_opt_rect :
              (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3
              tree) -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2 tree -> __
              -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 ->
              'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a4) -> ('a1 tree -> 'a2
              tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
              -> 'a2 tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ ->
              'a2 tree -> 'a2 option -> 'a2 tree -> __ -> 'a3 -> __ -> 'a3
              tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree ->
              ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree ->
              'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
              __ -> 'a2 tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ ->
              'a2 tree -> 'a2 option -> 'a2 tree -> __ -> __ -> 'a3 tree ->
              ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2,
              'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1 tree -> 'a2 tree ->
              'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4

            val coq_R_map2_opt_rec :
              (key -> 'a1 -> 'a2 option -> 'a3 option) -> ('a1 tree -> 'a3
              tree) -> ('a2 tree -> 'a3 tree) -> ('a1 tree -> 'a2 tree -> __
              -> 'a4) -> ('a1 tree -> 'a2 tree -> 'a1 tree -> key -> 'a1 ->
              'a1 tree -> Z_as_Int.t -> __ -> __ -> 'a4) -> ('a1 tree -> 'a2
              tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t -> __
              -> 'a2 tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ ->
              'a2 tree -> 'a2 option -> 'a2 tree -> __ -> 'a3 -> __ -> 'a3
              tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree ->
              ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> ('a1 tree ->
              'a2 tree -> 'a1 tree -> key -> 'a1 -> 'a1 tree -> Z_as_Int.t ->
              __ -> 'a2 tree -> key -> 'a2 -> 'a2 tree -> Z_as_Int.t -> __ ->
              'a2 tree -> 'a2 option -> 'a2 tree -> __ -> __ -> 'a3 tree ->
              ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4 -> 'a3 tree -> ('a1, 'a2,
              'a3) coq_R_map2_opt -> 'a4 -> 'a4) -> 'a1 tree -> 'a2 tree ->
              'a3 tree -> ('a1, 'a2, 'a3) coq_R_map2_opt -> 'a4

            val fold' : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 tree -> 'a2 -> 'a2

            val flatten_e : 'a1 enumeration -> (key * 'a1) list
           end
         end

        type 'elt bst =
          'elt Raw.tree
          (* singleton inductive, whose constructor was Bst *)

        val this : 'a1 bst -> 'a1 Raw.tree

        type 'elt t = 'elt bst

        type key = STT.Defs.Pointer_as_UCT.t

        val empty : 'a1 t

        val is_empty : 'a1 t -> bool

        val add : key -> 'a1 -> 'a1 t -> 'a1 t

        val remove : key -> 'a1 t -> 'a1 t

        val mem : key -> 'a1 t -> bool

        val find : key -> 'a1 t -> 'a1 option

        val map : ('a1 -> 'a2) -> 'a1 t -> 'a2 t

        val mapi : (key -> 'a1 -> 'a2) -> 'a1 t -> 'a2 t

        val map2 :
          ('a1 option -> 'a2 option -> 'a3 option) -> 'a1 t -> 'a2 t -> 'a3 t

        val elements : 'a1 t -> (key * 'a1) list

        val cardinal : 'a1 t -> nat

        val fold : (key -> 'a1 -> 'a2 -> 'a2) -> 'a1 t -> 'a2 -> 'a2

        val equal : ('a1 -> 'a1 -> bool) -> 'a1 t -> 'a1 t -> bool
       end

      module FMF :
       sig
        val eqb :
          STT.Defs.Pointer_as_UCT.t -> STT.Defs.Pointer_as_UCT.t -> bool

        val coq_In_dec : 'a1 FM.t -> FM.key -> bool
       end

      type coq_Memo =
        ((STT.R.Defs.Strings.coq_String * STT.R.Defs.Strings.coq_String) * STT.Ty.index)
        option Trie.coq_Trie FM.t

      val emptyMemo : coq_Memo

      val get_Memo :
        coq_Memo -> STT.Ty.coq_Pointer -> STT.Ty.index ->
        ((STT.R.Defs.Strings.coq_String * STT.R.Defs.Strings.coq_String) * STT.Ty.index)
        option option

      val set_Memo :
        coq_Memo -> STT.Ty.coq_Pointer -> STT.Ty.index ->
        ((STT.R.Defs.Strings.coq_String * STT.R.Defs.Strings.coq_String) * STT.Ty.index)
        option -> coq_Memo
     end

    module Defs :
     sig
      module NaiveLexer :
       sig
        module LEM :
         sig
          module IMPL :
           sig
            val max_pref_fn :
              STT.R.Defs.Strings.coq_String -> STT.Ty.index ->
              STT.Ty.coq_State ->
              ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
              option

            val extract_fsm_for_max :
              STT.R.Defs.Strings.coq_String -> STT.Ty.index ->
              (STT.Ty.coq_Label * STT.Ty.coq_State) ->
              STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
              option

            val max_prefs :
              STT.R.Defs.Strings.coq_String -> STT.Ty.index ->
              (STT.Ty.coq_Label * STT.Ty.coq_State) list ->
              (STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
              option) list

            val longer_pref :
              (STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
              option) ->
              (STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
              option) ->
              STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
              option

            val max_of_prefs :
              (STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
              option) list ->
              STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
              option

            val init_srule :
              STT.Defs.Coredefs.coq_Rule -> STT.Defs.Coredefs.sRule
           end
         end

        module Lex :
         sig
          val lex' :
            STT.Defs.Coredefs.sRule list -> STT.R.Defs.Strings.coq_String ->
            STT.Ty.index -> STT.Defs.Coredefs.coq_Token
            list * STT.R.Defs.Strings.coq_String

          val lex :
            STT.Defs.Coredefs.coq_Rule list -> STT.R.Defs.Strings.coq_String
            -> STT.Defs.Coredefs.coq_Token
            list * STT.R.Defs.Strings.coq_String
         end
       end

      module NaiveLexerF :
       sig
        module LEM :
         sig
          module IMPL :
           sig
            module LEM :
             sig
              module IMPL :
               sig
                val max_pref_fn :
                  STT.R.Defs.Strings.coq_String -> STT.Ty.index ->
                  STT.Ty.coq_State ->
                  ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
                  option

                val extract_fsm_for_max :
                  STT.R.Defs.Strings.coq_String -> STT.Ty.index ->
                  (STT.Ty.coq_Label * STT.Ty.coq_State) ->
                  STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
                  option

                val max_prefs :
                  STT.R.Defs.Strings.coq_String -> STT.Ty.index ->
                  (STT.Ty.coq_Label * STT.Ty.coq_State) list ->
                  (STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
                  option) list

                val longer_pref :
                  (STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
                  option) ->
                  (STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
                  option) ->
                  STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
                  option

                val max_of_prefs :
                  (STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
                  option) list ->
                  STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
                  option

                val init_srule :
                  STT.Defs.Coredefs.coq_Rule -> STT.Defs.Coredefs.sRule
               end
             end

            module Lex :
             sig
              val lex' :
                STT.Defs.Coredefs.sRule list -> STT.R.Defs.Strings.coq_String
                -> STT.Ty.index -> STT.Defs.Coredefs.coq_Token
                list * STT.R.Defs.Strings.coq_String

              val lex :
                STT.Defs.Coredefs.coq_Rule list ->
                STT.R.Defs.Strings.coq_String -> STT.Defs.Coredefs.coq_Token
                list * STT.R.Defs.Strings.coq_String
             end
           end

          module Lemmas :
           sig
            module IMPL :
             sig
              val max_pref_fn :
                STT.R.Defs.Strings.coq_String -> STT.Ty.index ->
                STT.Ty.coq_State ->
                ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
                option

              val extract_fsm_for_max :
                STT.R.Defs.Strings.coq_String -> STT.Ty.index ->
                (STT.Ty.coq_Label * STT.Ty.coq_State) ->
                STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
                option

              val max_prefs :
                STT.R.Defs.Strings.coq_String -> STT.Ty.index ->
                (STT.Ty.coq_Label * STT.Ty.coq_State) list ->
                (STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
                option) list

              val longer_pref :
                (STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
                option) ->
                (STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
                option) ->
                STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
                option

              val max_of_prefs :
                (STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
                option) list ->
                STT.Ty.coq_Label * ((STT.Defs.Coredefs.coq_Prefix * STT.Defs.Coredefs.coq_Suffix) * STT.Ty.index)
                option

              val init_srule :
                STT.Defs.Coredefs.coq_Rule -> STT.Defs.Coredefs.sRule
             end
           end
         end
       end

      module Invariants :
       sig
       end
     end
   end

  module Correctness :
   sig
    module IMPL :
     sig
      module MEMO :
       sig
        type coq_Memo = MEM.MemTy.coq_Memo

        val emptyMemo : coq_Memo

        val set_Memo :
          coq_Memo -> MEM.STT.Ty.coq_Pointer -> MEM.STT.Ty.index ->
          ((MEM.STT.R.Defs.Strings.coq_String * MEM.STT.R.Defs.Strings.coq_String) * MEM.STT.Ty.index)
          option -> coq_Memo

        val get_Memo :
          coq_Memo -> MEM.STT.Ty.coq_Pointer -> MEM.STT.Ty.index ->
          ((MEM.STT.R.Defs.Strings.coq_String * MEM.STT.R.Defs.Strings.coq_String) * MEM.STT.Ty.index)
          option option
       end

      module Defs :
       sig
        module NaiveLexer :
         sig
          module LEM :
           sig
            module IMPL :
             sig
              val max_pref_fn :
                MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
                MEM.STT.Ty.coq_State ->
                ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                option

              val extract_fsm_for_max :
                MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
                (MEM.STT.Ty.coq_Label * MEM.STT.Ty.coq_State) ->
                MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                option

              val max_prefs :
                MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
                (MEM.STT.Ty.coq_Label * MEM.STT.Ty.coq_State) list ->
                (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                option) list

              val longer_pref :
                (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                option) ->
                (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                option) ->
                MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                option

              val max_of_prefs :
                (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                option) list ->
                MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                option

              val init_srule :
                MEM.STT.Defs.Coredefs.coq_Rule -> MEM.STT.Defs.Coredefs.sRule
             end
           end

          module Lex :
           sig
            val lex' :
              MEM.STT.Defs.Coredefs.sRule list ->
              MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
              MEM.STT.Defs.Coredefs.coq_Token
              list * MEM.STT.R.Defs.Strings.coq_String

            val lex :
              MEM.STT.Defs.Coredefs.coq_Rule list ->
              MEM.STT.R.Defs.Strings.coq_String ->
              MEM.STT.Defs.Coredefs.coq_Token
              list * MEM.STT.R.Defs.Strings.coq_String
           end
         end

        module NaiveLexerF :
         sig
          module LEM :
           sig
            module IMPL :
             sig
              module LEM :
               sig
                module IMPL :
                 sig
                  val max_pref_fn :
                    MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
                    MEM.STT.Ty.coq_State ->
                    ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                    option

                  val extract_fsm_for_max :
                    MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
                    (MEM.STT.Ty.coq_Label * MEM.STT.Ty.coq_State) ->
                    MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                    option

                  val max_prefs :
                    MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
                    (MEM.STT.Ty.coq_Label * MEM.STT.Ty.coq_State) list ->
                    (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                    option) list

                  val longer_pref :
                    (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                    option) ->
                    (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                    option) ->
                    MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                    option

                  val max_of_prefs :
                    (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                    option) list ->
                    MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                    option

                  val init_srule :
                    MEM.STT.Defs.Coredefs.coq_Rule ->
                    MEM.STT.Defs.Coredefs.sRule
                 end
               end

              module Lex :
               sig
                val lex' :
                  MEM.STT.Defs.Coredefs.sRule list ->
                  MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
                  MEM.STT.Defs.Coredefs.coq_Token
                  list * MEM.STT.R.Defs.Strings.coq_String

                val lex :
                  MEM.STT.Defs.Coredefs.coq_Rule list ->
                  MEM.STT.R.Defs.Strings.coq_String ->
                  MEM.STT.Defs.Coredefs.coq_Token
                  list * MEM.STT.R.Defs.Strings.coq_String
               end
             end

            module Lemmas :
             sig
              module IMPL :
               sig
                val max_pref_fn :
                  MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
                  MEM.STT.Ty.coq_State ->
                  ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                  option

                val extract_fsm_for_max :
                  MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
                  (MEM.STT.Ty.coq_Label * MEM.STT.Ty.coq_State) ->
                  MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                  option

                val max_prefs :
                  MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
                  (MEM.STT.Ty.coq_Label * MEM.STT.Ty.coq_State) list ->
                  (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                  option) list

                val longer_pref :
                  (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                  option) ->
                  (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                  option) ->
                  MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                  option

                val max_of_prefs :
                  (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                  option) list ->
                  MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                  option

                val init_srule :
                  MEM.STT.Defs.Coredefs.coq_Rule ->
                  MEM.STT.Defs.Coredefs.sRule
               end
             end
           end
         end

        module Invariants :
         sig
         end
       end

      module L :
       sig
        module IMPL :
         sig
          module LEM :
           sig
            module IMPL :
             sig
              val max_pref_fn :
                MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
                MEM.STT.Ty.coq_State ->
                ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                option

              val extract_fsm_for_max :
                MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
                (MEM.STT.Ty.coq_Label * MEM.STT.Ty.coq_State) ->
                MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                option

              val max_prefs :
                MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
                (MEM.STT.Ty.coq_Label * MEM.STT.Ty.coq_State) list ->
                (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                option) list

              val longer_pref :
                (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                option) ->
                (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                option) ->
                MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                option

              val max_of_prefs :
                (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                option) list ->
                MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
                option

              val init_srule :
                MEM.STT.Defs.Coredefs.coq_Rule -> MEM.STT.Defs.Coredefs.sRule
             end
           end

          module Lex :
           sig
            val lex' :
              MEM.STT.Defs.Coredefs.sRule list ->
              MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
              MEM.STT.Defs.Coredefs.coq_Token
              list * MEM.STT.R.Defs.Strings.coq_String

            val lex :
              MEM.STT.Defs.Coredefs.coq_Rule list ->
              MEM.STT.R.Defs.Strings.coq_String ->
              MEM.STT.Defs.Coredefs.coq_Token
              list * MEM.STT.R.Defs.Strings.coq_String
           end
         end

        module Lemmas :
         sig
          module IMPL :
           sig
            val max_pref_fn :
              MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
              MEM.STT.Ty.coq_State ->
              ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
              option

            val extract_fsm_for_max :
              MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
              (MEM.STT.Ty.coq_Label * MEM.STT.Ty.coq_State) ->
              MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
              option

            val max_prefs :
              MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
              (MEM.STT.Ty.coq_Label * MEM.STT.Ty.coq_State) list ->
              (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
              option) list

            val longer_pref :
              (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
              option) ->
              (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
              option) ->
              MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
              option

            val max_of_prefs :
              (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
              option) list ->
              MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
              option

            val init_srule :
              MEM.STT.Defs.Coredefs.coq_Rule -> MEM.STT.Defs.Coredefs.sRule
           end
         end
       end

      module Utils :
       sig
        val zip : 'a1 list -> 'a2 list -> ('a1 * 'a2) list

        val unzip : ('a1 * 'a2) list -> 'a1 list * 'a2 list

        val ssnd : ('a1 * ('a2 * 'a3)) -> 'a3
       end

      module MPref :
       sig
        val max_pref_fn_M :
          MEMO.coq_Memo -> MEM.STT.R.Defs.Strings.coq_String ->
          MEM.STT.Ty.index -> MEM.STT.Ty.coq_State ->
          MEMO.coq_Memo * ((MEM.STT.R.Defs.Strings.coq_String * MEM.STT.R.Defs.Strings.coq_String) * MEM.STT.Ty.index)
          option

        val extract_fsm_for_max_M :
          MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
          (MEMO.coq_Memo * (MEM.STT.Ty.coq_Label * MEM.STT.Ty.coq_State)) ->
          MEMO.coq_Memo * (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
          option)

        val max_prefs_M :
          MEMO.coq_Memo list -> MEM.STT.R.Defs.Strings.coq_String ->
          MEM.STT.Ty.index -> (MEM.STT.Ty.coq_Label * MEM.STT.Ty.coq_State)
          list -> MEMO.coq_Memo
          list * (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
          option) list

        val max_of_prefs_M :
          (MEMO.coq_Memo
          list * (MEM.STT.Ty.coq_Label * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
          option) list) -> (MEMO.coq_Memo
          list * MEM.STT.Ty.coq_Label) * ((MEM.STT.Defs.Coredefs.coq_Prefix * MEM.STT.Defs.Coredefs.coq_Suffix) * MEM.STT.Ty.index)
          option
       end

      module TypeCheckLemmas :
       sig
        module MemoEq :
         sig
         end

        module Accessible :
         sig
         end

        module Lengths :
         sig
         end

        module LexyClosure :
         sig
         end

        module IndexClosure :
         sig
         end
       end

      module Lex :
       sig
        val lex'_M :
          MEM.STT.R.Defs.Strings.coq_String -> MEMO.coq_Memo list ->
          MEM.STT.Defs.Coredefs.sRule list ->
          MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Ty.index ->
          (MEMO.coq_Memo list * MEM.STT.Defs.Coredefs.coq_Token
          list) * MEM.STT.R.Defs.Strings.coq_String

        val init_srule :
          MEM.STT.Defs.Coredefs.coq_Rule -> MEM.STT.Defs.Coredefs.sRule

        val init_Memos :
          MEM.STT.Defs.Coredefs.sRule list -> MEMO.coq_Memo list

        val lex_M :
          MEM.STT.Defs.Coredefs.coq_Rule list ->
          MEM.STT.R.Defs.Strings.coq_String ->
          MEM.STT.Defs.Coredefs.coq_Token
          list * MEM.STT.R.Defs.Strings.coq_String
       end
     end

    module CaseLemmas :
     sig
     end
   end

  module LitLexer :
   sig
    val lex :
      MEM.STT.Defs.Coredefs.coq_Rule list ->
      MEM.STT.R.Defs.Strings.coq_String -> MEM.STT.Defs.Coredefs.coq_Token
      list * MEM.STT.R.Defs.Strings.coq_String
   end
 end

module PBR :
 sig
  module Coq_builders :
   sig
    val coq_Char_of_nat : nat -> LXR.MEM.STT.R.Defs.Regexes.regex

    val asciiUnion : char list -> LXR.MEM.STT.R.Defs.Regexes.regex

    val stringUnion : char list -> LXR.MEM.STT.R.Defs.Regexes.regex

    val asciiApp : char list -> LXR.MEM.STT.R.Defs.Regexes.regex

    val stringApp : char list -> LXR.MEM.STT.R.Defs.Regexes.regex
   end

  module Coq_whitespace :
   sig
    val tab_ascii : char

    val linebreak_ascii : char

    val carriage_return_ascii : char

    val space_ascii : char

    val ws_chars : char list

    val ws_re : LXR.MEM.STT.R.Defs.Regexes.regex

    val ws_carr_chars : char list

    val ws_carr_re : LXR.MEM.STT.R.Defs.Regexes.regex
   end

  module Coq_numbers :
   sig
    val digit_re : LXR.MEM.STT.R.Defs.Regexes.regex

    val nz_digit_re : LXR.MEM.STT.R.Defs.Regexes.regex

    val zero_re : LXR.MEM.STT.R.Defs.Regexes.regex

    val pos_lz_re : LXR.MEM.STT.R.Defs.Regexes.regex

    val pos_re : LXR.MEM.STT.R.Defs.Regexes.regex

    val nat_lz_re : LXR.MEM.STT.R.Defs.Regexes.regex

    val nat_re : LXR.MEM.STT.R.Defs.Regexes.regex

    val int_lz_re : LXR.MEM.STT.R.Defs.Regexes.regex

    val int_re : LXR.MEM.STT.R.Defs.Regexes.regex

    val int_no_neg0_lz_re : LXR.MEM.STT.R.Defs.Regexes.regex

    val int_no_neg0_re : LXR.MEM.STT.R.Defs.Regexes.regex

    val dec_part_re : LXR.MEM.STT.R.Defs.Regexes.regex

    val dec_lz_re : LXR.MEM.STT.R.Defs.Regexes.regex

    val dec_re : LXR.MEM.STT.R.Defs.Regexes.regex

    val dec_no_neg0_lz_re : LXR.MEM.STT.R.Defs.Regexes.regex

    val dec_no_neg0_re : LXR.MEM.STT.R.Defs.Regexes.regex

    val proper_dec_lz_re : LXR.MEM.STT.R.Defs.Regexes.regex

    val proper_dec_re : LXR.MEM.STT.R.Defs.Regexes.regex

    val proper_dec_no_neg0_lz_re : LXR.MEM.STT.R.Defs.Regexes.regex

    val proper_dec_no_neg0_re : LXR.MEM.STT.R.Defs.Regexes.regex
   end

  module Strings_regex :
   sig
    val coq_AZ_re : LXR.MEM.STT.R.Defs.Regexes.regex

    val az_re : LXR.MEM.STT.R.Defs.Regexes.regex

    val punc_re : LXR.MEM.STT.R.Defs.Regexes.regex

    val quote_re : LXR.MEM.STT.R.Defs.Regexes.regex

    val esc_quote_re : LXR.MEM.STT.R.Defs.Regexes.regex

    val esc_bslash_re : LXR.MEM.STT.R.Defs.Regexes.regex

    val char_re : LXR.MEM.STT.R.Defs.Regexes.regex

    val string_re : LXR.MEM.STT.R.Defs.Regexes.regex
   end
 end

val ru_ws : LXR.MEM.STT.Defs.Coredefs.coq_Rule

val exp_part_re : LXR.MEM.STT.R.Defs.Regexes.regex

val float_re : LXR.MEM.STT.R.Defs.Regexes.regex

val ru_float : LABELS.coq_Label' * LXR.MEM.STT.R.Defs.Regexes.regex

val ru_int : LABELS.coq_Label' * LXR.MEM.STT.R.Defs.Regexes.regex

val unicode_digit_re : LXR.MEM.STT.R.Defs.Regexes.regex

val four_unicode_digits_re : LXR.MEM.STT.R.Defs.Regexes.regex

val unicode_codepoint_re : LXR.MEM.STT.R.Defs.Regexes.regex

val json_char_re : LXR.MEM.STT.R.Defs.Regexes.regex

val json_string_re : LXR.MEM.STT.R.Defs.Regexes.regex

val ru_string : LABELS.coq_Label' * LXR.MEM.STT.R.Defs.Regexes.regex

val ru_true : LABELS.coq_Label' * LXR.MEM.STT.R.Defs.Regexes.regex

val ru_false : LABELS.coq_Label' * LXR.MEM.STT.R.Defs.Regexes.regex

val ru_null : LABELS.coq_Label' * LXR.MEM.STT.R.Defs.Regexes.regex

val ru_colon : LABELS.coq_Label' * LXR.MEM.STT.R.Defs.Regexes.regex

val ru_comma : LABELS.coq_Label' * LXR.MEM.STT.R.Defs.Regexes.regex

val ru_lbrack : LABELS.coq_Label' * LXR.MEM.STT.R.Defs.Regexes.regex

val ru_rbrack : LABELS.coq_Label' * LXR.MEM.STT.R.Defs.Regexes.regex

val ru_lbrace : LABELS.coq_Label' * LXR.MEM.STT.R.Defs.Regexes.regex

val ru_rbrace : LABELS.coq_Label' * LXR.MEM.STT.R.Defs.Regexes.regex

val rus : LXR.MEM.STT.Defs.Coredefs.coq_Rule list

module SemLexerFn :
 functor (STT:Coq_T) ->
 functor (LXR__2:sig
  val lex :
    STT.Defs.Coredefs.coq_Rule list -> STT.R.Defs.Strings.coq_String ->
    STT.Defs.Coredefs.coq_Token list * STT.R.Defs.Strings.coq_String
 end) ->
 functor (USER:sig
  type sem_ty

  val apply_sem :
    (STT.Ty.coq_Label * STT.R.Defs.Strings.coq_String) -> (STT.Ty.coq_Label,
    sem_ty) sigT option

  val defLiteral : sem_ty
 end) ->
 sig
  module Core :
   sig
    type sem_token = (STT.Ty.coq_Label, USER.sem_ty) sigT

    val defSemToken : (STT.Ty.coq_Label, USER.sem_ty) sigT
   end

  module Spec :
   sig
   end

  module Impl :
   sig
    val lex_sem' :
      STT.Defs.Coredefs.coq_Rule list -> STT.R.Defs.Strings.coq_String ->
      Core.sem_token option list * STT.R.Defs.Strings.coq_String

    val lo2ol : 'a1 option list -> 'a1 list option

    val lex_sem :
      STT.Defs.Coredefs.coq_Rule list -> STT.R.Defs.Strings.coq_String ->
      Core.sem_token list option * STT.R.Defs.Strings.coq_String
   end

  module Lemmas :
   sig
   end

  module Correct :
   sig
   end
 end

module USER :
 sig
  type sem_ty = __

  val defLiteral : sem_ty

  val coq_String2uint' : LXR.MEM.STT.R.Defs.Strings.coq_String -> z option

  val coq_String2int' : LXR.MEM.STT.R.Defs.Strings.coq_String -> z option

  val coq_String2int : LXR.MEM.STT.R.Defs.Strings.coq_String -> z option

  val apply_sem :
    (LXR.MEM.STT.Ty.coq_Label * LXR.MEM.STT.R.Defs.Strings.coq_String) ->
    (LXR.MEM.STT.Ty.coq_Label, sem_ty) sigT option
 end

module SemLexer :
 sig
  module Core :
   sig
    type sem_token = (LXR.MEM.STT.Ty.coq_Label, USER.sem_ty) sigT

    val defSemToken : (LXR.MEM.STT.Ty.coq_Label, USER.sem_ty) sigT
   end

  module Spec :
   sig
   end

  module Impl :
   sig
    val lex_sem' :
      LXR.MEM.STT.Defs.Coredefs.coq_Rule list ->
      LXR.MEM.STT.R.Defs.Strings.coq_String -> Core.sem_token option
      list * LXR.MEM.STT.R.Defs.Strings.coq_String

    val lo2ol : 'a1 option list -> 'a1 list option

    val lex_sem :
      LXR.MEM.STT.Defs.Coredefs.coq_Rule list ->
      LXR.MEM.STT.R.Defs.Strings.coq_String -> Core.sem_token list
      option * LXR.MEM.STT.R.Defs.Strings.coq_String
   end

  module Lemmas :
   sig
   end

  module Correct :
   sig
   end
 end
